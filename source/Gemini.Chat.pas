unit Gemini.Chat;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, Gemini.API.Params, Gemini.API, Gemini.Safety, Gemini.Schema,
  Gemini.Tools, Gemini.Async.Support;

type
  TMessageRole = (
    user,
    model,
    &function
  );

  TMessageRoleHelper = record helper for TMessageRole
    function ToString: string;
    class function Create(const Value: string): TMessageRole; static;
  end;

  TMessageRoleInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TFinishReason = (
    /// <summary>
    /// Default value. This value is unused.
    /// </summary>
    FINISH_REASON_UNSPECIFIED,
    /// <summary>
    /// Natural stop point of the model or provided stop sequence.
    /// </summary>
    STOP,
    /// <summary>
    /// The maximum number of tokens as specified in the request was reached.
    /// </summary>
    MAX_TOKENS,
    /// <summary>
    /// The response candidate content was flagged for safety reasons.
    /// </summary>
    SAFETY,
    /// <summary>
    /// The response candidate content was flagged for recitation reasons.
    /// </summary>
    RECITATION,
    /// <summary>
    /// The response candidate content was flagged for using an unsupported language.
    /// </summary>
    LANGUAGE,
    /// <summary>
    ///  Unknown reason.
    /// </summary>
    OTHER,
    /// <summary>
    /// Token generation stopped because the content contains forbidden terms.
    /// </summary>
    BLOCKLIST,
    /// <summary>
    /// Token generation stopped for potentially containing prohibited content.
    /// </summary>
    PROHIBITED_CONTENT,
    /// <summary>
    /// Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).
    /// </summary>
    SPII,
    /// <summary>
    /// The function call generated by the model is invalid.
    /// </summary>
    MALFORMED_FUNCTION_CALL
  );

  TFinishReasonHelper = record helper for TFinishReason
    function ToString: string;
    class function Create(const Value: string): TFinishReason; static;
  end;

  TFinishReasonInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TLangueType = (
    /// <summary>
    /// Language not specified. This value should not be used.
    /// </summary>
    LANGUAGE_UNSPECIFIED,
    /// <summary>
    /// Python >= 3.10, with numpy and simpy available
    /// </summary>
    PYTHON
  );

  TLangueTypeHelper = record helper for TLangueType
    function ToString: string;
    class function Create(const Value: string): TLangueType; static;
  end;

  TLangueTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TOutcomeType = (
    /// <summary>
    /// State not specified. This value should not be used.
    /// </summary>
    OUTCOME_UNSPECIFIED,
    /// <summary>
    /// The code execution was successful.
    /// </summary>
    OUTCOME_OK,
    /// <summary>
    /// Code execution completed, but with failure. stderr should contain the reason.
    /// </summary>
    OUTCOME_FAILED,
    /// <summary>
    /// Code execution took too long and was canceled. Partial output may or may not be present.
    /// </summary>
    OUTCOME_DEADLINE_EXCEEDED
  );

  TOutcomeTypeHelper = record helper for TOutcomeType
    function ToString: string;
    class function Create(const Value: string): TOutcomeType; static;
  end;

  TOutcomeTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TInlineData = class(TJSONParam)
    function MimeType(const Value: string): TInlineData;
    function Data(const Value: string): TInlineData;
  end;

  TFileData = class(TJSONParam)
    function MimeType(const Value: string): TFileData;
    function FileUri(const Value: string): TFileData;
  end;

  TTextData = class(TJSONParam)
    function Text(const Value: string): TTextData;
  end;

  TContentPayload = class(TJSONParam)
  public
    function Role(const Value: TMessageRole): TContentPayload;
    function Parts(const Value: string; const Attached: TArray<string>): TContentPayload; overload;
    function Parts(const Attached: TArray<string>): TContentPayload; overload;
    class function Add(const Text: string; const Attached: TArray<string> = []): TContentPayload; reintroduce; overload;
    class function Add(const Role: TMessageRole;
      const Attached: TArray<string> = []): TContentPayload; reintroduce; overload;
    class function Add(const Role: TMessageRole; const Text: string;
      const Attached: TArray<string> = []): TContentPayload; reintroduce; overload;
    class function New(const ParamProc: TProcRef<TContentPayload>): TContentPayload; static;
  end;

  TGenerationConfig = class(TJSONParam)
  public
    function StopSequences(const Value: TArray<string>): TGenerationConfig;
    function ResponseMimeType(const Value: string): TGenerationConfig;
    function ResponseSchema(const Value: TSchemaParams): TGenerationConfig; overload;
    function ResponseSchema(const ParamProc: TProcRef<TSchemaParams>): TGenerationConfig; overload;
    function CandidateCount(const Value: Integer): TGenerationConfig;
    function MaxOutputTokens(const Value: Integer): TGenerationConfig;
    function Temperature(const Value: Double): TGenerationConfig;
    function TopP(const Value: Double): TGenerationConfig;
    function TopK(const Value: Integer): TGenerationConfig;
    function PresencePenalty(const Value: Double): TGenerationConfig;
    function FrequencyPenalty(const Value: Double): TGenerationConfig;
    function ResponseLogprobs(const Value: Boolean): TGenerationConfig;
    function Logprobs(const Value: Integer): TGenerationConfig;
    class function New(const ParamProc: TProcRef<TGenerationConfig>): TGenerationConfig; overload;
  end;

  TChatParams = class(TJSONParam)
    function Contents(const Value: TArray<TContentPayload>): TChatParams;
    function Tools(const Value: TArray<TToolPluginParams>): TChatParams;
    function ToolConfig(const Value: TToolMode; AllowedFunctionNames: TArray<string> = []): TChatParams;
    function SafetySettings(const Value: TArray<TSafety>): TChatParams;
    function SystemInstruction(const Value: string): TChatParams;
    function GenerationConfig(const ParamProc: TProcRef<TGenerationConfig>): TChatParams;
    function CachedContent(const Value: string): TChatParams;
    class function New(const ParamProc: TProcRef<TChatParams>): TChatParams; overload;
  end;

  TArgsFixInterceptor = class(TJSONInterceptorStringToString)
  public
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TFunctionCall = class
  private
    FName: string;
    [JsonReflectAttribute(ctString, rtString, TArgsFixInterceptor)]
    FArgs: string;
  public
    property Name: string read FName write FName;
    property Args: string read FArgs write FArgs;
  end;

  TInlineDataPart = class
  private
    FMimeType: string;
    FData: string;
  public
    property MimeType: string read FMimeType write FMimeType;
    property Data: string read FData write FData;
  end;

  TFileDataPart = class
  private
    FMimeType: string;
    FFileUri: string;
  public
    property MimeType: string read FMimeType write FMimeType;
    property FileUri: string read FFileUri write FFileUri;
  end;

//  TFunctionResponsePart = class
//  private
//
//  public
//  end;

  TExecutableCodePart = class
  private
    [JsonReflectAttribute(ctString, rtString, TLangueTypeInterceptor)]
    FLanguage: TLangueType;
    FCode: string;
  public
    property Language: TLangueType read FLanguage write FLanguage;
    property Code: string read FCode write FCode;
  end;

  TCodeExecutionResult = class
  private
    [JsonReflectAttribute(ctString, rtString, TOutcomeTypeInterceptor)]
    FOutcome: TOutcomeType;
    FOutput: string;
  public
    property Outcome: TOutcomeType read FOutcome write FOutcome;
    property Output: string read FOutput write FOutput;
  end;

  TChatPart = class
  private
    FText: string;
    FFunctionCall: TFunctionCall;
    FInlineData: TInlineDataPart;
    FFileData: TFileDataPart;
    FExecutableCode: TExecutableCodePart;
    FCodeExecutionResult: TCodeExecutionResult;
  public
    property Text: string read FText write FText;
    property FunctionCall: TFunctionCall read FFunctionCall write FFunctionCall;
    property InlineData: TInlineDataPart read FInlineData write FInlineData;
    property FileData: TFileDataPart read FFileData write FFileData;
    property ExecutableCode: TExecutableCodePart read FExecutableCode write FExecutableCode;
    property CodeExecutionResult: TCodeExecutionResult read FCodeExecutionResult write FCodeExecutionResult;
    destructor Destroy; override;
  end;

  TChatContent = class
  private
    FParts: TArray<TChatPart>;
    [JsonReflectAttribute(ctString, rtString, TMessageRoleInterceptor)]
    FRole: TMessageRole;
  public
    property Parts: TArray<TChatPart> read FParts write FParts;
    property Role: TMessageRole read FRole write FRole;
    destructor Destroy; override;
  end;

  TSafetyRatings = class
  private
    [JsonReflectAttribute(ctString, rtString, THarmCategoryInterceptor)]
    FCategory: THarmCategory;
    [JsonReflectAttribute(ctString, rtString, THarmProbabilityInterceptor)]
    FProbability: THarmProbability;
    FBlocked: Boolean;
  public
    property Category: THarmCategory read FCategory write FCategory;
    property Probability: THarmProbability read FProbability write FProbability;
    property Blocked: Boolean read FBlocked write FBlocked;
  end;

  TCitationSource = class
  private
    FStartIndex: Int64;
    FEndIndex: Int64;
    FUri: string;
    FLicense: string;
  public
    property StartIndex: Int64 read FStartIndex write FStartIndex;
    property EndIndex: Int64 read FEndIndex write FEndIndex;
    property Uri: string read FUri write FUri;
    property License: string read FLicense write FLicense;
  end;

  TCitationMetadata = class
  private
    FCitationSources: TArray<TCitationSource>;
  public
    property CitationSources: TArray<TCitationSource> read FCitationSources write FCitationSources;
    destructor Destroy; override;
  end;

  TCandidate = class
  private
    FToken: string;
    FTokenId: Int64;
    FLogProbability: Double;
  public
    property Token: string read FToken write FToken;
    property TokenId: Int64 read FTokenId write FTokenId;
    property LogProbability: Double read FLogProbability write FLogProbability;
  end;

  TTopCandidates = class
  private
    FCandidates: TArray<TCandidate>;
  public
    property Candidates: TArray<TCandidate> read Fcandidates write Fcandidates;
  end;

  TLogprobsResult = class
  private
    FTopCandidates: TArray<TTopCandidates>;
    FChosenCandidates: TArray<TCandidate>;
  public
    property TopCandidates: TArray<TTopCandidates> read FTopCandidates write FTopCandidates;
    property ChosenCandidates: TArray<TCandidate> read FChosenCandidates write FChosenCandidates;
    destructor Destroy; override;
  end;

  TChatCandidate = class
  private
    FContent: TChatContent;
    [JsonReflectAttribute(ctString, rtString, TFinishReasonInterceptor)]
    FFinishReason: TFinishReason;
    FSafetyRatings: TArray<TSafetyRatings>;
    FCitationMetadata: TCitationMetadata;
    FTokenCount: Int64;
    FAvgLogprobs: Double;
    FLogprobsResult: TLogprobsResult;
    FIndex: Int64;
  public
    property Content: TChatContent read FContent write FContent;
    property FinishReason: TFinishReason read FFinishReason write FFinishReason;
    property SafetyRatings: TArray<TSafetyRatings> read FSafetyRatings write FSafetyRatings;
    property CitationMetadata: TCitationMetadata read FCitationMetadata write FCitationMetadata;
    property TokenCount: Int64 read FTokenCount write FTokenCount;
    property AvgLogprobs: Double read FAvgLogprobs write FAvgLogprobs;
    property LogprobsResult: TLogprobsResult read FLogprobsResult write FLogprobsResult;
    property Index: Int64 read FIndex write FIndex;
    destructor Destroy; override;
  end;

  TPromptFeedback = class
  private
    [JsonReflectAttribute(ctString, rtString, TBlockReasonInterceptor)]
    FBlockReason: TBlockReason;
    FSafetyRatings: TArray<TsafetyRatings>;
  public
    property BlockReason: TBlockReason read FBlockReason write FBlockReason;
    property SafetyRatings: TArray<TsafetyRatings> read FSafetyRatings write FSafetyRatings;
    destructor Destroy; override;
  end;

  TUsageMetadata = class
  private
    FPromptTokenCount: Int64;
    FCachedContentTokenCount: Int64;
    FCandidatesTokenCount: Int64;
    FTotalTokenCount: Int64;
  public
    property PromptTokenCount: Int64 read FPromptTokenCount write FPromptTokenCount;
    property CachedContentTokenCount: Int64 read FCachedContentTokenCount write FCachedContentTokenCount;
    property CandidatesTokenCount: Int64 read FCandidatesTokenCount write FCandidatesTokenCount;
    property TotalTokenCount: Int64 read FTotalTokenCount write FTotalTokenCount;
  end;

  TChat = class
  private
    FCandidates: TArray<TChatCandidate>;
    FPromptFeedback: TPromptFeedback;
    FUsageMetadata: TUsageMetadata;
  public
    property Candidates: TArray<TChatCandidate> read FCandidates write FCandidates;
    property PromptFeedback: TPromptFeedback read FPromptFeedback write FPromptFeedback;
    property UsageMetadata: TUsageMetadata read FUsageMetadata write FUsageMetadata;
    destructor Destroy; override;
  end;

  TChatEvent = reference to procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean);

  TAsynChat = TAsynCallBack<TChat>;

  TAsynChatStream = TAsynStreamCallBack<TChat>;

  TChatRoute = class(TGeminiAPIRoute)
  private
    procedure ResetStream;
  public
    procedure AsynCreate(const ModelName: string; ParamProc: TProc<TChatParams>;
      CallBacks: TFunc<TAsynChat>);
    procedure AsynCreateStream(const ModelName: string; ParamProc: TProc<TChatParams>;
      CallBacks: TFunc<TAsynChatStream>);

    function Create(const ModelName: string; ParamProc: TProc<TChatParams>): TChat;
    function CreateStream(const ModelName: string; ParamProc: TProc<TChatParams>; Event: TChatEvent): Boolean;
  end;

implementation

uses
  System.StrUtils, System.Math, System.Rtti, Rest.Json, Gemini.Async.Params,
  Gemini.NetEncoding.Base64;

type
  TAttachedManager = record
  private
    function IsUri(const FilePath: string): Boolean;
    function GetMimeType(const FilePath: string): string;
    function GetEncoded(const FilePath: string): string;
  public
    function ToJson(const FilePath: string): TJSONObject;
  end;

{ TChatRoute }

procedure TChatRoute.AsynCreate(const ModelName: string;
  ParamProc: TProc<TChatParams>; CallBacks: TFunc<TAsynChat>);
begin
  with TAsynCallBackExec<TAsynChat, TChat>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.Create(ModelName, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TChatRoute.AsynCreateStream(const ModelName: string;
  ParamProc: TProc<TChatParams>; CallBacks: TFunc<TAsynChatStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynChatStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ModelName, ParamProc,
                procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Chat) then
                    begin
                      var LocalChat := Chat;
                      Chat := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalChat);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalChat.Free;
                          end;
                        end);
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

function TChatRoute.Create(const ModelName: string; ParamProc: TProc<TChatParams>): TChat;
begin
  GeminiLock.Acquire;
  try
    Result := API.Post<TChat, TChatParams>(SetModel(ModelName, ':generateContent'), ParamProc);
  finally
    GeminiLock.Release;
  end;
end;

function TChatRoute.CreateStream(const ModelName: string; ParamProc: TProc<TChatParams>;
  Event: TChatEvent): Boolean;
var
  Response: TStringStream;
  RetPos: Integer;
  Prev: Integer;
  Starting: Boolean;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    RetPos := 0;
    Prev := 0;
    Starting := True;
    Result := API.Post<TChatParams>(SetModel(ModelName, ':streamGenerateContent'), ParamProc, Response,
      procedure(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var AAbort: Boolean)
      var
        IsDone: Boolean;
        Data: string;
        Chat: TChat;
        TextBuffer: string;
        Line: string;
        Ret: Integer;
      begin
        try
          TextBuffer := Response.DataString;
        except
          on E: EEncodingError do
            Exit;
        end;

        Ret := TextBuffer.Length - 1;
        Line := TextBuffer.Substring(RetPos, Ret - RetPos);
        RetPos := Ret + 1;

        Chat := nil;
        Data := Line.Trim([' ', #13, #10]);
        Data := Copy(Data, 2, Data.Length-1);

        IsDone := not Starting and Data.IsEmpty;
        Starting := False;

        if not IsDone then
          try
            Chat := TJson.JsonToObject<TChat>(Data);
            Prev := RetPos;
          except
            Chat := nil;
            RetPos := Prev;
          end;

        try
          Event(Chat, IsDone, AAbort);
        finally
          Chat.Free;
        end;

      end);
  finally
    ResetStream;
    Response.Free;
  end;
end;

procedure TChatRoute.ResetStream;
begin
  AsynCreate('gemini-1.5-pro',
    procedure (Params : TChatParams)
    begin
      Params.Contents([TContentPayload.Add(user, 'nill')]);
    end,
    function : TAsynChat
    begin
    end);
end;

{ TChatParams }

function TChatParams.CachedContent(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('cachedContent', Value));
end;

function TChatParams.Contents(
  const Value: TArray<TContentPayload>): TChatParams;
begin
  var JSONContents := TJSONArray.Create;
  for var Item in Value do
    JSONContents.Add(Item.Detach);
  Result := TChatParams(Add('contents', JSONContents));
end;

function TChatParams.GenerationConfig(const ParamProc: TProcRef<TGenerationConfig>): TChatParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TGenerationConfig.Create;
      ParamProc(Value);
      Result := TChatParams(Add('generationConfig', Value.Detach));
    end
  else Result := Self;
end;

class function TChatParams.New(
  const ParamProc: TProcRef<TChatParams>): TChatParams;
begin
  Result := TChatParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TChatParams.SafetySettings(
  const Value: TArray<TSafety>): TChatParams;
begin
  var JSONSafetySettings := TJSONArray.Create;
  for var Item in Value do
    JSONSafetySettings.Add(Item.ToJson);
  Result := TChatParams(Add('safetySettings', JSONSafetySettings));
end;

function TChatParams.SystemInstruction(const Value: string): TChatParams;
begin
  var PartsJSON := TJSONObject.Create.AddPair('parts', TJSONObject.Create.AddPair('text', Value));
  Result := TChatParams(Add('system_instruction', PartsJSON));
end;

function TChatParams.ToolConfig(const Value: TToolMode; AllowedFunctionNames: TArray<string>): TChatParams;
begin
  var Temp := TJSONObject.Create.AddPair('mode', Value.ToString);
  if Length(AllowedFunctionNames) > 0 then
    begin
      var JSONArray := TJSONArray.Create;
      for var Item in AllowedFunctionNames do
        begin
          JSONArray.Add(Item);
        end;
      Temp.AddPair('allowedFunctionNames', JSONArray);
    end;

  Result := TChatParams(Add('toolConfig',
              TJSONObject.Create.AddPair('function_calling_config', Temp)));
end;

function TChatParams.Tools(const Value: TArray<TToolPluginParams>): TChatParams;
begin
  var JSONFuncs := TJSONArray.Create;
  for var Item in value do
    begin
      JSONFuncs.Add(Item.ToJson);
    end;
  var JSONDeclaration := TJSONObject.Create.AddPair('function_declarations', JSONFuncs);

  var JSONTool := TJSONArray.Create.Add(JSONDeclaration);

  Result := TChatParams(Add('tools', JSONTool));
end;

{ TMessageRoleHelper }

class function TMessageRoleHelper.Create(const Value: string): TMessageRole;
begin
  var index := IndexStr(AnsiLowerCase(Value), ['user', 'model', 'function']);
  if index = -1 then
    raise Exception.Create('String role value not correct');
  Result := TMessageRole(index);
end;

function TMessageRoleHelper.ToString: string;
begin
  case Self of
    user:
      Exit('user');
    model:
      Exit('model');
    &function:
      Exit('function');
  end;
end;

{ TChat }

destructor TChat.Destroy;
begin
  for var Item in FCandidates do
    Item.Free;
  if Assigned(FPromptFeedback) then
    FPromptFeedback.Free;
  if Assigned(FUsageMetadata) then
    FUsageMetadata.Free;
  inherited;
end;

{ TChatCandidate }

destructor TChatCandidate.Destroy;
begin
  if Assigned(FContent) then
    FContent.Free;
  for var Item in FSafetyRatings do
    Item.Free;
  if Assigned(FCitationMetadata) then
    FCitationMetadata.Free;
  if Assigned(FlogprobsResult) then
    FlogprobsResult.Free;
  inherited;
end;

{ TChatContent }

destructor TChatContent.Destroy;
begin
  for var Item in FParts do
    Item.Free;
  inherited;
end;

{ TPromptFeedback }

destructor TPromptFeedback.Destroy;
begin
  for var Item in FSafetyRatings do
    Item.Free;
  inherited;
end;

{ TFinishReasonHelper }

class function TFinishReasonHelper.Create(const Value: string): TFinishReason;
begin
  var Index := IndexStr(AnsiUpperCase(Value), [
         'FINISH_REASON_UNSPECIFIED', 'STOP', 'MAX_TOKENS', 'SAFETY',
         'RECITATION', 'LANGUAGE', 'OTHER', 'BLOCKLIST', 'PROHIBITED_CONTENT',
         'SPII', 'MALFORMED_FUNCTION_CALL']);
  if Index = -1 then
    raise Exception.CreateFmt('"FinishReason" unknown : %s', [Value]);
  Result := TFinishReason(Index);
end;

function TFinishReasonHelper.ToString: string;
begin
  case Self of
    FINISH_REASON_UNSPECIFIED:
      Exit('FINISH_REASON_UNSPECIFIED');
    STOP:
      Exit('STOP');
    MAX_TOKENS:
      Exit('MAX_TOKENS');
    SAFETY:
      Exit('SAFETY');
    RECITATION:
      Exit('RECITATION');
    LANGUAGE:
      Exit('LANGUAGE');
    OTHER:
      Exit('OTHER');
    BLOCKLIST:
      Exit('BLOCKLIST');
    PROHIBITED_CONTENT:
      Exit('PROHIBITED_CONTENT');
    SPII:
      Exit('SPII');
    MALFORMED_FUNCTION_CALL:
      Exit('MALFORMED_FUNCTION_CALL');
  end;
end;

{ TFinishReasonInterceptor }

function TFinishReasonInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFinishReason>.ToString;
end;

procedure TFinishReasonInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFinishReason.Create(Arg)));
end;

{ TCitationMetadata }

destructor TCitationMetadata.Destroy;
begin
  for var Item in FCitationSources do
    Item.Free;
  inherited;
end;

{ TLogprobsResult }

destructor TLogprobsResult.Destroy;
begin
  for var Item in FTopCandidates do
    Item.Free;
  for var Item in FChosenCandidates do
    Item.Free;
  inherited;
end;

{ TGenerationConfig }

function TGenerationConfig.CandidateCount(
  const Value: Integer): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('candidateCount', Value));
end;

function TGenerationConfig.FrequencyPenalty(
  const Value: Double): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('frequencyPenalty', Value));
end;

function TGenerationConfig.Logprobs(const Value: Integer): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('logprobs', Value));
end;

function TGenerationConfig.MaxOutputTokens(const Value: Integer): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('maxOutputTokens', Value));
end;

class function TGenerationConfig.New(
  const ParamProc: TProcRef<TGenerationConfig>): TGenerationConfig;
begin
  Result := TGenerationConfig.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TGenerationConfig.PresencePenalty(
  const Value: Double): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('presencePenalty', Value));
end;

function TGenerationConfig.ResponseLogprobs(
  const Value: Boolean): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('responseLogprobs', Value));
end;

function TGenerationConfig.ResponseMimeType(const Value: string): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('responseMimeType', Value));
end;

function TGenerationConfig.ResponseSchema(
  const ParamProc: TProcRef<TSchemaParams>): TGenerationConfig;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := TGenerationConfig(Add('responseSchema', Value.Detach));
    end
  else Result := Self;
end;

function TGenerationConfig.ResponseSchema(
  const Value: TSchemaParams): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('responseSchema', Value.Detach));
end;

function TGenerationConfig.StopSequences(
  const Value: TArray<string>): TGenerationConfig;
begin
  if Length(Value) = 0 then
    Exit(Self);

  Result := TGenerationConfig(Add('stopSequences', Value));
end;

function TGenerationConfig.Temperature(const Value: Double): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('temperature', Value));
end;

function TGenerationConfig.TopK(const Value: Integer): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('topK', Value));
end;

function TGenerationConfig.TopP(const Value: Double): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('topP', Value));
end;

{ TMessageRoleInterceptor }

function TMessageRoleInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TMessageRole>.ToString;
end;

procedure TMessageRoleInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TMessageRole.Create(Arg)));
end;

{ TChatPart }

destructor TChatPart.Destroy;
begin
  if Assigned(FFunctionCall) then
    FFunctionCall.Free;
  if Assigned(FInlineData) then
    FInlineData.Free;
  if Assigned(FFileData) then
    FFileData.Free;
  if Assigned(FExecutableCode) then
    FExecutableCode.Free;
  if Assigned(FCodeExecutionResult) then
    FCodeExecutionResult.Free;
  inherited;
end;

{ TArgsFixInterceptor }

procedure TArgsFixInterceptor.StringReverter(Data: TObject; Field, Arg: string);
begin
  Arg := Format('{%s}', [Trim(Arg.Replace('`', '"').Replace(#10, ''))]);
  while Arg.Contains(', ') do Arg := Arg.Replace(', ', ',');
  Arg := Arg.Replace(',', ', ');
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, Arg);
end;

{ TContentPayload }

class function TContentPayload.Add(const Role: TMessageRole;
  const Text: string; const Attached: TArray<string>): TContentPayload;
begin
  Result := TContentPayload.Create.Role(Role).Parts(Text, Attached);
end;

class function TContentPayload.Add(const Role: TMessageRole;
  const Attached: TArray<string>): TContentPayload;
begin
  Result := TContentPayload.Create.Role(Role).Parts(Attached);
end;

class function TContentPayload.New(
  const ParamProc: TProcRef<TContentPayload>): TContentPayload;
begin
  Result := TContentPayload.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TContentPayload.Parts(const Attached: TArray<string>): TContentPayload;
var
  Convert: TAttachedManager;
begin
  var JSONParts := TJSONArray.Create;
  for var Item in Attached do
    JSONParts.Add(Convert.ToJson(Item));
  Result := TContentPayload(Add('parts', JSONParts));
end;

class function TContentPayload.Add(const Text: string;
  const Attached: TArray<string>): TContentPayload;
begin
  Result := TContentPayload.Create.Parts(Text, Attached);
end;

function TContentPayload.Role(const Value: TMessageRole): TContentPayload;
begin
  Result := TContentPayload(Add('role', Value.ToString));
end;

function TContentPayload.Parts(const Value: string;
  const Attached: TArray<string>): TContentPayload;
var
  Convert: TAttachedManager;
begin
  var JSONParts := TJSONArray.Create;
  if not Value.IsEmpty then
    JSONParts.Add(TTextData.Create.Text(Value).Detach);
  for var Item in Attached do
    JSONParts.Add(Convert.ToJson(Item));
  Result := TContentPayload(Add('parts', JSONParts));
end;

{ TTextData }

function TTextData.Text(const Value: string): TTextData;
begin
  Result := TTextData(Add('text', Value));
end;

{ TInlineData }

function TInlineData.Data(const Value: string): TInlineData;
begin
  Result := TInlineData(Add('data', Value));
end;

function TInlineData.MimeType(const Value: string): TInlineData;
begin
  Result := TInlineData(Add('mime_type', Value));
end;

{ TFileData }

function TFileData.FileUri(const Value: string): TFileData;
begin
  Result := TFileData(Add('file_uri', Value));
end;

function TFileData.MimeType(const Value: string): TFileData;
begin
  Result := TFileData(Add('mime_type', Value));
end;

{ TAttachedManager }

function TAttachedManager.GetEncoded(const FilePath: string): string;
begin
  Result := EncodeBase64(FilePath);
end;

function TAttachedManager.GetMimeType(const FilePath: string): string;
begin
  Result := EmptyStr;
  if not IsUri(FilePath) then
    begin
      Result := ResolveMimeType(FilePath);
    end;
end;

function TAttachedManager.IsUri(const FilePath: string): Boolean;
begin
  Result := FilePath.ToLower.StartsWith('http');
end;

function TAttachedManager.ToJson(const FilePath: string): TJSONObject;
begin
  if IsUri(FilePath) then
    begin
      Result := TFileData.Create.FileUri(FilePath).Detach;
      Result := TJSONObject.Create.AddPair('file_data', Result);
    end
  else
    begin
      Result := TInlineData.Create.MimeType(GetMimeType(FilePath)).Data(GetEncoded(FilePath)).Detach;
      Result := TJSONObject.Create.AddPair('inline_data', Result);
    end;
end;

{ TLangueTypeHelper }

class function TLangueTypeHelper.Create(const Value: string): TLangueType;
begin
  var Index := IndexStr(AnsiUpperCase(Value), ['LANGUAGE_UNSPECIFIED', 'PYTHON']);
  if Index = -1 then
    raise Exception.CreateFmt('"Langue type" unknown : %s', [Value]);
  Result := TLangueType(Index);
end;

function TLangueTypeHelper.ToString: string;
begin
  case Self of
    LANGUAGE_UNSPECIFIED:
      Exit('LANGUAGE_UNSPECIFIED');
    PYTHON:
      Exit('PYTHON');
  end;
end;

{ TLangueTypeInterceptor }

function TLangueTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TLangueType>.ToString;
end;

procedure TLangueTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TLangueType.Create(Arg)));
end;

{ TOutcomeTypeHelper }

class function TOutcomeTypeHelper.Create(
  const Value: string): TOutcomeType;
begin
  var Index := IndexStr(AnsiUpperCase(Value), [
    'OUTCOME_UNSPECIFIED', 'OUTCOME_OK', 'OUTCOME_FAILED', 'OUTCOME_DEADLINE_EXCEEDED']);
  if Index = -1 then
    raise Exception.CreateFmt('"Code result type" unknown : %s', [Value]);
  Result := TOutcomeType(Index);
end;

function TOutcomeTypeHelper.ToString: string;
begin
  case Self of
    OUTCOME_UNSPECIFIED:
      Exit('OUTCOME_UNSPECIFIED');
    OUTCOME_OK:
      Exit('OUTCOME_OK');
    OUTCOME_FAILED:
      Exit('OUTCOME_FAILED');
    OUTCOME_DEADLINE_EXCEEDED:
      Exit('OUTCOME_DEADLINE_EXCEEDED');
  end;
end;

{ TOutcomeTypeInterceptor }

function TOutcomeTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TOutcomeType>.ToString;
end;

procedure TOutcomeTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TOutcomeType.Create(Arg)));
end;

end.
