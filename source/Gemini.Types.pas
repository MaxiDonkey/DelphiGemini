unit Gemini.Types;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils,
  Gemini.Types.Rtti, Gemini.API.Params, Gemini.Types.EnumWire;

type
  TArgsFixInterceptor = class(TJSONInterceptorStringToString)
  public
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$REGION 'Gemini.Chat'}

    {$SCOPEDENUMS OFF}

    /// <summary>
    /// Kind of tool call
    /// </summary>
    TToolKind = (
      /// <summary>
      /// Enable code execution
      /// </summary>
      CodeExecution,

      /// <summary>
      /// Enable google search
      /// </summary>
      GoogleSearch
    );

    {$SCOPEDENUMS ON}

    /// <summary>
    /// Type of message role
    /// </summary>
    TMessageRole = (
      /// <summary>
      /// User message
      /// </summary>
      user,

      /// <summary>
      /// Assistant message
      /// </summary>
      model,

      agent
    );

    {$SCOPEDENUMS OFF}

    TMessageRoleHelper = record helper for TMessageRole
    const
      MessageRoles: array[TMessageRole] of string = (
        'user',
        'model',
        'agent'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TMessageRole; static;
    end;

    TMessageRoleInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

    {$SCOPEDENUMS ON}

    /// <summary>
    /// Defines the reason why the model stopped generating tokens.
    /// </summary>
    TFinishReason = (
      /// <summary>
      /// Default value. This value is unused.
      /// </summary>
      FINISH_REASON_UNSPECIFIED,

      /// <summary>
      /// Natural stop point of the model or provided stop sequence.
      /// </summary>
      STOP,

      /// <summary>
      /// The maximum number of tokens as specified in the request was reached.
      /// </summary>
      MAX_TOKENS,

      /// <summary>
      /// The response candidate content was flagged for safety reasons.
      /// </summary>
      SAFETY,

      /// <summary>
      /// The response candidate content was flagged for recitation reasons.
      /// </summary>
      RECITATION,

      /// <summary>
      /// The response candidate content was flagged for using an unsupported language.
      /// </summary>
      LANGUAGE,

      /// <summary>
      ///  Unknown reason.
      /// </summary>
      OTHER,

      /// <summary>
      /// Token generation stopped because the content contains forbidden terms.
      /// </summary>
      BLOCKLIST,

      /// <summary>
      /// Token generation stopped for potentially containing prohibited content.
      /// </summary>
      PROHIBITED_CONTENT,

      /// <summary>
      /// Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).
      /// </summary>
      SPII,

      /// <summary>
      /// The function call generated by the model is invalid.
      /// </summary>
      MALFORMED_FUNCTION_CALL,

      /// <summary>
      /// Token generation stopped because generated images contain safety violations.
      /// </summary>
      IMAGE_SAFETY,

      /// <summary>
      /// Image generation stopped because generated images has other prohibited content.
      /// </summary>
      IMAGE_PROHIBITED_CONTENT,

      /// <summary>
      /// Image generation stopped because of other miscellaneous issue.
      /// </summary>
      IMAGE_OTHER,

      /// <summary>
      /// The model was expected to generate an image, but none was generated.
      /// </summary>
      NO_IMAGE,

      /// <summary>
      /// Image generation stopped due to recitation.
      /// </summary>
      IMAGE_RECITATION,

      /// <summary>
      /// Model generated a tool call but no tools were enabled in the request.
      /// </summary>
      UNEXPECTED_TOOL_CALL,

      /// <summary>
      /// Model called too many tools consecutively, thus the system exited execution.
      /// </summary>
      TOO_MANY_TOOL_CALLS,

      /// <summary>
      /// Request has at least one thought signature missing.
      /// </summary>
      MISSING_THOUGHT_SIGNATURE
    );

    TFinishReasonHelper = record helper for TFinishReason
    const
      FinishReasons: array[TFinishReason] of string = (
        'FINISH_REASON_UNSPECIFIED',
        'STOP',
        'MAX_TOKENS',
        'SAFETY',
        'RECITATION',
        'LANGUAGE',
        'OTHER',
        'BLOCKLIST',
        'PROHIBITED_CONTENT',
        'SPII',
        'MALFORMED_FUNCTION_CALL',
        'IMAGE_SAFETY',
        'IMAGE_PROHIBITED_CONTENT',
        'IMAGE_OTHER',
        'NO_IMAGE',
        'IMAGE_RECITATION',
        'UNEXPECTED_TOOL_CALL',
        'TOO_MANY_TOOL_CALLS',
        'MISSING_THOUGHT_SIGNATURE'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TFinishReason; static;
    end;

    TFinishReasonInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

    {$SCOPEDENUMS OFF}

    /// <summary>
    /// Supported programming languages for the generated code.
    /// </summary>
    TLanguageType = (
      /// <summary>
      /// Language not specified. This value should not be used.
      /// </summary>
      LANGUAGE_UNSPECIFIED,

      /// <summary>
      /// Python >= 3.10, with numpy and simpy available
      /// </summary>
      PYTHON
    );

    TLanguageTypeHelper = record helper for TLanguageType
    const
      LanguageTypes: array[TLanguageType] of string = (
        'LANGUAGE_UNSPECIFIED',
        'PYTHON'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TLanguageType; static;
    end;

    TLanguageTypeInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

    {$SCOPEDENUMS OFF}

    /// <summary>
    /// Enumeration of possible outcomes of the code execution.
    /// </summary>
    TOutcomeType = (
      /// <summary>
      /// State not specified. This value should not be used.
      /// </summary>
      OUTCOME_UNSPECIFIED,

      /// <summary>
      /// The code execution was successful.
      /// </summary>
      OUTCOME_OK,

      /// <summary>
      /// Code execution completed, but with failure. stderr should contain the reason.
      /// </summary>
      OUTCOME_FAILED,

      /// <summary>
      /// Code execution took too long and was canceled. Partial output may or may not be present.
      /// </summary>
      OUTCOME_DEADLINE_EXCEEDED
    );

    TOutcomeTypeHelper = record helper for TOutcomeType
    const
      OutcomeTypes: array[TOutcomeType] of string = (
        'OUTCOME_UNSPECIFIED',
        'OUTCOME_OK',
        'OUTCOME_FAILED',
        'OUTCOME_DEADLINE_EXCEEDED'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TOutcomeType; static;
    end;

    TOutcomeTypeInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

    {$SCOPEDENUMS OFF}

    /// <summary>
    /// Specifies how the response should be scheduled in the conversation.
    /// </summary>
    TSchedulingType = (
      /// <summary>
      /// This value is unused.
      /// </summary>
      SCHEDULING_UNSPECIFIED,

      /// <summary>
      /// Only add the result to the conversation context, do not interrupt or trigger generation.
      /// </summary>
      SILENT,

      /// <summary>
      /// Add the result to the conversation context, and prompt to generate output without interrupting
      /// ongoing generation.
      /// </summary>
      WHEN_IDLE,

      /// <summary>
      /// Add the result to the conversation context, interrupt ongoing generation and prompt to generate output.
      /// </summary>
      INTERRUPT
    );

    TSchedulingTypeHelper = record Helper for TSchedulingType
    const
      SchedulingTypes: array[TSchedulingType] of string = (
        'SCHEDULING_UNSPECIFIED',
        'SILENT',
        'WHEN_IDLE',
        'INTERRUPT'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TSchedulingType; static;
    end;

    TSchedulingTypeInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

    {$SCOPEDENUMS OFF}

    /// <summary>
    /// Defines the function behavior. Defaults to BLOCKING.
    /// </summary>
    TBehaviorType = (
      /// <summary>
      /// This value is unused.
      /// </summary>
      UNSPECIFIED,

      /// <summary>
      /// If set, the system will wait to receive the function response before continuing the conversation.
      /// </summary>
      BLOCKING,

      /// <summary>
      /// If set, the system will not wait to receive the function response. Instead, it will attempt to
      /// handle function responses as they become available while maintaining the conversation between
      /// the user and the model.
      /// </summary>
      NON_BLOCKING
    );

    TBehaviorTypeHelper = record Helper for TBehaviorType
    const
      BehaviorTypes: array[TBehaviorType] of string = (
        'UNSPECIFIED',
        'BLOCKING',
        'NON_BLOCKING'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TBehaviorType; static;
    end;

    {$SCOPEDENUMS ON}

    /// <summary>
    /// The mode of the predictor to be used in dynamic retrieval.
    /// </summary>
    TModeType = (
      /// <summary>
      /// Always trigger retrieval.
      /// </summary>
      MODE_UNSPECIFIED,

      /// <summary>
      /// Run retrieval only when system decides it is necessary.
      /// </summary>
      MODE_DYNAMIC
    );

    TModeTypeHelper = record Helper for TModeType
    const
      ModeTypes: array[TModeType] of string = (
        'MODE_UNSPECIFIED',
        'MODE_DYNAMIC'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TModeType; static;
    end;

    {$SCOPEDENUMS OFF}

    /// <summary>
    /// Represents the environment being operated, such as a web browser.
    /// </summary>
    TEnvironmentType = (
      /// <summary>
      /// Defaults to browser.
      /// </summary>
      ENVIRONMENT_UNSPECIFIED,

      /// <summary>
      /// Operates in a web browser.
      /// </summary>
      ENVIRONMENT_BROWSER
    );

    TEnvironmentTypeHelper = record Helper for TEnvironmentType
    const
      EnvironmentTypes: array[TEnvironmentType] of string = (
        'ENVIRONMENT_UNSPECIFIED',
        'ENVIRONMENT_BROWSER'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TEnvironmentType; static;
    end;

    {$SCOPEDENUMS ON}

    /// <summary>
    /// Defines the execution behavior for function calling by defining the execution mode.
    /// </summary>
    TToolConfigMode = (
      /// <summary>
      /// Unspecified function calling mode. This value should not be used.
      /// </summary>
      MODE_UNSPECIFIED,

      /// <summary>
      /// 	Default model behavior, model decides to predict either a function call or a natural language response.
      /// </summary>
      AUTO,

      /// <summary>
      /// Model is constrained to always predicting a function call only. If "allowedFunctionNames" are set,
      /// the predicted function call will be limited to any one of "allowedFunctionNames", else the predicted
      /// function call will be any one of the provided "functionDeclarations".
      /// </summary>
      ANY,

      /// <summary>
      /// Model will not predict any function call. Model behavior is same as when not passing any function
      /// declarations.
      /// </summary>
      NONE,

      /// <summary>
      /// Model decides to predict either a function call or a natural language response, but will validate
      /// function calls with constrained decoding. If "allowedFunctionNames" are set, the predicted function
      /// call will be limited to any one of "allowedFunctionNames", else the predicted function call will be
      ///any one of the provided "functionDeclarations".
      /// </summary>
      VALIDATED
    );

    TToolConfigModeHelper = record Helper for TToolConfigMode
    const
      ToolConfigModes: array[TToolConfigMode] of string = (
        'MODE_UNSPECIFIED',
        'AUTO',
        'ANY',
        'NONE',
        'VALIDATED'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TToolConfigMode; static;
    end;

    {$SCOPEDENUMS ON}

    /// <summary>
    /// Supported modalities of the response.
    /// </summary>
    TModalityType = (
      /// <summary>
      /// Default value.
      /// </summary>
      MODALITY_UNSPECIFIED,

      /// <summary>
      /// Indicates the model should return text.
      /// </summary>
      TEXT,

      /// <summary>
      /// Indicates the model should return images.
      /// </summary>
      IMAGE,

      /// <summary>
      /// Indicates the model should return audio.
      /// </summary>
      AUDIO
    );

    TModalityTypeHelper = record Helper for TModalityType
    const
      ModalityTypes: array[TModalityType] of string = (
        'MODALITY_UNSPECIFIED',
        'TEXT',
        'IMAGE',
        'AUDIO'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TModalityType; static;
    end;

    {$SCOPEDENUMS ON}

    /// <summary>
    /// Allow user to specify how much to think using enum instead of integer budget.
    /// </summary>
    TThinkingLevelType = (
      /// <summary>
      /// Default value.
      /// </summary>
      THINKING_LEVEL_UNSPECIFIED,

      /// <summary>
      /// Low thinking level.
      /// </summary>
      LOW,

      /// <summary>
      /// High thinking level.
      /// </summary>
      HIGH
    );

    TThinkingLevelTypeHelper = record Helper for TThinkingLevelType
    const
      ThinkingLevelTypes: array[TThinkingLevelType] of string = (
        'THINKING_LEVEL_UNSPECIFIED',
        'LOW',
        'HIGH'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TThinkingLevelType; static;
    end;

    {$SCOPEDENUMS OFF}

    /// <summary>
    /// Media resolution for the input media.
    /// </summary>
    TMediaResolutionType = (
      /// <summary>
      /// Media resolution has not been set.
      /// </summary>
      MEDIA_RESOLUTION_UNSPECIFIED,

      /// <summary>
      /// Media resolution set to low (64 tokens).
      /// </summary>
      MEDIA_RESOLUTION_LOW,

      /// <summary>
      /// Media resolution set to medium (256 tokens).
      /// </summary>
      MEDIA_RESOLUTION_MEDIUM,

      /// <summary>
      /// Media resolution set to high (zoomed reframing with 256 tokens).
      /// </summary>
      MEDIA_RESOLUTION_HIGH
    );

    TMediaResolutionTypeHelper = record Helper for TMediaResolutionType
    const
      MediaResolutionTypes: array[TMediaResolutionType] of string = (
        'MEDIA_RESOLUTION_UNSPECIFIED',
        'MEDIA_RESOLUTION_LOW',
        'MEDIA_RESOLUTION_MEDIUM',
        'MEDIA_RESOLUTION_HIGH'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TMediaResolutionType; static;
    end;

    {$SCOPEDENUMS OFF}

    /// <summary>
    /// Status of the url retrieval.
    /// </summary>
    TUrlRetrievalStatusType = (
      /// <summary>
      /// Default value. This value is unused.
      /// </summary>
      URL_RETRIEVAL_STATUS_UNSPECIFIED,

      /// <summary>
      /// Url retrieval is successful.
      /// </summary>
      URL_RETRIEVAL_STATUS_SUCCESS,

      /// <summary>
      /// Url retrieval is failed due to error.
      /// </summary>
      URL_RETRIEVAL_STATUS_ERROR,

      /// <summary>
      /// Url retrieval is failed because the content is behind paywall.
      /// </summary>
      URL_RETRIEVAL_STATUS_PAYWALL,

      /// <summary>
      /// Url retrieval is failed because the content is unsafe.
      /// </summary>
      URL_RETRIEVAL_STATUS_UNSAFE
    );

    TUrlRetrievalStatusTypeHelper = record Helper for TUrlRetrievalStatusType
    const
      UrlRetrievalStatusTypes: array[TUrlRetrievalStatusType] of string = (
        'URL_RETRIEVAL_STATUS_UNSPECIFIED',
        'URL_RETRIEVAL_STATUS_SUCCESS',
        'URL_RETRIEVAL_STATUS_ERROR',
        'URL_RETRIEVAL_STATUS_PAYWALL',
        'URL_RETRIEVAL_STATUS_UNSAFE'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TUrlRetrievalStatusType; static;
    end;

    TUrlRetrievalStatusTypeInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

    {$SCOPEDENUMS ON}

    /// <summary>
    /// Specifies the reason why the prompt was blocked.
    /// </summary>
    TBlockReason = (
      /// <summary>
      /// Default value. This value is unused.
      /// </summary>
      BLOCK_REASON_UNSPECIFIED,

      /// <summary>
      /// Prompt was blocked due to safety reasons. Inspect safetyRatings to understand which safety category blocked it.
      /// </summary>
      SAFETY,

      /// <summary>
      /// Prompt was blocked due to unknown reasons.
      /// </summary>
      OTHER,

      /// <summary>
      /// Prompt was blocked due to the terms which are included from the terminology blocklist.
      /// </summary>
      BLOCKLIST,

      /// <summary>
      /// Prompt was blocked due to prohibited content.
      /// </summary>
      PROHIBITED_CONTENT,

      /// <summary>
      /// Candidates blocked due to unsafe image generation content.
      /// </summary>
      IMAGE_SAFETY
    );

    TBlockReasonHelper = record Helper for TBlockReason
    const
      BlockReasons: array[TBlockReason] of string = (
        'BLOCK_REASON_UNSPECIFIED',
        'SAFETY',
        'OTHER',
        'BLOCKLIST',
        'PROHIBITED_CONTENT',
        'IMAGE_SAFETY'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TBlockReason; static;
    end;

    TBlockReasonInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

    {$SCOPEDENUMS ON}

    TTokenModalityType = (
      MODALITY_UNSPECIFIED,
      TEXT,
      IMAGE,
      VIDEO,
      AUDIO,
      DOCUMENT
    );

    TTokenModalityTypeHelper = record Helper for TTokenModalityType
    const
      TokenModalityTypes: array[TTokenModalityType] of string = (
        'MODALITY_UNSPECIFIED',
        'TEXT',
        'IMAGE',
        'VIDEO',
        'AUDIO',
        'DOCUMENT'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TTokenModalityType; static;
    end;

    TTokenModalityTypeInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

  {$ENDREGION}

  {$REGION 'Gemini.Schema'}

    {$SCOPEDENUMS ON}

    /// <summary>
    /// Type contains the list of OpenAPI data types as defined by :
    /// <para>
    /// - https://spec.openapis.org/oas/v3.0.3#data-types
    /// </para>
    /// </summary>
    TSchemaType = (
      /// <summary>
      /// Not specified, should not be used.
      /// </summary>
      unspecified,

      /// <summary>
      /// String type.
      /// </summary>
      &string,

      /// <summary>
      /// Number type.
      /// </summary>
      number,

      /// <summary>
      /// Integer type.
      /// </summary>
      &integer,

      /// <summary>
      /// Boolean type.
      /// </summary>
      &boolean,

      /// <summary>
      /// Array type.
      /// </summary>
      &array,

      /// <summary>
      /// Object type.
      /// </summary>
      &object
    );

    TSchemaTypeHelper = record Helper for TSchemaType
    const
      SchemaTypes: array[TSchemaType] of string = (
        'unspecified',
        'string',
        'number',
        'integer',
        'boolean',
        'array',
        'object'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TSchemaType; static;
    end;

  {$ENDREGION}

  {$REGION 'Gemini.Embeddings'}

    {$SCOPEDENUMS ON}

    /// <summary>
    /// Type of task for which the embedding will be used.
    /// </summary>
    TTaskType = (
      /// <summary>
      /// Unset value, which will default to one of the other enum values.
      /// </summary>
      TASK_TYPE_UNSPECIFIED,

      /// <summary>
      /// Specifies the given text is a query in a search/retrieval setting.
      /// </summary>
      RETRIEVAL_QUERY,

      /// <summary>
      /// Specifies the given text is a document from the corpus being searched.
      /// </summary>
      RETRIEVAL_DOCUMENT,

      /// <summary>
      /// Specifies the given text will be used for STS.
      /// </summary>
      SEMANTIC_SIMILARITY,

      /// <summary>
      /// Specifies that the given text will be classified.
      /// </summary>
      CLASSIFICATION,

      /// <summary>
      /// Specifies that the embeddings will be used for clustering.
      /// </summary>
      CLUSTERING,

      /// <summary>
      /// Specifies that the given text will be used for question answering.
      /// </summary>
      QUESTION_ANSWERING,

      /// <summary>
      /// Specifies that the given text will be used for fact verification.
      /// </summary>
      FACT_VERIFICATION,

      /// <summary>
      /// Specifies that the given text will be used for code retrieval.
      /// </summary>
      CODE_RETRIEVAL_QUERY
    );

    TTaskTypeHelper = record helper for TTaskType
    const
      TaskTypes: array[TTaskType] of string = (
        'TASK_TYPE_UNSPECIFIED',
        'RETRIEVAL_QUERY',
        'RETRIEVAL_DOCUMENT',
        'SEMANTIC_SIMILARITY',
        'CLASSIFICATION',
        'CLUSTERING',
        'QUESTION_ANSWERING',
        'FACT_VERIFICATION',
        'CODE_RETRIEVAL_QUERY'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TTaskType; static;
    end;

  {$ENDREGION}

  {$REGION 'Gemini.Safety'}

    {$SCOPEDENUMS OFF}

    /// <summary>
    /// The category of a rating.
    /// </summary>
    /// <remarks>
    /// These categories cover various kinds of harms that developers may wish to adjust.
    /// </remarks>
    THarmCategory = (
      /// <summary>
      /// Category is unspecified.
      /// </summary>
      HARM_CATEGORY_UNSPECIFIED,

      /// <summary>
      /// PaLM - Negative or harmful comments targeting identity and/or protected attribute.
      /// </summary>
      HARM_CATEGORY_DEROGATORY,

      /// <summary>
      /// PaLM - Content that is rude, disrespectful, or profane.
      /// </summary>
      HARM_CATEGORY_TOXICITY,

      /// <summary>
      /// PaLM - Describes scenarios depicting violence against an individual or group, or general descriptions of gore.
      /// </summary>
      HARM_CATEGORY_VIOLENCE,

      /// <summary>
      /// PaLM - Contains references to sexual acts or other lewd content.
      /// </summary>
      HARM_CATEGORY_SEXUAL,

      /// <summary>
      /// PaLM - Promotes unchecked medical advice.
      /// </summary>
      HARM_CATEGORY_MEDICAL,

      /// <summary>
      /// PaLM - Dangerous content that promotes, facilitates, or encourages harmful acts.
      /// </summary>
      HARM_CATEGORY_DANGEROUS,

      /// <summary>
      /// Gemini - Harassment content.
      /// </summary>
      HARM_CATEGORY_HARASSMENT,

      /// <summary>
      /// Gemini - Hate speech and content.
      /// </summary>
      HARM_CATEGORY_HATE_SPEECH,

      /// <summary>
      /// Gemini - Sexually explicit content.
      /// </summary>
      HARM_CATEGORY_SEXUALLY_EXPLICIT,

      /// <summary>
      /// Gemini - Dangerous content.
      /// </summary>
      HARM_CATEGORY_DANGEROUS_CONTENT
    );

    THarmCategoryHelper = record Helper for THarmCategory
    const
      HarmCategories: array[THarmCategory] of string = (
        'HARM_CATEGORY_UNSPECIFIED',
        'HARM_CATEGORY_DEROGATORY',
        'HARM_CATEGORY_TOXICITY',
        'HARM_CATEGORY_VIOLENCE',
        'HARM_CATEGORY_SEXUAL',
        'HARM_CATEGORY_MEDICAL',
        'HARM_CATEGORY_DANGEROUS',
        'HARM_CATEGORY_HARASSMENT',
        'HARM_CATEGORY_HATE_SPEECH',
        'HARM_CATEGORY_SEXUALLY_EXPLICIT',
        'HARM_CATEGORY_DANGEROUS_CONTENT'
      );
    public
      function ToString: string;
      class function Parse(const S: string): THarmCategory; static;
    end;

    THarmCategoryInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

    {$SCOPEDENUMS OFF}

    /// <summary>
    /// Block at and beyond a specified harm probability.
    /// </summary>
    THarmBlockThreshold = (
      /// <summary>
      /// Threshold is unspecified.
      /// </summary>
      HARM_BLOCK_THRESHOLD_UNSPECIFIED,

      /// <summary>
      /// Content with NEGLIGIBLE will be allowed.
      /// </summary>
      BLOCK_LOW_AND_ABOVE,

      /// <summary>
      /// Content with NEGLIGIBLE and LOW will be allowed.
      /// </summary>
      BLOCK_MEDIUM_AND_ABOVE,

      /// <summary>
      /// Content with NEGLIGIBLE, LOW, and MEDIUM will be allowed.
      /// </summary>
      BLOCK_ONLY_HIGH,

      /// <summary>
      /// All content will be allowed.
      /// </summary>
      BLOCK_NONE,

      /// <summary>
      /// Turn off the safety filter.
      /// </summary>
      OFF
    );

    THarmBlockThresholdHelper = record Helper for THarmBlockThreshold
    const
      HarmBlockThresholds: array[THarmBlockThreshold] of string = (
        'HARM_BLOCK_THRESHOLD_UNSPECIFIED',
        'BLOCK_LOW_AND_ABOVE',
        'BLOCK_MEDIUM_AND_ABOVE',
        'BLOCK_ONLY_HIGH',
        'BLOCK_NONE',
        'OFF'
      );
    public
      function ToString: string;
      class function Parse(const S: string): THarmBlockThreshold; static;
    end;

    {$SCOPEDENUMS ON}

    /// <summary>
    /// The probability that a piece of content is harmful.
    /// </summary>
    /// <remarks>
    /// The classification system gives the probability of the content being unsafe. This does not indicate
    /// the severity of harm for a piece of content.
    /// </remarks>
    THarmProbability = (
      /// <summary>
      /// Probability is unspecified.
      /// </summary>
      HARM_PROBABILITY_UNSPECIFIED,

      /// <summary>
      /// Content has a negligible chance of being unsafe.
      /// </summary>
      NEGLIGIBLE,

      /// <summary>
      /// Content has a low chance of being unsafe.
      /// </summary>
      LOW,

      /// <summary>
      /// Content has a medium chance of being unsafe.
      /// </summary>
      MEDIUM,

      /// <summary>
      /// Content has a high chance of being unsafe.
      /// </summary>
      HIGH
    );

    THarmProbabilityHelper = record Helper for THarmProbability
    const
      HarmProbabilities: array[THarmProbability] of string = (
        'HARM_PROBABILITY_UNSPECIFIED',
        'NEGLIGIBLE',
        'LOW',
        'MEDIUM',
        'HIGH'
      );
    public
      function ToString: string;
      class function Parse(const S: string): THarmProbability; static;
    end;

    THarmProbabilityInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

  {$ENDREGION}

  {$REGION 'Gemini.Files'}

    {$SCOPEDENUMS ON}

    /// <summary>
    /// States for the lifecycle of a File, representing its readiness for use and the outcome of processing.
    /// </summary>
    TStateType = (
      /// <summary>
      /// The default value. This value is used if the state is omitted.
      /// </summary>
      STATE_UNSPECIFIED,

      /// <summary>
      /// File is being processed and cannot be used for inference yet.
      /// </summary>
      PROCESSING,

      /// <summary>
      /// File is processed and available for inference.
      /// </summary>
      ACTIVE,

      /// <summary>
      /// File failed processing.
      /// </summary>
      FAILED
    );

    TStateTypeHelper = record Helper for TStateType
    const
      StateTypes: array[TStateType] of string = (
        'STATE_UNSPECIFIED',
        'PROCESSING',
        'ACTIVE',
        'FAILED'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TStateType; static;
    end;

    TStateTypeInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

    TSourceType = (
      /// <summary>
      /// Used if source is not specified.
      /// </summary>
      SOURCE_UNSPECIFIED,

      /// <summary>
      /// Indicates the file is uploaded by the user.
      /// </summary>
      UPLOADED,

      /// <summary>
      /// Indicates the file is generated by Google.
      /// </summary>
      GENERATED,

      /// <summary>
      /// Indicates the file is a registered, i.e. a Google Cloud Storage file.
      /// </summary>
      REGISTERED
    );

    TSourceTypeHelper = record Helper for TSourceType
    const
      SourceTypes: array[TSourceType] of string = (
        'STATE_UNSPECIFIED',
        'PROCESSING',
        'ACTIVE',
        'FAILED'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TSourceType; static;
    end;

    TSourceTypeInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

  {$ENDREGION}

  {$REGION 'Gemini.Tools'}

    {$SCOPEDENUMS ON}

    /// <summary>
    /// Defines the execution behavior for function calling by defining the execution mode.
    /// </summary>
    TToolMode = (
      /// <summary>
      /// Unspecified function calling mode. This value should not be used.
      /// </summary>
      MODE_UNSPECIFIED,

      /// <summary>
      /// Default model behavior, model decides to predict either a function call or a natural language response.
      /// </summary>
      AUTO,

      /// <summary>
      /// Model is constrained to always predicting a function call only. If "allowedFunctionNames" are set, the
      //// predicted function call will be limited to any one of "allowedFunctionNames", else the predicted function
      /// call will be any one of the provided "functionDeclarations".
      /// </summary>
      ANY,

      /// <summary>
      /// Model will not predict any function call. Model behavior is same as when not passing any function declarations.
      /// </summary>
      NONE
    );

    TToolModeHelper = record helper for TToolMode
    const
      ToolModes: array[TToolMode] of string = (
        'MODE_UNSPECIFIED',
        'AUTO',
        'ANY',
        'NONE'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TToolMode; static;
    end;

  {$ENDREGION}

  {$REGION 'Gemini.FineTunings'}

    {$SCOPEDENUMS ON}

    /// <summary>
    /// The state of the tuned model.
    /// </summary>
    TModelState = (
      /// <summary>
      /// Default value. This value is not used.
      /// </summary>
      STATE_UNSPECIFIED,
      /// <summary>
      /// The model is being created.
      /// </summary>
      CREATING,
      /// <summary>
      /// The model is ready to use.
      /// </summary>
      ACTIVE,
      /// <summary>
      /// Failed to create model.
      /// </summary>
      FAILED
    );

    TModelStateHelper = record Helper for TModelState
    const
      ModelStates: array[TModelState] of string = (
        'STATE_UNSPECIFIED',
        'CREATING',
        'ACTIVE',
        'FAILED'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TModelState; static;
    end;

    TModelStateInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

  {$ENDREGION}

  {$REGION 'Gemini.VectorFiles.Documents'}

    {$SCOPEDENUMS ON}

    /// <summary>
    /// States for the lifecycle of a Document.
    /// </summary>
    TDocumentState = (
      /// <summary>
      /// The default value. This value is used if the state is omitted.
      /// </summary>
      STATE_UNSPECIFIED,

      /// <summary>
      /// Some Chunks of the Document are being processed (embedding and vector storage).
      /// </summary>
      STATE_PENDING,

      /// <summary>
      /// All Chunks of the Document is processed and available for querying.
      /// </summary>
      STATE_ACTIVE,

      /// <summary>
      /// Some Chunks of the Document failed processing.
      /// </summary>
      STATE_FAILED
    );

    TDocumentStateHelper = record Helper for TDocumentState
    const
      DocumentStates: array[TDocumentState] of string = (
        'STATE_UNSPECIFIED',
        'STATE_PENDING',
        'STATE_ACTIVE',
        'STATE_FAILED'
      );
    public
      function ToString: string;
      class function Parse(const S: string): TDocumentState; static;
    end;

    TDocumentStateInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

  {$ENDREGION}

  {$REGION 'Gemini.Batch'}

   {$SCOPEDENUMS OFF}

   /// <summary>
   /// The state of the batch.
   /// </summary>
   TBatchStateType = (
     /// <summary>
     /// The batch state is unspecified.
     /// </summary>
     BATCH_STATE_UNSPECIFIED,

     /// <summary>
     /// The service is preparing to run the batch.
     /// </summary>
     BATCH_STATE_PENDING,

     /// <summary>
     /// The batch is in progress.
     /// </summary>
     BATCH_STATE_RUNNING,

     /// <summary>
     /// The batch completed successfully.
     /// </summary>
     BATCH_STATE_SUCCEEDED,

     /// <summary>
     /// The batch failed.
     /// </summary>
     BATCH_STATE_FAILED,

     /// <summary>
     /// The batch has been cancelled.
     /// </summary>
     BATCH_STATE_CANCELLED,

     /// <summary>
     /// The batch has expired.
     /// </summary>
     BATCH_STATE_EXPIRED
   );

   TBatchStateTypeHelper = record Helper for TBatchStateType
   const
      BatchStateTypes: array[TBatchStateType] of string = (
        'BATCH_STATE_UNSPECIFIED',
        'BATCH_STATE_PENDING',
        'BATCH_STATE_RUNNING',
        'BATCH_STATE_SUCCEEDED',
        'BATCH_STATE_FAILED',
        'BATCH_STATE_CANCELLED',
        'BATCH_STATE_EXPIRED'
      );
   public
     function ToString: string;
     class function Parse(const S: string): TBatchStateType; static;
   end;

  {$ENDREGION}

  {$REGION 'Gemini.Batch'}

   {$SCOPEDENUMS OFF}

   /// <summary>
   /// JsonPath fields for Operation metadata/response.
   /// </summary>
   TOperationPath = (
     op_type,
     op_model,
     op_displayName,
     op_inputFileName,
     op_createTime,
     op_endTime,
     op_updateTime,
     op_state,
     op_requestCount,
     op_successfulRequestCount,
     op_failedRequestCount,
     op_pendingRequestCount,
     op_responsesFile
   );

   TOperationPathHelper = record helper for TOperationPath
   const
     OperationPaths: array[TOperationPath] of string = (
       'metadata.@type',
       'metadata.model',
       'metadata.displayName',
       'metadata.inputConfig.fileName',
       'metadata.createTime',
       'metadata.endTime',
       'metadata.updateTime',
       'metadata.state',
       'metadata.batchStats.requestCount',
       'metadata.batchStats.successfulRequestCount',
       'metadata.batchStats.failedRequestCount',
       'metadata.batchStats.pendingRequestCount',
       'response.responsesFile'
     );
   public
     function ToString: string; inline;
     class function Parse(const S: string): TOperationPath; static;
   end;

  {$ENDREGION}

  {$REGION 'Gemini.Interactions.Content'}

    {$SCOPEDENUMS ON}

    TContentType = (
      text,
      image,
      audio,
      document,
      video,
      thought,
      function_call,
      function_result,
      code_execution_call,
      code_execution_result,
      url_context_call,
      url_context_result,
      google_search_call,
      google_search_result,
      mcp_server_tool_call,
      mcp_server_tool_result,
      file_search_result,
      thought_summary,            //Delta
      thought_signature           //Delta
    );

    TContentTypeHelper = record Helper for TContentType
    const
      ContentTypes: array[TContentType] of string = (
        'text',
        'image',
        'audio',
        'document',
        'video',
        'thought',
        'function_call',
        'function_result',
        'code_execution_call',
        'code_execution_result',
        'url_context_call',
        'url_context_result',
        'google_search_call',
        'google_search_result',
        'mcp_server_tool_call',
        'mcp_server_tool_result',
        'file_search_result',
        'thought_summary',
        'thought_signature'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TContentType; static;
    end;

    TContentTypeInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

    {$SCOPEDENUMS OFF}

    TImageMimeTypeOption = (
      image_png,
      image_jpeg,
      image_webp,
      image_heic,
      image_heif
    );

    TImageMimeTypeOptionHelper = record Helper for TImageMimeTypeOption
    const
      ImageMimeTypeOptions: array[TImageMimeTypeOption] of string = (
        'image/png',
        'image/jpeg',
        'image/webp',
        'image/heic',
        'image/heif'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TImageMimeTypeOption; static;
    end;

    {$SCOPEDENUMS ON}

    TMediaResolution = (
      low,
      medium,
      high,
      ultra_high
    );

    TMediaResolutionHelper = record Helper for TMediaResolution
    const
      MediaResolutions: array[TMediaResolution] of string = (
        'low',
        'medium',
        'high',
        'ultra_high'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TMediaResolution; static;
    end;

    {$SCOPEDENUMS OFF}

    TAudioMimeTypeOption = (
      audio_wav,
      audio_x_wav,
      audio_mp3,
      audio_aiff,
      audio_aac,
      audio_ogg,
      audio_flac
    );

    TAudioMimeTypeOptionHelper = record Helper for TAudioMimeTypeOption
    const
      AudioMimeTypeOptions: array[TAudioMimeTypeOption] of string = (
        'audio/wav',
        'audio/x-wav',
        'audio/mp3',
        'audio/aiff',
        'audio/aac',
        'audio/ogg',
        'audio/flac'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TAudioMimeTypeOption; static;
    end;

    {$SCOPEDENUMS OFF}

    TDocumentMimeTypeOption = (
      application_pdf
    );

    TDocumentMimeTypeOptionHelper = record Helper for TDocumentMimeTypeOption
    const
      DocumentMimeTypeOptions: array[TDocumentMimeTypeOption] of string = (
        'application/pdf'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TDocumentMimeTypeOption; static;
    end;

    {$SCOPEDENUMS OFF}

    TVideoMimeTypeOption = (
      video_mp4,
      video_mpeg,
      video_mov,
      video_avi,
      video_x_flv,
      video_mpg,
      video_webm,
      video_wmv,
      video_3gpp
    );

    TVideoMimeTypeOptionHelper = record Helper for TVideoMimeTypeOption
    const
      VideoMimeTypeOptions: array[TVideoMimeTypeOption] of string = (
        'video/mp4',
        'video/mpeg',
        'video/mov',
        'video/avi',
        'video/x-flv',
        'video/mpg',
        'video/webm',
        'video/wmv',
        'video/3gpp'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TVideoMimeTypeOption; static;
    end;

    {$SCOPEDENUMS ON}

    TUrlStatus = (
      success,
      error,
      paywall,
      unsafe
    );

    TUrlStatusHelper = record Helper for TUrlStatus
    const
      UrlStatus: array[TUrlStatus] of string = (
        'success',
        'error',
        'paywall',
        'unsafe'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TUrlStatus; static;
    end;

  {$ENDREGION}

  {$REGION 'Gemini.Interactions.Tools'}

    {$SCOPEDENUMS ON}

    TToolType = (
      &function,
      google_search,
      code_execution,
      url_context,
      computer_use,
      mcp_server,
      file_search
    );

    TToolTypeHelper = record Helper for TToolType
    const
      ToolTypes: array[TToolType] of string = (
        'function',
        'google_search',
        'code_execution',
        'url_context',
        'computer_use',
        'mcp_server',
        'file_search'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TToolType; static;
    end;

    {$SCOPEDENUMS OFF}

    TComputerEnvironmentType = (
      browser
    );

    TComputerEnvironmentTypeHelper = record Helper for TComputerEnvironmentType
    const
      ComputerEnvironmentTypes: array[TComputerEnvironmentType] of string = (
        'browser'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TComputerEnvironmentType; static;
    end;

    {$SCOPEDENUMS ON}

    TToolChoiceType = (
      auto,
      any,
      none,
      validated
    );

    ToolChoiceTypeHelper = record Helper for TToolChoiceType
    const
      ToolChoiceTypes: array[TToolChoiceType] of string = (
        'auto',
        'any',
        'none',
        'validated'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TToolChoiceType; static;
    end;

  {$ENDREGION}

  {$REGION 'Gemini.Interactions.GenerationConfig'}

    {$SCOPEDENUMS ON}

    TThinkingLevel = (
      minimal,
      low,
      medium,
      high
    );

    TThinkingLevelHelper = record Helper for TThinkingLevel
    const
      ThinkingLevels: array[TThinkingLevel] of string = (
        'minimal',
        'low',
        'medium',
        'high'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TThinkingLevel; static;
    end;

    {$SCOPEDENUMS ON}

    TThinkingSummaries = (
      auto,
      none
    );

    TThinkingSummariesHelper = record Helper for TThinkingSummaries
    const
      ThinkingSummaries: array[TThinkingSummaries] of string = (
        'auto',
        'none'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TThinkingSummaries; static;
    end;

  {$ENDREGION}

  {$REGION 'Gemini.Interactions'}

    {$SCOPEDENUMS ON}

    TAgentConfigType = (
      &dynamic,
      deep_research
    );

    TAgentConfigTypeHelper = record Helper for TAgentConfigType
    const
      AgentConfigTypes: array[TAgentConfigType] of string = (
        'dynamic',
        'deep-research'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TAgentConfigType; static;
    end;

    {$SCOPEDENUMS ON}

    TResponseModality = (
      text,
      image,
      audio
    );

    TResponseModalityHelper = record Helper for TResponseModality
    const
      ResponseModalities: array[TResponseModality] of string = (
        'text',
        'image',
        'audio'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TResponseModality; static;
      class function ToStringArray(const Enums: TArray<TResponseModality>): TArray<string>; static;
    end;

  {$ENDREGION}

  {$REGION 'Gemini.Interactions.Responses'}

    {$SCOPEDENUMS ON}

    TInteractionStatusType = (
      in_progress,
      requires_action,
      completed,
      failed,
      cancelled
    );

    TInteractionStatusTypeHelper = record Helper for TInteractionStatusType
    const
      InteractionStatusTypes: array[TInteractionStatusType] of string = (
        'in_progress',
        'requires_action',
        'completed',
        'failed',
        'cancelled'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TInteractionStatusType; static;
    end;

    TInteractionStatusTypeInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

  {$ENDREGION}


  {$REGION 'Gemini.Interactions.Stream'}

    {$SCOPEDENUMS OFF}

    TEventType = (
      interaction_start,
      interaction_complete,
      interaction_status_update,
      content_start,
      content_delta,
      content_stop,
      error
    );

    TEventTypeHelper = record Helper for TEventType
    const
      EventTypes: array[TEventType] of string = (
        'interaction.start',
        'interaction.complete',
        'interaction.status_update',
        'content.start',
        'content.delta',
        'content.stop',
        'error'
      );
    public
      function ToString: string; inline;
      class function Parse(const S: string): TEventType; static;
    end;

    TEventTypeInterceptor = class(TJSONInterceptorStringToString)
      function StringConverter(Data: TObject; Field: string): string; override;
      procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
    end;

  {$ENDREGION}

implementation

uses
  Gemini.API.JSONShield;

{ TArgsFixInterceptor }

procedure TArgsFixInterceptor.StringReverter(Data: TObject; Field, Arg: string);
begin
  RTTI
    .GetType(Data.ClassType)
    .GetField(Field)
    .SetValue(Data, TJsonPolyUnshield.Restore(Arg));
end;

{ TMessageRoleHelper }

class function TMessageRoleHelper.Parse(const S: string): TMessageRole;
begin
  Result := TEnumWire.Parse<TMessageRole>(S, MessageRoles);
end;

function TMessageRoleHelper.ToString: string;
begin
  Result := MessageRoles[Self];
end;

{ TMessageRoleInterceptor }

function TMessageRoleInterceptor.StringConverter(Data: TObject; Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TMessageRole>(Data, Field);
  Result := V.ToString;
end;

procedure TMessageRoleInterceptor.StringReverter(Data: TObject; Field, Arg: string);
begin
  var V := TMessageRole.Parse(Arg);
  TRttiMemberAccess.SetValue<TMessageRole>(Data, Field, V);
end;

{ TFinishReasonHelper }

class function TFinishReasonHelper.Parse(const S: string): TFinishReason;
begin
  Result := TEnumWire.Parse<TFinishReason>(S, FinishReasons);
end;

function TFinishReasonHelper.ToString: string;
begin
  Result := FinishReasons[Self];
end;

{ TFinishReasonInterceptor }

function TFinishReasonInterceptor.StringConverter(Data: TObject; Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TFinishReason>(Data, Field);
  Result := V.ToString;
end;

procedure TFinishReasonInterceptor.StringReverter(Data: TObject; Field, Arg: string);
begin
  var V := TFinishReason.Parse(Arg);
  TRttiMemberAccess.SetValue<TFinishReason>(Data, Field, V);
end;

{ TLanguageTypeHelper }

class function TLanguageTypeHelper.Parse(const S: string): TLanguageType;
begin
  Result := TEnumWire.Parse<TLanguageType>(S, LanguageTypes);
end;

function TLanguageTypeHelper.ToString: string;
begin
  Result := LanguageTypes[Self];
end;

{ TLanguageTypeInterceptor }

function TLanguageTypeInterceptor.StringConverter(Data: TObject; Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TLanguageType>(Data, Field);
  Result := V.ToString;
end;

procedure TLanguageTypeInterceptor.StringReverter(Data: TObject; Field, Arg: string);
begin
  var V := TLanguageType.Parse(Arg);
  TRttiMemberAccess.SetValue<TLanguageType>(Data, Field, V);
end;

{ TOutcomeTypeHelper }

class function TOutcomeTypeHelper.Parse(const S: string): TOutcomeType;
begin
  Result := TEnumWire.Parse<TOutcomeType>(S, OutcomeTypes);
end;

function TOutcomeTypeHelper.ToString: string;
begin
  Result := OutcomeTypes[Self];
end;

{ TOutcomeTypeInterceptor }

function TOutcomeTypeInterceptor.StringConverter(Data: TObject; Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TOutcomeType>(Data, Field);
  Result := V.ToString;
end;

procedure TOutcomeTypeInterceptor.StringReverter(Data: TObject; Field, Arg: string);
begin
  var V := TOutcomeType.Parse(Arg);
  TRttiMemberAccess.SetValue<TOutcomeType>(Data, Field, V);
end;

{ TSchemaTypeHelper }

class function TSchemaTypeHelper.Parse(const S: string): TSchemaType;
begin
  Result := TEnumWire.Parse<TSchemaType>(S, SchemaTypes);
end;

function TSchemaTypeHelper.ToString: string;
begin
  Result := SchemaTypes[Self];
end;

{ TTaskTypeHelper }

class function TTaskTypeHelper.Parse(const S: string): TTaskType;
begin
  Result := TEnumWire.Parse<TTaskType>(S, TaskTypes);
end;

function TTaskTypeHelper.ToString: string;
begin
  Result := TaskTypes[Self];
end;

{ TSchedulingTypeHelper }

class function TSchedulingTypeHelper.Parse(const S: string): TSchedulingType;
begin
  Result := TEnumWire.Parse<TSchedulingType>(S, SchedulingTypes);
end;

function TSchedulingTypeHelper.ToString: string;
begin
  Result := SchedulingTypes[Self];
end;

{ TBehaviorTypeHelper }

class function TBehaviorTypeHelper.Parse(const S: string): TBehaviorType;
begin
  Result := TEnumWire.Parse<TBehaviorType>(S, BehaviorTypes);
end;

function TBehaviorTypeHelper.ToString: string;
begin
  Result := BehaviorTypes[Self];
end;

{ TModeTypeHelper }

class function TModeTypeHelper.Parse(const S: string): TModeType;
begin
  Result := TEnumWire.Parse<TModeType>(S, ModeTypes);
end;

function TModeTypeHelper.ToString: string;
begin
  Result := ModeTypes[Self];
end;

{ TEnvironmentTypeHelper }

class function TEnvironmentTypeHelper.Parse(const S: string): TEnvironmentType;
begin
  Result := TEnumWire.Parse<TEnvironmentType>(S, EnvironmentTypes);
end;

function TEnvironmentTypeHelper.ToString: string;
begin
  Result := EnvironmentTypes[Self];
end;

{ TToolConfigModeHelper }

class function TToolConfigModeHelper.Parse(const S: string): TToolConfigMode;
begin
  Result := TEnumWire.Parse<TToolConfigMode>(S, ToolConfigModes);
end;

function TToolConfigModeHelper.ToString: string;
begin
  Result := ToolConfigModes[Self];
end;

{ TModalityTypeHelper }

class function TModalityTypeHelper.Parse(const S: string): TModalityType;
begin
  Result := TEnumWire.Parse<TModalityType>(S, ModalityTypes);
end;

function TModalityTypeHelper.ToString: string;
begin
  Result := ModalityTypes[Self];
end;

{ TThinkingLevelTypeHelper }

class function TThinkingLevelTypeHelper.Parse(
  const S: string): TThinkingLevelType;
begin
  Result := TEnumWire.Parse<TThinkingLevelType>(S, ThinkingLevelTypes);
end;

function TThinkingLevelTypeHelper.ToString: string;
begin
  Result := ThinkingLevelTypes[Self];
end;

{ TMediaResolutionTypeHelper }

class function TMediaResolutionTypeHelper.Parse(
  const S: string): TMediaResolutionType;
begin
  Result := TEnumWire.Parse<TMediaResolutionType>(S, MediaResolutionTypes);
end;

function TMediaResolutionTypeHelper.ToString: string;
begin
  Result := MediaResolutionTypes[Self];
end;

{ TSchedulingTypeInterceptor }

function TSchedulingTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TSchedulingType>(Data, Field);
  Result := V.ToString;
end;

procedure TSchedulingTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  var V := TSchedulingType.Parse(Arg);
  TRttiMemberAccess.SetValue<TSchedulingType>(Data, Field, V);
end;

{ TUrlRetrievalStatusTypeHelper }

class function TUrlRetrievalStatusTypeHelper.Parse(
  const S: string): TUrlRetrievalStatusType;
begin
  Result := TEnumWire.Parse<TUrlRetrievalStatusType>(S, UrlRetrievalStatusTypes);
end;

function TUrlRetrievalStatusTypeHelper.ToString: string;
begin
  Result := UrlRetrievalStatusTypes[Self];
end;

{ TUrlRetrievalStatusTypeInterceptor }

function TUrlRetrievalStatusTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TUrlRetrievalStatusType>(Data, Field);
  Result := V.ToString;
end;

procedure TUrlRetrievalStatusTypeInterceptor.StringReverter(Data: TObject;
  Field, Arg: string);
begin
  var V := TUrlRetrievalStatusType.Parse(Arg);
  TRttiMemberAccess.SetValue<TUrlRetrievalStatusType>(Data, Field, V);
end;

{ TBlockReasonHelper }

class function TBlockReasonHelper.Parse(const S: string): TBlockReason;
begin
  Result := TEnumWire.Parse<TBlockReason>(S, BlockReasons);
end;

function TBlockReasonHelper.ToString: string;
begin
  Result := BlockReasons[Self];
end;

{ TBlockReasonInterceptor }

function TBlockReasonInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TBlockReason>(Data, Field);
  Result := V.ToString;
end;

procedure TBlockReasonInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  var V := TBlockReason.Parse(Arg);
  TRttiMemberAccess.SetValue<TBlockReason>(Data, Field, V);
end;

{ THarmCategoryHelper }

class function THarmCategoryHelper.Parse(const S: string): THarmCategory;
begin
  Result := TEnumWire.Parse<THarmCategory>(S, HarmCategories);
end;

function THarmCategoryHelper.ToString: string;
begin
  Result := HarmCategories[Self];
end;

{ THarmCategoryInterceptor }

function THarmCategoryInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<THarmCategory>(Data, Field);
  Result := V.ToString;
end;

procedure THarmCategoryInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  var V := THarmCategory.Parse(Arg);
  TRttiMemberAccess.SetValue<THarmCategory>(Data, Field, V);
end;

{ THarmBlockThresholdHelper }

class function THarmBlockThresholdHelper.Parse(const S: string): THarmBlockThreshold;
begin
  Result := TEnumWire.Parse<THarmBlockThreshold>(S, HarmBlockThresholds);
end;

function THarmBlockThresholdHelper.ToString: string;
begin
  Result := HarmBlockThresholds[Self];
end;

{ THarmProbabilityHelper }

class function THarmProbabilityHelper.Parse(const S: string): THarmProbability;
begin
  Result := TEnumWire.Parse<THarmProbability>(S, HarmProbabilities);
end;

function THarmProbabilityHelper.ToString: string;
begin
  Result := HarmProbabilities[Self];
end;

{ THarmProbabilityInterceptor }

function THarmProbabilityInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<THarmProbability>(Data, Field);
  Result := V.ToString;
end;

procedure THarmProbabilityInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  var V := THarmProbability.Parse(Arg);
  TRttiMemberAccess.SetValue<THarmProbability>(Data, Field, V);
end;

{ TTokenModalityTypeHelper }

class function TTokenModalityTypeHelper.Parse(
  const S: string): TTokenModalityType;
begin
  Result := TEnumWire.Parse<TTokenModalityType>(S, TokenModalityTypes);
end;

function TTokenModalityTypeHelper.ToString: string;
begin
  Result := TokenModalityTypes[Self];
end;

{ TTokenModalityTypeInterceptor }

function TTokenModalityTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TTokenModalityType>(Data, Field);
  Result := V.ToString;
end;

procedure TTokenModalityTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  var V := TTokenModalityType.Parse(Arg);
  TRttiMemberAccess.SetValue<TTokenModalityType>(Data, Field, V);
end;

{ TStateTypeHelper }

class function TStateTypeHelper.Parse(const S: string): TStateType;
begin
  Result := TEnumWire.Parse<TStateType>(S, StateTypes);
end;

function TStateTypeHelper.ToString: string;
begin
  Result := StateTypes[Self];
end;

{ TStateTypeInterceptor }

function TStateTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TStateType>(Data, Field);
  Result := V.ToString;
end;

procedure TStateTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  var V := TStateType.Parse(Arg);
  TRttiMemberAccess.SetValue<TStateType>(Data, Field, V);
end;

{ TSourceTypeHelper }

class function TSourceTypeHelper.Parse(const S: string): TSourceType;
begin
  Result := TEnumWire.Parse<TSourceType>(S, SourceTypes);
end;

function TSourceTypeHelper.ToString: string;
begin
  Result := SourceTypes[Self];
end;

{ TSourceTypeInterceptor }

function TSourceTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TSourceType>(Data, Field);
  Result := V.ToString;
end;

procedure TSourceTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  var V := TSourceType.Parse(Arg);
  TRttiMemberAccess.SetValue<TSourceType>(Data, Field, V);
end;

{ TToolModeHelper }

class function TToolModeHelper.Parse(const S: string): TToolMode;
begin
  Result := TEnumWire.Parse<TToolMode>(S, ToolModes);
end;

function TToolModeHelper.ToString: string;
begin
  Result := ToolModes[Self];
end;

{ TModelStateHelper }

class function TModelStateHelper.Parse(const S: string): TModelState;
begin
  Result := TEnumWire.Parse<TModelState>(S, ModelStates);
end;

function TModelStateHelper.ToString: string;
begin
  Result := ModelStates[Self];
end;

{ TModelStateInterceptor }

function TModelStateInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TModelState>(Data, Field);
  Result := V.ToString;
end;

procedure TModelStateInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  var V := TModelState.Parse(Arg);
  TRttiMemberAccess.SetValue<TModelState>(Data, Field, V);
end;

{ TDocumentStateHelper }

class function TDocumentStateHelper.Parse(const S: string): TDocumentState;
begin
  Result := TEnumWire.Parse<TDocumentState>(S, DocumentStates);
end;

function TDocumentStateHelper.ToString: string;
begin
  Result := DocumentStates[Self];
end;

{ TDocumentStateInterceptor }

function TDocumentStateInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TDocumentState>(Data, Field);
  Result := V.ToString;
end;

procedure TDocumentStateInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  var V := TDocumentState.Parse(Arg);
  TRttiMemberAccess.SetValue<TDocumentState>(Data, Field, V);
end;

{ TBatchStateTypeHelper }

class function TBatchStateTypeHelper.Parse(const S: string): TBatchStateType;
begin
  Result := TEnumWire.Parse<TBatchStateType>(S, BatchStateTypes);
end;

function TBatchStateTypeHelper.ToString: string;
begin
  Result := BatchStateTypes[Self];
end;

{ TOperationPathHelper }

class function TOperationPathHelper.Parse(const S: string): TOperationPath;
begin
  Result := TEnumWire.Parse<TOperationPath>(S, OperationPaths);
end;

function TOperationPathHelper.ToString: string;
begin
  Result := OperationPaths[Self];
end;

{ TContentTypeHelper }

class function TContentTypeHelper.Parse(const S: string): TContentType;
begin
  Result := TEnumWire.Parse<TContentType>(S, ContentTypes);
end;

function TContentTypeHelper.ToString: string;
begin
  Result := ContentTypes[Self];
end;

{ TContentTypeInterceptor }

function TContentTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TContentType>(Data, Field);
  Result := V.ToString;
end;

procedure TContentTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  var V := TContentType.Parse(Arg);
  TRttiMemberAccess.SetValue<TContentType>(Data, Field, V);
end;

{ TImageMimeTypeOptionHelper }

class function TImageMimeTypeOptionHelper.Parse(const S: string): TImageMimeTypeOption;
begin
  Result := TEnumWire.Parse<TImageMimeTypeOption>(S, ImageMimeTypeOptions);
end;

function TImageMimeTypeOptionHelper.ToString: string;
begin
  Result := ImageMimeTypeOptions[Self];
end;

{ TMediaResolutionHelper }

class function TMediaResolutionHelper.Parse(
  const S: string): TMediaResolution;
begin
  Result := TEnumWire.Parse<TMediaResolution>(S, MediaResolutions);
end;

function TMediaResolutionHelper.ToString: string;
begin
  Result := MediaResolutions[Self];
end;

{ TAudioMimeTypeOptionHelper }

class function TAudioMimeTypeOptionHelper.Parse(
  const S: string): TAudioMimeTypeOption;
begin
  Result := TEnumWire.Parse<TAudioMimeTypeOption>(S, AudioMimeTypeOptions);
end;

function TAudioMimeTypeOptionHelper.ToString: string;
begin
  Result := AudioMimeTypeOptions[Self];
end;

{ TDocumentMimeTypeOptionHelper }

class function TDocumentMimeTypeOptionHelper.Parse(
  const S: string): TDocumentMimeTypeOption;
begin
  Result := TEnumWire.Parse<TDocumentMimeTypeOption>(S, DocumentMimeTypeOptions);
end;

function TDocumentMimeTypeOptionHelper.ToString: string;
begin
  Result := DocumentMimeTypeOptions[Self]
end;

{ TVideoMimeTypeOptionHelper }

class function TVideoMimeTypeOptionHelper.Parse(
  const S: string): TVideoMimeTypeOption;
begin
  Result := TEnumWire.Parse<TVideoMimeTypeOption>(S, VideoMimeTypeOptions);
end;

function TVideoMimeTypeOptionHelper.ToString: string;
begin
  Result := VideoMimeTypeOptions[Self];
end;

{ TUrlStatusHelper }

class function TUrlStatusHelper.Parse(const S: string): TUrlStatus;
begin
  Result := TEnumWire.Parse<TUrlStatus>(S, UrlStatus);
end;

function TUrlStatusHelper.ToString: string;
begin
  Result := UrlStatus[Self];
end;

{ TToolTypeHelper }

class function TToolTypeHelper.Parse(const S: string): TToolType;
begin
  Result := TEnumWire.Parse<TToolType>(S, ToolTypes);
end;

function TToolTypeHelper.ToString: string;
begin
  Result := ToolTypes[Self];
end;

{ TComputerEnvironmentTypeHelper }

class function TComputerEnvironmentTypeHelper.Parse(
  const S: string): TComputerEnvironmentType;
begin
  Result := TEnumWire.Parse<TComputerEnvironmentType>(S, ComputerEnvironmentTypes);
end;

function TComputerEnvironmentTypeHelper.ToString: string;
begin
  Result := ComputerEnvironmentTypes[Self];
end;

{ ToolChoiceTypeHelper }

class function ToolChoiceTypeHelper.Parse(const S: string): TToolChoiceType;
begin
  Result := TEnumWire.Parse<TToolChoiceType>(S, ToolChoiceTypes);
end;

function ToolChoiceTypeHelper.ToString: string;
begin
  Result := ToolChoiceTypes[Self];
end;

{ TThinkingLevelHelper }

class function TThinkingLevelHelper.Parse(const S: string): TThinkingLevel;
begin
  Result := TEnumWire.Parse<TThinkingLevel>(S, ThinkingLevels);
end;

function TThinkingLevelHelper.ToString: string;
begin
  Result := ThinkingLevels[Self];
end;

{ TThinkingSummariesHelper }

class function TThinkingSummariesHelper.Parse(
  const S: string): TThinkingSummaries;
begin
  Result := TEnumWire.Parse<TThinkingSummaries>(S, ThinkingSummaries);
end;

function TThinkingSummariesHelper.ToString: string;
begin
  Result := ThinkingSummaries[Self];
end;

{ TAgentConfigTypeHelper }

class function TAgentConfigTypeHelper.Parse(const S: string): TAgentConfigType;
begin
  Result := TEnumWire.Parse<TAgentConfigType>(S, AgentConfigTypes);
end;

function TAgentConfigTypeHelper.ToString: string;
begin
  Result := AgentConfigTypes[Self];
end;

{ TResponseModalityHelper }

class function TResponseModalityHelper.Parse(
  const S: string): TResponseModality;
begin
  Result := TEnumWire.Parse<TResponseModality>(S, ResponseModalities);
end;

function TResponseModalityHelper.ToString: string;
begin
  Result := ResponseModalities[Self];
end;

class function TResponseModalityHelper.ToStringArray(
  const Enums: TArray<TResponseModality>): TArray<string>;
begin
  Result := [];
  for var Item in Enums do
    Result := Result + [Item.ToString];
end;

{ TInteractionStatusTypeHelper }

class function TInteractionStatusTypeHelper.Parse(
  const S: string): TInteractionStatusType;
begin
  Result := TEnumWire.Parse<TInteractionStatusType>(S, InteractionStatusTypes);
end;

function TInteractionStatusTypeHelper.ToString: string;
begin
  Result := InteractionStatusTypes[Self];
end;

{ TInteractionStatusTypeInterceptor }

function TInteractionStatusTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TInteractionStatusType>(Data, Field);
  Result := V.ToString;
end;

procedure TInteractionStatusTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  var V := TInteractionStatusType.Parse(Arg);
  TRttiMemberAccess.SetValue<TInteractionStatusType>(Data, Field, V);
end;

{ TEventTypeHelper }

class function TEventTypeHelper.Parse(const S: string): TEventType;
begin
  Result := TEnumWire.Parse<TEventType>(S, EventTypes);
end;

function TEventTypeHelper.ToString: string;
begin
  Result := EventTypes[Self];
end;

{ TEventTypeInterceptor }

function TEventTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  var V := TRttiMemberAccess.GetValue<TEventType>(Data, Field);
  Result := V.ToString;
end;

procedure TEventTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  var V := TEventType.Parse(Arg);
  TRttiMemberAccess.SetValue<TEventType>(Data, Field, V);
end;

end.

