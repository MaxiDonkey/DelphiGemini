unit Gemini.Vectors.Endpoints;

interface

uses
  System.SysUtils;

type
  EGeminiEndpointError = class(Exception);

  TVectorEndpoints = record
  public
    class function IsStoreOnly(const Value: string): Boolean; static;
    class function IsDocumentName(const Value: string): Boolean; static;
    class function IsDocumentsCollection(const Value: string): Boolean; static;
    class function IsOperationName(const Value: string): Boolean; static;
    class function StoreOf(const Value: string): string; static;
    class function DocumentsCollectionOf(const Value: string): string; static;

    class function RequireStoreOnly(const Value, ErrMsg: string): string; overload; static;
    class function RequireStoreOnly(const Value: string): string; overload; static;
    class function RequireDocumentName(const Value, ErrMsg: string): string; static;
  end;

implementation

resourcestring
  INVALID_STORE_ENDPOINT =
    'Invalid endpoint. Expected: fileSearchStores/{storeId}.';
  INVALID_STORE_PREFIX =
    'Invalid endpoint. Expected prefix: fileSearchStores/{storeId}.';

function Parts(const Value: string): TArray<string>;
begin
  Result := Value.Split(['/'], TStringSplitOptions.ExcludeEmpty);
end;

class function TVectorEndpoints.IsStoreOnly(const Value: string): Boolean;
begin
  var Items := Parts(Value);
  Result :=
    (Length(Items) = 2) and
    SameText(Items[0], 'fileSearchStores') and
    (not Items[1].IsEmpty);
end;

class function TVectorEndpoints.IsDocumentsCollection(const Value: string): Boolean;
begin
  var Items := Parts(Value);
  Result :=
    (Length(Items) = 3) and
    SameText(Items[0], 'fileSearchStores') and
    (not Items[1].IsEmpty) and
    SameText(Items[2], 'documents');
end;

class function TVectorEndpoints.IsDocumentName(const Value: string): Boolean;
begin
  var Items := Parts(Value);
  Result :=
    (Length(Items) = 4) and
    SameText(Items[0], 'fileSearchStores') and
    (not Items[1].IsEmpty) and
    SameText(Items[2], 'documents') and
    (not Items[3].IsEmpty);
end;

class function TVectorEndpoints.IsOperationName(const Value: string): Boolean;
begin
  var Items := Parts(Value);
  Result :=
    (Length(Items) = 4) and
    SameText(Items[0], 'fileSearchStores') and
    (not Items[1].IsEmpty) and
    SameText(Items[2], 'operations') and
    (not Items[3].IsEmpty);
end;

class function TVectorEndpoints.StoreOf(const Value: string): string;
begin
  var Items := Parts(Value);

  if (Length(Items) < 2) or (not SameText(Items[0], 'fileSearchStores')) or Items[1].IsEmpty then
    raise EGeminiEndpointError.Create(INVALID_STORE_PREFIX);

  Result := 'fileSearchStores/' + Items[1];
end;

class function TVectorEndpoints.DocumentsCollectionOf(const Value: string): string;
begin
  Result := StoreOf(Value) + '/documents';
end;

class function TVectorEndpoints.RequireStoreOnly(const Value, ErrMsg: string): string;
begin
  if not IsStoreOnly(Value) then
    raise EGeminiEndpointError.Create(ErrMsg);
  Result := Value;
end;

class function TVectorEndpoints.RequireDocumentName(const Value, ErrMsg: string): string;
begin
  if not IsDocumentName(Value) then
    raise EGeminiEndpointError.Create(ErrMsg);
  Result := Value;
end;

class function TVectorEndpoints.RequireStoreOnly(const Value: string): string;
begin
  Result := RequireStoreOnly(Value, INVALID_STORE_ENDPOINT);
end;

end.

