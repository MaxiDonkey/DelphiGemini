unit Gemini.Interactions.Request;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.JSON,
  REST.JsonReflect, REST.Json.Types,
  Gemini.API.Params, Gemini.API, Gemini.Types, Gemini.Exceptions,
  Gemini.Interactions.Content, Gemini.Interactions.Tools, Gemini.Schema,
  Gemini.Interactions.GenerationConfig;

type
  TDynamicAgentConfigIxParams = class(TJSONParam)
    /// <summary>
    /// Always set to "dynamic".
    /// </summary>
    function &Type(const Value: TAgentConfigType = TAgentConfigType.dynamic): TDynamicAgentConfigIxParams;

    class function New: TDynamicAgentConfigIxParams;
  end;

  TDeepResearchAgentConfigIxParams = class(TJSONParam)
    /// <summary>
    /// Always set to "deep-research".
    /// </summary>
    function &Type(const Value: TAgentConfigType = TAgentConfigType.deep_research): TDeepResearchAgentConfigIxParams;

    /// <summary>
    /// Whether to include thought summaries in the response.
    /// </summary>
    function ThinkingSummaries(const Value: TThinkingSummaries): TDeepResearchAgentConfigIxParams; overload;

    /// <summary>
    /// Whether to include thought summaries in the response.
    /// </summary>
    function ThinkingSummaries(const Value: string): TDeepResearchAgentConfigIxParams; overload;

    class function New: TDeepResearchAgentConfigIxParams;
  end;

  TInteractionParams = class(TJSONParam)
    /// <summary>
    /// The name of the `Model` used for generating the interaction.
    /// </summary>
    /// <remarks>
    /// Required if `agent` is not provided.
    /// </remarks>
    function Model(const Value: string): TInteractionParams;

    /// <summary>
    /// The name of the `Agent` used for generating the interaction.
    /// </summary>
    /// <remarks>
    /// Required if `model` is not provided.
    /// </remarks>
    function Agent(const Value: string): TInteractionParams;

    /// <summary>
    /// The inputs for the interaction (common to both Model and Agent).
    /// </summary>
    function Input(const Value: string): TInteractionParams; overload;

    /// <summary>
    /// The inputs for the interaction (common to both Model and Agent).
    /// </summary>
    function Input(const Value: TContentIxParams): TInteractionParams; overload;

    /// <summary>
    /// The inputs for the interaction (common to both Model and Agent).
    /// </summary>
    function Input(const Value: TArray<TContentIxParams>): TInteractionParams; overload;

    /// <summary>
    /// The inputs for the interaction (common to both Model and Agent).
    /// </summary>
    function Input(const Value: TArray<TTurnIxParams>): TInteractionParams; overload;

    /// <summary>
    /// The inputs for the interaction (common to both Model and Agent).
    /// </summary>
    function Input(const Value: TArray<TTurnParams>): TInteractionParams; overload;

    /// <summary>
    /// A list of tool declarations the model may call during interaction.
    /// </summary>
    function Tools(const Value: TArray<TToolIxParams>): TInteractionParams; overload;

    /// <summary>
    /// A list of tool declarations the model may call during interaction.
    /// </summary>
    function Tools(const Value: string): TInteractionParams; overload;

    /// <summary>
    /// Enforces that the generated response is a JSON object that complies with the JSON schema specified
    /// in this field.
    /// </summary>
    function ResponseFormat(const Value: TJSONObject): TInteractionParams; overload;

    /// <summary>
    /// Enforces that the generated response is a JSON object that complies with the JSON schema specified
    /// in this field.
    /// </summary>
    function ResponseFormat(const Value: TSchemaParams): TInteractionParams; overload;

    /// <summary>
    /// Enforces that the generated response is a JSON object that complies with the JSON schema specified
    /// in this field.
    /// </summary>
    function ResponseFormat(const Value: string): TInteractionParams; overload;

    /// <summary>
    /// The mime type of the response. This is required if response_format is set.
    /// </summary>
    function ResponseMimeType(const Value: string): TInteractionParams;

    /// <summary>
    /// Input only. Whether the interaction will be streamed.
    /// </summary>
    function Stream(const Value: Boolean = True): TInteractionParams;

    /// <summary>
    /// Input only. Whether to store the response and request for later retrieval.
    /// </summary>
    function Store(const Value: Boolean = True): TInteractionParams;

    /// <summary>
    /// Whether to run the model interaction in the background.
    /// </summary>
    function Background(const Value: Boolean = True): TInteractionParams;

    /// <summary>
    /// Configuration parameters for the model interaction.
    /// </summary>
    /// <remarks>
    /// Alternative to `agent_config`. Only applicable when `model` is set.
    /// </remarks>
    function GenerationConfig(const Value: TGenerationConfigIxParams): TInteractionParams; overload;

    /// <summary>
    /// Configuration parameters for the model interaction.
    /// </summary>
    /// <remarks>
    /// Alternative to `agent_config`. Only applicable when `model` is set.
    /// </remarks>
    function GenerationConfig(const Value: TJSONObject): TInteractionParams; overload;

    /// <summary>
    /// Configuration parameters for the model interaction.
    /// </summary>
    /// <remarks>
    /// Alternative to `agent_config`. Only applicable when `model` is set.
    /// </remarks>
    function GenerationConfig(const Value: string): TInteractionParams; overload;

    /// <summary>
    /// Configuration for the agent.
    /// </summary>
    /// <remarks>
    /// Alternative to `generation_config`. Only applicable when `agent` is set.
    /// </remarks>
    function AgentConfig(const Value: TJSONObject): TInteractionParams; overload;

    /// <summary>
    /// Configuration for the agent.
    /// </summary>
    /// <remarks>
    /// Alternative to `generation_config`. Only applicable when `agent` is set.
    /// </remarks>
    function AgentConfig(const Value: TDynamicAgentConfigIxParams): TInteractionParams; overload;

    /// <summary>
    /// Configuration for the agent.
    /// </summary>
    /// <remarks>
    /// Alternative to `generation_config`. Only applicable when `agent` is set.
    /// </remarks>
    function AgentConfig(const Value: TDeepResearchAgentConfigIxParams): TInteractionParams; overload;

    /// <summary>
    /// Configuration for the agent.
    /// </summary>
    /// <remarks>
    /// Alternative to `generation_config`. Only applicable when `agent` is set.
    /// </remarks>
    function AgentConfig(const Value: string): TInteractionParams; overload;

    /// <summary>
    /// The requested modalities of the response (TEXT, IMAGE, AUDIO).
    /// </summary>
    function ResponseModalities(const Value: TResponseModality): TInteractionParams; overload;

    /// <summary>
    /// The requested modalities of the response (TEXT, IMAGE, AUDIO).
    /// </summary>
    function ResponseModalities(const Value: string): TInteractionParams; overload;

    /// <summary>
    /// The ID of the previous interaction, if any.
    /// </summary>
    function PreviousInteractionId(const Value: string): TInteractionParams;
  end;

implementation

{ TInteractionParams }

function TInteractionParams.Agent(const Value: string): TInteractionParams;
begin
  Result := TInteractionParams(Add('agent', Value));
end;

function TInteractionParams.AgentConfig(
  const Value: TJSONObject): TInteractionParams;
begin
  Result := TInteractionParams(Add('agent_config', Value));
end;

function TInteractionParams.AgentConfig(
  const Value: TDynamicAgentConfigIxParams): TInteractionParams;
begin
  Result := Self.AgentConfig(Value.Detach);
end;

function TInteractionParams.AgentConfig(
  const Value: TDeepResearchAgentConfigIxParams): TInteractionParams;
begin
  Result := Self.AgentConfig(Value.Detach);
end;

function TInteractionParams.AgentConfig(
  const Value: string): TInteractionParams;
var
  JSONObject: TJSONObject;
begin
  if TJSONHelper.TryGetObject(Value, JSONObject) then
    Exit(TInteractionParams(Add('agent_config', JSONObject)));

  raise EGeminiException.Create('Invalid JSON Object');
end;

function TInteractionParams.Background(
  const Value: Boolean): TInteractionParams;
begin
  Result := TInteractionParams(Add('background', Value));
end;

function TInteractionParams.GenerationConfig(
  const Value: TJSONObject): TInteractionParams;
begin
  Result := TInteractionParams(Add('generation_config', Value));
end;

function TInteractionParams.GenerationConfig(
  const Value: TGenerationConfigIxParams): TInteractionParams;
begin
  Result := Self.GenerationConfig(Value.Detach);
end;

function TInteractionParams.GenerationConfig(
  const Value: string): TInteractionParams;
var
  JSONObject: TJSONObject;
begin
  if TJSONHelper.TryGetObject(Value, JSONObject) then
    Exit(TInteractionParams(Add('generation_config', JSONObject)));

  raise EGeminiException.Create('Invalid JSON Object');
end;

function TInteractionParams.Input(const Value: string): TInteractionParams;
var
  JSONArray: TJSONArray;
begin
  if TJSONHelper.TryGetArray(Value, JSONArray) then
    Exit(TInteractionParams(Add('input', JSONArray)));

  Result := TInteractionParams(Add('input', Value));
end;

function TInteractionParams.Input(
  const Value: TContentIxParams): TInteractionParams;
begin
  Result := TInteractionParams(Add('input', Value.Detach));
end;

function TInteractionParams.Input(
  const Value: TArray<TContentIxParams>): TInteractionParams;
begin
  Result := TInteractionParams(Add('input',
    TJSONHelper.ToJsonArray<TContentIxParams>(Value)));
end;

function TInteractionParams.Input(
  const Value: TArray<TTurnIxParams>): TInteractionParams;
begin
  Result := TInteractionParams(Add('input',
    TJSONHelper.ToJsonArray<TTurnIxParams>(Value)));
end;

function TInteractionParams.Input(
  const Value: TArray<TTurnParams>): TInteractionParams;
begin
  Result := TInteractionParams(Add('input',
    TJSONHelper.ToJsonArray<TTurnParams>(Value)));
end;


function TInteractionParams.Model(const Value: string): TInteractionParams;
begin
  Result := TInteractionParams(Add('model', Value));
end;

function TInteractionParams.PreviousInteractionId(
  const Value: string): TInteractionParams;
begin
  Result := TInteractionParams(Add('previous_interaction_id', Value));
end;

function TInteractionParams.ResponseFormat(
  const Value: string): TInteractionParams;
var
  JSONObject: TJSONObject;
begin
  if TJSONHelper.TryGetObject(Value, JSONObject) then
    Exit(TInteractionParams(Add('response_format', JSONObject)));

  raise EGeminiException.Create('Invalid JSON Object');
end;

function TInteractionParams.ResponseFormat(
  const Value: TSchemaParams): TInteractionParams;
begin
  Result := TInteractionParams(Add('response_format', Value.Detach));
end;

function TInteractionParams.ResponseFormat(
  const Value: TJSONObject): TInteractionParams;
begin
  Result := TInteractionParams(Add('response_format', Value));
end;

function TInteractionParams.ResponseMimeType(
  const Value: string): TInteractionParams;
begin
  Result := TInteractionParams(Add('response_mime_type', Value));
end;

function TInteractionParams.ResponseModalities(
  const Value: string): TInteractionParams;
begin
  Result := Self.ResponseModalities(TResponseModality.Parse(Value));
end;

function TInteractionParams.ResponseModalities(
  const Value: TResponseModality): TInteractionParams;
begin
  Result := TInteractionParams(Add('response_modalities', Value.ToString));
end;

function TInteractionParams.Store(const Value: Boolean): TInteractionParams;
begin
  Result := TInteractionParams(Add('store', Value));
end;

function TInteractionParams.Stream(const Value: Boolean): TInteractionParams;
begin
  Result := TInteractionParams(Add('stream', Value));
end;

function TInteractionParams.Tools(const Value: string): TInteractionParams;
var
  JSONArray: TJSONArray;
begin
  if TJSONHelper.TryGetArray(Value, JSONArray) then
    Exit(TInteractionParams(Add('tools', JSONArray)));

  raise EGeminiException.Create('Invalid JSON Array');
end;

function TInteractionParams.Tools(const Value:  TArray<TToolIxParams>): TInteractionParams;
begin
  Result := TInteractionParams(Add('tools',
    TJSONHelper.ToJsonArray<TToolIxParams>(Value)));
end;

{ TDynamicAgentConfigIxParams }

class function TDynamicAgentConfigIxParams.New: TDynamicAgentConfigIxParams;
begin
  Result := TDynamicAgentConfigIxParams.Create.&Type();
end;

function TDynamicAgentConfigIxParams.&Type(
  const Value: TAgentConfigType): TDynamicAgentConfigIxParams;
begin
  Result := TDynamicAgentConfigIxParams(Add('type', Value.ToString));
end;

{ TDeepResearchAgentConfigIxParams }

function TDeepResearchAgentConfigIxParams.ThinkingSummaries(
  const Value: TThinkingSummaries): TDeepResearchAgentConfigIxParams;
begin
  Result := TDeepResearchAgentConfigIxParams(Add('thinking_summaries', Value.ToString));
end;

class function TDeepResearchAgentConfigIxParams.New: TDeepResearchAgentConfigIxParams;
begin
  Result := TDeepResearchAgentConfigIxParams.Create.&Type();
end;

function TDeepResearchAgentConfigIxParams.ThinkingSummaries(
  const Value: string): TDeepResearchAgentConfigIxParams;
begin
  Result := Self.ThinkingSummaries(TThinkingSummaries.Parse(Value));
end;

function TDeepResearchAgentConfigIxParams.&Type(
  const Value: TAgentConfigType): TDeepResearchAgentConfigIxParams;
begin
  Result := TDeepResearchAgentConfigIxParams(Add('type', Value.ToString));
end;

end.
