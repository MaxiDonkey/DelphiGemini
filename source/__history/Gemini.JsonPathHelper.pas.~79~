unit Gemini.JsonPathHelper;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.JSON, System.Generics.Collections;

type
  TJSONValueHelper = class helper for TJSONValue
  public
    function GetPathValue(const Path: string): TJSONValue;
    function GetPathString(const Path: string; const Default: string = ''): string;
    function GetPathInteger(const Path: string; const Default: Integer = 0): Integer;
    function GetPathBoolean(const Path: string; const Default: Boolean = False): Boolean;
    function GetPathDouble(const Path: string; const Default: Double = 0.0): Double;
    function GetPathObjectText(const Path: string; const Default: string = ''): string;
    function GetPathArrayText(const Path: string; const Default: string = ''): string;
    function GetPathCount(const Path: string; const Default: Integer = 0): Integer;
  end;

  TJsonReader = record
  private
    FRoot: TJSONValue;
  public
    class function Parse(const JsonText: string): TJsonReader; static;

    class operator Initialize(out Dest: TJsonReader);
    class operator Finalize(var Dest: TJsonReader);

    function IsValid: Boolean; inline;

    function Value(const Path: string): TJSONValue; inline;

    function AsString(const Path: string; const Default: string = ''): string;
    function AsInteger(const Path: string; const Default: Integer = 0): Integer;
    function AsBoolean(const Path: string; const Default: Boolean = False): Boolean;
    function AsDouble(const Path: string; const Default: Double = 0.0): Double;

    function ObjectText(const Path: string; const Default: string = ''): string;
    function ArrayText(const Path: string; const Default: string = ''): string;
    function Count(const Path: string; const Default: Integer = 0): Integer;
    function Format(const Path: string; const Format: Integer = 4): string;
  end;

implementation

function NextToken(const S: string; var Index: Integer): string;
begin
  while (Index <= S.Length) and (S[Index] = '.') do
    Inc(Index);

  var Start := Index;

  while (Index <= S.Length) and (S[Index] <> '.') do
    Inc(Index);

  Result := S.Substring(Start - 1, Index - Start);
end;

function ParseArrayIndex(const Token: string; out Name: string; out HasIndex: Boolean; out Index: Integer): Boolean;
begin
  Name := Token;
  HasIndex := False;
  Index := -1;

  var Left := Token.IndexOf('[');
  if Left < 0 then
    Exit(True);

  var Right := Token.IndexOf(']', Left + 1);
  if Right < 0 then
    Exit(False);

  Name := Token.Substring(0, Left);
  var IndexStr := Token.Substring(Left + 1, Right - (Left + 1));
  HasIndex := True;
  Result := TryStrToInt(IndexStr, Index) and (Index >= 0);
end;

function TJSONValueHelper.GetPathValue(const Path: string): TJSONValue;
var
  Index: Integer;
  Name: string;
  HasIndex: Boolean;
begin
  Result := nil;
  var Current := Self;
  if (Current = nil) or Path.IsEmpty then
    Exit;

  var I := 1;
  while I <= Path.Length do
    begin
      var Token := NextToken(Path, I);
      if Token.IsEmpty then
        Break;

      if not ParseArrayIndex(Token, Name, HasIndex, Index) then
        Exit(nil);

      if not Name.IsEmpty then
        begin
          if not (Current is TJSONObject) then
            Exit(nil);

          var JSONObjet := TJSONObject(Current);
          Current := JSONObjet.GetValue(Name);
          if Current = nil then
            Exit(nil);
        end;

      if HasIndex then
        begin
          if not (Current is TJSONArray) then
            Exit(nil);

          var JSONArray := TJSONArray(Current);
          if (Index < 0) or (Index >= JSONArray.Count) then
            Exit(nil);

          Current := JSONArray.Items[Index];
          if Current = nil then
            Exit(nil);
        end;
  end;

  Result := Current;
end;

function TJSONValueHelper.GetPathString(const Path: string; const Default: string): string;
begin
  var JSONValue := GetPathValue(Path);
  if JSONValue = nil then
    Exit(Default);

  if JSONValue is TJSONString then
    Exit(TJSONString(JSONValue).Value);

  if JSONValue is TJSONNumber then
    Exit(TJSONNumber(JSONValue).ToString);

  Result := JSONValue.Value;
  if Result.IsEmpty then
    Result := JSONValue.ToString;
end;

function TJSONValueHelper.GetPathInteger(const Path: string; const Default: Integer): Integer;
begin
  var PathString := GetPathString(Path, '');
  if not PathString.IsEmpty and TryStrToInt(PathString, Result) then
    Exit;

  Result := Default;
end;

function TJSONValueHelper.GetPathArrayText(const Path, Default: string): string;
begin
  var JSONValue := GetPathValue(Path);
  if (JSONValue <> nil) and (JSONValue is TJSONArray) then
    Exit(TJSONArray(JSONValue).ToJSON);

  Result := Default;
end;

function TJSONValueHelper.GetPathObjectText(const Path, Default: string): string;
begin
  var JSONValue := GetPathValue(Path);
  if (JSONValue <> nil) and (JSONValue is TJSONObject) then
    Exit(TJSONObject(JSONValue).ToJSON);

  Result := Default;
end;

function TJSONValueHelper.GetPathBoolean(const Path: string; const Default: Boolean): Boolean;
begin
  var PathString := GetPathString(Path, '');
  if SameText(PathString, 'true') then
    Exit(True);

  if SameText(PathString, 'false') then
    Exit(False);

  Result := Default;
end;

function TJSONValueHelper.GetPathCount(const Path: string; const Default: Integer): Integer;
begin
  var V := GetPathValue(Path);
  if V = nil then
    Exit(Default);

  if V is TJSONArray then
    Exit(TJSONArray(V).Count);

  if V is TJSONObject then
    Exit(TJSONObject(V).Count);

  Result := Default;
end;

function TJSONValueHelper.GetPathDouble(const Path: string; const Default: Double): Double;
begin
  var PathString := GetPathString(Path, '');
  var FS := TFormatSettings.Invariant;
  if (PathString <> '') and TryStrToFloat(PathString, Result, FS) then
    Exit;

  Result := Default;
end;

{ TJsonReader }

class function TJsonReader.Parse(const JsonText: string): TJsonReader;
begin
  Result.FRoot := TJSONObject.ParseJSONValue(JsonText);
end;

class operator TJsonReader.Initialize(out Dest: TJsonReader);
begin
  Dest.FRoot := nil;
end;

class operator TJsonReader.Finalize(var Dest: TJsonReader);
begin
  Dest.FRoot.Free;
  Dest.FRoot := nil;
end;

function TJsonReader.Format(const Path: string; const Format: Integer): string;
begin
  if FRoot = nil then
    Exit('');
end;

function TJsonReader.IsValid: Boolean;
begin
  Result := FRoot <> nil;
end;

function TJsonReader.Value(const Path: string): TJSONValue;
begin
  if FRoot = nil then
    Exit(nil);
  Result := FRoot.GetPathValue(Path);
end;

function TJsonReader.AsString(const Path, Default: string): string;
begin
  if FRoot = nil then
    Exit(Default);
  Result := FRoot.GetPathString(Path, Default);
end;

function TJsonReader.AsInteger(const Path: string; const Default: Integer): Integer;
begin
  if FRoot = nil then Exit(Default);
  Result := FRoot.GetPathInteger(Path, Default);
end;

function TJsonReader.AsBoolean(const Path: string; const Default: Boolean): Boolean;
begin
  if FRoot = nil then Exit(Default);
  Result := FRoot.GetPathBoolean(Path, Default);
end;

function TJsonReader.AsDouble(const Path: string; const Default: Double): Double;
begin
  if FRoot = nil then Exit(Default);
  Result := FRoot.GetPathDouble(Path, Default);
end;

function TJsonReader.ObjectText(const Path, Default: string): string;
begin
  if FRoot = nil then Exit(Default);
  Result := FRoot.GetPathObjectText(Path, Default);
end;

function TJsonReader.ArrayText(const Path, Default: string): string;
begin
  if FRoot = nil then Exit(Default);
  Result := FRoot.GetPathArrayText(Path, Default);
end;

function TJsonReader.Count(const Path: string; const Default: Integer): Integer;
begin
  if FRoot = nil then Exit(Default);
  Result := FRoot.GetPathCount(Path, Default);
end;

end.

