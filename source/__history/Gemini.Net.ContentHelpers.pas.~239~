unit Gemini.Net.ContentHelpers;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes;

type
  TNetContentHelper = record
  private
    /// <summary>
    /// Retrieves the MIME type of a remote resource using an HTTP HEAD request.
    /// </summary>
    class function GetMimeTypeFromURI(const Uri: string): string; static;

    /// <summary>
    /// Resolves the MIME type of a local file based on its extension.
    /// </summary>
    class function ResolveMimeType(const FilePath: string): string; static;

    /// <summary>
    /// Removes all CR and LF characters from a string.
    /// </summary>
    class function StripCrlf(const Value: string): string; static;

    /// <summary>
    /// Normalizes a Base64 string by optionally removing line breaks.
    /// </summary>
    class function NormalizeBase64(const Value: string; const CrLfDeletion: Boolean): string; static;

  public
    /// <summary>
    /// Encodes a file into a Base64 string.
    /// </summary>
    class function EncodeBase64(FilePath: string; const CrLfDeletion: Boolean = False) : string; overload; static;

    /// <summary>
    /// Encodes a text string into Base64 using the specified encoding.
    /// </summary>
    class function EncodeBase64(const Text: string; Encoding: TEncoding;
      const CrLfDeletion: Boolean = True): string; overload; static;

    /// <summary>
    /// Encodes a stream into a Base64 string.
    /// </summary>
    class function EncodeBase64(const Value: TStream; const CrLfDeletion: Boolean = True): string; overload; static;

    /// <summary>
    /// Encodes a byte array into a Base64 string.
    /// </summary>
    class function EncodeBase64(const ABytes: TBytes; const CrLfDeletion: Boolean = True): string; overload; static;

    /// <summary>
    /// Decodes a Base64 string into a text string using the specified encoding.
    /// </summary>
    class function DecodeBase64ToString(const Base64: string;
      Encoding: TEncoding = nil): string; static;

    /// <summary>
    /// Decodes a Base64 string into a stream.
    /// </summary>
    class function DecodeBase64ToStream(const Base64: string;
      const AStream: TStream): Boolean; static;

    /// <summary>
    /// Decodes a Base64 string into a byte array.
    /// </summary>
    class function DecodeBase64ToBytes(const Base64: string): TBytes; static;

    /// <summary>
    /// Decodes a Base64 string and writes the result to a file.
    /// </summary>
    class function DecodeBase64ToFile(const Base64: string;
      const FilePath: string): Boolean; static;

    /// <summary>
    /// Attempts to decode a Base64 string into a text string.
    /// </summary>
    class function TryDecodeBase64ToString(const Base64: string;
      out Value: string; Encoding: TEncoding = nil): Boolean; static;

    /// <summary>
    /// Attempts to decode a Base64 string into a stream.
    /// </summary>
    class function TryDecodeBase64ToStream(const Base64: string;
      AStream: TStream): Boolean; static;

    /// <summary>
    /// Attempts to decode a Base64 string into a byte array.
    /// </summary>
    class function TryDecodeBase64ToBytes(const Base64: string;
      out Bytes: TBytes): Boolean; static;

    /// <summary>
    /// Attempts to decode a Base64 string and write the result to a file.
    /// </summary>
    class function TryDecodeBase64ToFile(const Base64: string;
      const FilePath: string): Boolean; static;

    {--- RFC 2397 }

    class function EncodeDataUri(const Text: string; const MimeType: string;
      Encoding: TEncoding = nil; const CrLfDeletion: Boolean = True): string; overload; static;
    class function EncodeDataUri(const ABytes: TBytes; const MimeType: string;
      const CrLfDeletion: Boolean = True): string; overload; static;
    class function EncodeDataUri(const Value: TStream; const MimeType: string;
      const CrLfDeletion: Boolean = True): string; overload; static;
    class function EncodeDataUri(const FilePath: string; const MimeType: string;
      const CrLfDeletion: Boolean = False): string; overload; static;

    class function TryDecodeDataUriToBytes(const DataUri: string;
      out Bytes: TBytes; out MimeType: string): Boolean; static;
    class function TryDecodeDataUriToStream(const DataUri: string;
      AStream: TStream; out MimeType: string): Boolean; static;
    class function TryDecodeDataUriToString(const DataUri: string;
      out Value: string; out MimeType: string; Encoding: TEncoding): Boolean; static;
    class function TryDecodeDataUriToFile(const DataUri: string;
      const FilePath: string; out MimeType: string): Boolean; static;

    class function IsUri(const FilePath: string): Boolean; static;
    class function GetMimeType(const FileLocation: string): string; static;
    class function GetFileSize(const FilePath: string): Int64; static;

    class function TryToBytes(const FileLocation: string;
      out Bytes: TBytes; out MimeType: string): Boolean; static;
    class function TryToDataUri(const FileLocation: string;
      out DataUri: string; out MimeType: string): Boolean; static;
    class function TryUrlToStream(const AUrl: string; AStream: TStream; out AContentType: string): Boolean; static;
    class function TryUrlToBytes(const AUrl: string;
      out Bytes: TBytes; out ContentType: string): Boolean; static;
  end;

implementation

uses
  System.Net.Mime, System.NetEncoding, System.Net.HttpClient, System.Net.URLClient,
  System.IOUtils;

type
  TDataUriDecoded = record
  private
    FMimeType: string;
    FCharset: string;
    FIsBase64: Boolean;
    FPayload: string;
    FBytes: TBytes;

    { --- Defaults RFC2397 (when mediatype is omitted) --- }
    class function DefaultMimeType: string; static; inline;
    class function DefaultCharset: string; static; inline;

    { --- Small helpers --- }
    class function StripCrlf(const Value: string): string; static; inline;
    class function StartsWithDataPrefix(const Value: string): Boolean; static; inline;

    { --- Parsing --- }
    class function SplitHeaderPayload(const DataUri: string;
      out Header: string; out Payload: string): Boolean; static;

    class procedure ParseHeader(const Header: string;
      out MimeType: string; out Charset: string; out IsBase64: Boolean); static;

    class function RemoveBase64Token(const Header: string;
      out HeaderNoBase64: string): Boolean; static;

    class function ExtractCharset(const HeaderNoBase64: string): string; static;

    class function GetEncodingFromCharset(const Charset: string;
      out Encoding: TEncoding): Boolean; static;

    procedure Clear;
  public
    property MimeType: string read FMimeType;
    property Charset: string read FCharset;
    property IsBase64: Boolean read FIsBase64;
    property Bytes: TBytes read FBytes;

    class function TryDecode(const DataUri: string; out Decoder: TDataUriDecoded): Boolean; static;
  end;

{ TDataUriDecoded }

class function TDataUriDecoded.DefaultMimeType: string;
begin
  Result := 'text/plain';
end;

class function TDataUriDecoded.DefaultCharset: string;
begin
  Result := 'US-ASCII';
end;

procedure TDataUriDecoded.Clear;
begin
  FMimeType := EmptyStr;
  FCharset := EmptyStr;
  FIsBase64 := False;
  FPayload := EmptyStr;
  FBytes := nil;
end;

class function TDataUriDecoded.StripCrlf(const Value: string): string;
begin
  if (Value.IndexOf(#10) < 0) and (Value.IndexOf(#13) < 0) then
    Exit(Value);
  Result := Value.Replace(#13, '').Replace(#10, '');
end;

class function TDataUriDecoded.StartsWithDataPrefix(const Value: string): Boolean;
begin
  Result := (Length(Value) >= 5) and SameText(Value.Substring(0, 5), 'data:');
end;

class function TDataUriDecoded.SplitHeaderPayload(const DataUri: string;
  out Header: string; out Payload: string): Boolean;
begin
  Header := EmptyStr;
  Payload := EmptyStr;

  var Buffer := DataUri.Trim;
  if not StartsWithDataPrefix(Buffer) then
    Exit(False);

  var CommaPos := Buffer.IndexOf(',');
  if CommaPos < 0 then
    Exit(False);

  {--- after "data" }
  Header := Buffer.Substring(5, CommaPos - 5).Trim;
  Payload := Buffer.Substring(CommaPos + 1);
  Result := True;
end;

class function TDataUriDecoded.RemoveBase64Token(const Header: string;
  out HeaderNoBase64: string): Boolean;
var
  OutParts: TArray<string>;
begin
  Result := False;
  HeaderNoBase64 := Header.Trim;

  if HeaderNoBase64.IsEmpty then
    Exit(False);

  var Parts := HeaderNoBase64.Split([';']);
  SetLength(OutParts, 0);

  for var i := 0 to High(Parts) do
    begin
      var P := Parts[i].Trim;
      if P.IsEmpty then
        Continue;

      if SameText(P, 'base64') then
        begin
          Result := True;
          Continue;
        end;

      OutParts := OutParts + [P];
    end;

  HeaderNoBase64 := string.Join(';', OutParts).Trim;
end;

class function TDataUriDecoded.ExtractCharset(const HeaderNoBase64: string): string;
begin
  Result := EmptyStr;

  var Lower := HeaderNoBase64.ToLower;
  var Index := Lower.IndexOf('charset=');
  if Index < 0 then
    Exit('');

  var Tail := HeaderNoBase64.Substring(Index + Length('charset=')).Trim;
  var SemiPos := Tail.IndexOf(';');
  if SemiPos >= 0 then
    Tail := Tail.Substring(0, SemiPos).Trim;

  Result := Tail.Trim(['"', '''']);
end;

class procedure TDataUriDecoded.ParseHeader(const Header: string;
  out MimeType: string; out Charset: string; out IsBase64: Boolean);
begin
  if Header.Trim.IsEmpty then
    begin
      MimeType := DefaultMimeType;
      Charset := DefaultCharset;
      IsBase64 := False;
      Exit;
    end;

  var LocalHeader := Header.Trim;

  var HadBase64 := RemoveBase64Token(LocalHeader, LocalHeader);
  IsBase64 := HadBase64;

  {--- Determine mimetype: if first segment looks like "type/subtype" }
  var FirstSegment := LocalHeader;
  var SemiPos := FirstSegment.IndexOf(';');
  if SemiPos >= 0 then
    FirstSegment := FirstSegment.Substring(0, SemiPos).Trim;

  if not FirstSegment.IsEmpty and (FirstSegment.IndexOf('/') > 0) then
    MimeType := FirstSegment
  else
    MimeType := DefaultMimeType;

  Charset := ExtractCharset(LocalHeader);
  if Charset.IsEmpty then
    Charset := DefaultCharset;
end;

class function TDataUriDecoded.GetEncodingFromCharset(const Charset: string;
  out Encoding: TEncoding): Boolean;
begin
  Encoding := nil;
  try
    Encoding := TEncoding.GetEncoding(Charset);
    Result := Encoding <> nil;
  except
    Encoding := nil;
    Result := False;
  end;
end;

class function TDataUriDecoded.TryDecode(const DataUri: string;
  out Decoder: TDataUriDecoded): Boolean;
var
  Header: string;
  Payload: string;
  Encoding: TEncoding;
begin
  Decoder.Clear;

  try
    if not SplitHeaderPayload(DataUri, Header, Payload) then
      Exit(False);

    ParseHeader(Header, Decoder.FMimeType, Decoder.FCharset, Decoder.FIsBase64);
    Decoder.FPayload := Payload;

    if Decoder.FIsBase64 then
      begin
        var Clean := StripCrlf(Decoder.FPayload);
        Decoder.FBytes := TNetEncoding.Base64.DecodeStringToBytes(Clean);
        Exit(True);
      end;

    {--- Non-base64: percent-decoding }
    var DecodedText := TNetEncoding.URL.Decode(Decoder.FPayload);

    if not GetEncodingFromCharset(Decoder.FCharset, Encoding) then
      Encoding := TEncoding.ASCII;

    Decoder.FBytes := Encoding.GetBytes(DecodedText);
    Result := True;
  except
    Decoder.Clear;
    Result := False;
  end;
end;

{ TNetContentHelper  }

class function TNetContentHelper.DecodeBase64ToBytes(
  const Base64: string): TBytes;
begin
  var Buffer := StripCrlf(Base64);

  Result := TNetEncoding.Base64.DecodeStringToBytes(Buffer);
end;

class function TNetContentHelper.DecodeBase64ToFile(const Base64,
  FilePath: string): Boolean;
begin
  Result := False;

  if FilePath.Trim.IsEmpty then
    Exit;

  try
    var Bytes := DecodeBase64ToBytes(Base64);
    TFile.WriteAllBytes(FilePath, Bytes);
    Result := True;
  except
    Result := False;
  end;
end;

class function TNetContentHelper.DecodeBase64ToStream(const Base64: string;
  const AStream: TStream): Boolean;
begin
  Result := False;

  if AStream = nil then
    Exit;

  try
    AStream.Size := 0;
    var Bytes := DecodeBase64ToBytes(Base64);

    if Length(Bytes) > 0 then
      AStream.WriteBuffer(Bytes[0], Length(Bytes));

    AStream.Position := 0;
    Result := True;
  except
    AStream.Size := 0;
    AStream.Position := 0;
    Result := False;
  end;
end;

class function TNetContentHelper.DecodeBase64ToString(const Base64: string;
  Encoding: TEncoding): string;
begin
  if Encoding = nil then
    Encoding := TEncoding.UTF8;

  var Bytes := DecodeBase64ToBytes(Base64);
  Result := Encoding.GetString(Bytes);
end;

class function TNetContentHelper.EncodeBase64(const ABytes: TBytes;
  const CrLfDeletion: Boolean): string;
begin
  Result := TNetEncoding.Base64.EncodeBytesToString(ABytes);

  Result := NormalizeBase64(Result, CrLfDeletion);
end;

class function TNetContentHelper.EncodeBase64(const Text: string;
  Encoding: TEncoding;
  const CrLfDeletion: Boolean): string;
begin
  if Encoding = nil then
    Encoding := TEncoding.UTF8;

  Result := EncodeBase64(Encoding.GetBytes(Text), CrLfDeletion);
end;

class function TNetContentHelper.EncodeBase64(const Value: TStream;
  const CrLfDeletion: Boolean): string;
var
  Bytes: TBytes;
  SavedPos: Int64;
begin
  if Value = nil then
    Exit('');

  SavedPos := Value.Position;
  try
    Value.Position := 0;

    var Length := Value.Size - Value.Position;
    if Length <= 0 then
      Exit('');

    SetLength(Bytes, Length);
    Value.ReadBuffer(Bytes[0], Length);

    Result := EncodeBase64(Bytes, CrLfDeletion);
  finally
    Value.Position := SavedPos;
  end;
end;

class function TNetContentHelper.EncodeBase64(FilePath: string;
  const CrLfDeletion: Boolean): string;
begin
  if not FileExists(FilePath) then
    raise Exception.CreateFmt('File not found : %s', [FilePath]);

  var Stream := TMemoryStream.Create;
  var StreamOutput := TStringStream.Create('', TEncoding.UTF8);

  try
    Stream.LoadFromFile(FilePath);
    Stream.Position := 0;

    {$IF RTLVersion >= 35.0}
    TNetEncoding.Base64String.Encode(Stream, StreamOutput);
    {$ELSE}
    TNetEncoding.Base64.Encode(Stream, StreamOutput);
    {$ENDIF}

    Result := NormalizeBase64(StreamOutput.DataString, CrLfDeletion);

  finally
    Stream.Free;
    StreamOutput.Free;
  end;
end;

class function TNetContentHelper.EncodeDataUri(const Value: TStream;
  const MimeType: string; const CrLfDeletion: Boolean): string;
begin
  if MimeType.Trim.IsEmpty then
    raise Exception.Create('MimeType is empty');

  Result := 'data:' + MimeType.Trim + ';base64,' + EncodeBase64(Value, CrLfDeletion);
end;

class function TNetContentHelper.EncodeDataUri(const ABytes: TBytes;
  const MimeType: string; const CrLfDeletion: Boolean): string;
begin
  if MimeType.Trim.IsEmpty then
    raise Exception.Create('MimeType is empty');

  Result := 'data:' + MimeType.Trim + ';base64,' + EncodeBase64(ABytes, CrLfDeletion);
end;

class function TNetContentHelper.EncodeDataUri(const Text, MimeType: string;
  Encoding: TEncoding; const CrLfDeletion: Boolean): string;
begin
  if MimeType.Trim.IsEmpty then
    raise Exception.Create('MimeType is empty');

  if Encoding = nil then
    Encoding := TEncoding.UTF8;

  Result := 'data:' + MimeType.Trim + ';base64,' + EncodeBase64(Text, Encoding, CrLfDeletion);
end;

class function TNetContentHelper.EncodeDataUri(const FilePath, MimeType: string;
  const CrLfDeletion: Boolean): string;
begin
  if MimeType.Trim.IsEmpty then
    raise Exception.Create('MimeType is empty');

  Result := 'data:' + MimeType.Trim + ';base64,' + EncodeBase64(FilePath, CrLfDeletion);
end;

class function TNetContentHelper.GetFileSize(const FilePath: string): Int64;
begin
  Result := TFile.GetSize(FilePath);
end;

class function TNetContentHelper.GetMimeType(const FileLocation: string): string;
begin
  if IsUri(FileLocation) then
    Result := GetMimeTypeFromURI(FileLocation)
  else
    Result := ResolveMimeType(FileLocation);
end;

class function TNetContentHelper.GetMimeTypeFromURI(const Uri: string): string;
begin
  Result := EmptyStr;
  var Client := THTTPClient.Create;
  try
    try
      var Response := Client.Head(Uri);
      if Response <> nil then
        Result := Response.HeaderValue['Content-Type'];
    except
      Result := EmptyStr;
    end;
  finally
    Client.Free;
  end;
end;

class function TNetContentHelper.IsUri(const FilePath: string): Boolean;
begin
  var Lower := FilePath.ToLower;
  Result := Lower.StartsWith('http://') or
            Lower.StartsWith('https://');
end;

class function TNetContentHelper.NormalizeBase64(const Value: string;
  const CrLfDeletion: Boolean): string;
begin
  if CrLfDeletion then
    Exit(StripCrlf(Value));

  Result := Value;
end;

class function TNetContentHelper.ResolveMimeType(
  const FilePath: string): string;
var
  LKind: TMimeTypes.TKind;
begin
  if not FileExists(FilePath) then
    raise Exception.CreateFmt('File not found: %s', [FilePath]);

  TMimeTypes.Default.GetFileInfo(FilePath, Result, LKind);
end;

class function TNetContentHelper.StripCrlf(const Value: string): string;
begin
  Result := Value.Replace(#13, '').Replace(#10, '');
end;

class function TNetContentHelper.TryDecodeBase64ToBytes(const Base64: string;
  out Bytes: TBytes): Boolean;
begin
  Bytes := nil;

  try
    var Clean := StripCrlf(Base64);
    Bytes := TNetEncoding.Base64.DecodeStringToBytes(Clean);
    Result := True;
  except
    Bytes := nil;
    Result := False;
  end;
end;

class function TNetContentHelper.TryDecodeBase64ToFile(const Base64,
  FilePath: string): Boolean;
var
  Bytes: TBytes;
begin
  Result := False;

  if FilePath.Trim.IsEmpty then
    Exit;

  if not TryDecodeBase64ToBytes(Base64, Bytes) then
    Exit;

  try
    TFile.WriteAllBytes(FilePath, Bytes);
    Result := True;
  except
    Result := False;
  end;
end;

class function TNetContentHelper.TryDecodeBase64ToStream(const Base64: string;
  AStream: TStream): Boolean;
var
  Bytes: TBytes;
begin
  Result := False;

  if AStream = nil then
    Exit;

  AStream.Size := 0;
  AStream.Position := 0;

  if not TryDecodeBase64ToBytes(Base64, Bytes) then
    Exit;

  try
    if Length(Bytes) > 0 then
      AStream.WriteBuffer(Bytes[0], Length(Bytes));

    AStream.Position := 0;
    Result := True;
  except
    AStream.Size := 0;
    AStream.Position := 0;
    Result := False;
  end;
end;

class function TNetContentHelper.TryDecodeBase64ToString(const Base64: string;
  out Value: string; Encoding: TEncoding): Boolean;
var
  Bytes: TBytes;
begin
  Result := False;
  Value := EmptyStr;

  if Encoding = nil then
    Encoding := TEncoding.UTF8;

  if not TryDecodeBase64ToBytes(Base64, Bytes) then
    Exit;

  try
    Value := Encoding.GetString(Bytes);
    Result := True;
  except
    Value := EmptyStr;
    Result := False;
  end;
end;

class function TNetContentHelper.TryDecodeDataUriToBytes(const DataUri: string;
  out Bytes: TBytes; out MimeType: string): Boolean;
var
  Decoder: TDataUriDecoded;
begin
  Bytes := nil;
  MimeType := EmptyStr;

  Result := TDataUriDecoded.TryDecode(DataUri, Decoder);
  if Result then
    begin
      Bytes := Decoder.Bytes;
      MimeType := Decoder.MimeType;
    end;
end;

class function TNetContentHelper.TryDecodeDataUriToFile(
  const DataUri, FilePath: string; out MimeType: string): Boolean;
var
  Decoder: TDataUriDecoded;
begin
  MimeType := EmptyStr;

  if FilePath.Trim.IsEmpty then
    Exit(False);

  Result := TDataUriDecoded.TryDecode(DataUri, Decoder);
  if not Result then
    Exit(False);

  try
    TFile.WriteAllBytes(FilePath, Decoder.Bytes);
    MimeType := Decoder.MimeType;
    Result := True;
  except
    MimeType := EmptyStr;
    Result := False;
  end;
end;

class function TNetContentHelper.TryDecodeDataUriToStream(const DataUri: string;
  AStream: TStream; out MimeType: string): Boolean;
var
  Decoder: TDataUriDecoded;
begin
  MimeType := EmptyStr;

  if AStream = nil then
    Exit(False);

  AStream.Size := 0;
  AStream.Position := 0;

  Result := TDataUriDecoded.TryDecode(DataUri, Decoder);
  if not Result then
    Exit(False);

  try
    if Length(Decoder.Bytes) > 0 then
      AStream.WriteBuffer(Decoder.Bytes[0], Length(Decoder.Bytes));
    AStream.Position := 0;
    MimeType := Decoder.MimeType;
    Result := True;
  except
    AStream.Size := 0;
    AStream.Position := 0;
    MimeType := EmptyStr;
    Result := False;
  end;
end;

class function TNetContentHelper.TryDecodeDataUriToString(const DataUri: string;
  out Value, MimeType: string; Encoding: TEncoding): Boolean;
var
  Decoder: TDataUriDecoded;
  LocalEncoding: TEncoding;
begin
  Value := EmptyStr;
  MimeType := EmptyStr;

  {--- Encoding = fallback if unknown/invalid charset }
  if Encoding = nil then
    Encoding := TEncoding.UTF8;

  Result := TDataUriDecoded.TryDecode(DataUri, Decoder);
  if not Result then
    Exit(False);

  {--- Priority Data URI Charset }
  LocalEncoding := nil;
  try
    if not Decoder.Charset.Trim.IsEmpty then
      LocalEncoding := TEncoding.GetEncoding(Decoder.Charset);
  except
    LocalEncoding := nil;
  end;

  if LocalEncoding = nil then
    LocalEncoding := Encoding;

  try
    Value := LocalEncoding.GetString(Decoder.Bytes);
    MimeType := Decoder.MimeType;
    Result := True;
  except
    Value := EmptyStr;
    MimeType := EmptyStr;
    Result := False;
  end;
end;

class function TNetContentHelper.TryToBytes(const FileLocation: string;
  out Bytes: TBytes; out MimeType: string): Boolean;
begin
  Bytes := nil;
  MimeType := '';
  var Location := FileLocation.Trim;
  if Location.IsEmpty then
    Exit(False);

  if (Location.Length >= 5) and SameText(Location.Substring(0, 5), 'data:') then
    Exit(TryDecodeDataUriToBytes(Location, Bytes, MimeType));

  if IsUri(Location) then
    begin
      var Stream := TMemoryStream.Create;
      try
        if not TryUrlToStream(Location, Stream, MimeType) then
          Exit(False);

        SetLength(Bytes, Stream.Size);
        if Stream.Size > 0 then
          begin
            Stream.Position := 0;
            Stream.ReadBuffer(Bytes[0], Stream.Size);
          end;

        Exit(True);
      finally
        Stream.Free;
      end;
    end;

  if not TFile.Exists(Location) then
    Exit(False);

  Bytes := TFile.ReadAllBytes(Location);
  try
    MimeType := ResolveMimeType(Location);
  except
    MimeType := '';
  end;

  Result := True;
end;

class function TNetContentHelper.TryToDataUri(const FileLocation: string;
  out DataUri, MimeType: string): Boolean;
begin
  DataUri := EmptyStr;
  MimeType := EmptyStr;

  var Location := FileLocation.Trim;
  if Location.IsEmpty then
    Exit(False);

  if (Location.Length >= 5) and SameText(Location.Substring(0, 5), 'data:') then
    begin
      {--- Already a data URI: validate + extract mimetype }
      var Bytes: TBytes;
      if not TryDecodeDataUriToBytes(Location, Bytes, MimeType) then
        Exit(False);

      DataUri := Location;
      Exit(True);
    end;

  if IsUri(Location) then
  begin
    var Stream := TMemoryStream.Create;
    try
      if not TryUrlToStream(Location, Stream, MimeType) then
        Exit(False);

      DataUri := EncodeDataUri(Stream, MimeType, True);
      Exit(True);
    finally
      Stream.Free;
    end;
  end;

  if not TFile.Exists(Location) then
    Exit(False);

  try
    MimeType := ResolveMimeType(Location);
  except
    MimeType := EmptyStr;
  end;

  if MimeType.Trim.IsEmpty then
    Exit(False);

  DataUri := EncodeDataUri(Location, MimeType, False);
  Result := True;
end;

class function TNetContentHelper.TryUrlToBytes(const AUrl: string;
  out Bytes: TBytes; out ContentType: string): Boolean;
begin
  Bytes := nil;
  ContentType := EmptyStr;

  var Url := AUrl.Trim;
  if Url.IsEmpty then
    Exit(False);

  var Stream := TMemoryStream.Create;
  try
    Result := TryUrlToStream(Url, Stream, ContentType);
    if not Result then
      Exit(False);

    SetLength(Bytes, Stream.Size);
    if Stream.Size > 0 then
      begin
        Stream.Position := 0;
        Stream.ReadBuffer(Bytes[0], Stream.Size);
      end;

    Result := True;
  finally
    Stream.Free;
  end;
end;

class function TNetContentHelper.TryUrlToStream(const AUrl: string;
  AStream: TStream; out AContentType: string): Boolean;
begin
  AContentType := '';

  if AStream = nil then
    Exit(False);

  AStream.Size := 0;
  AStream.Position := 0;

  var Client := THTTPClient.Create;
  try

    try
      var Response := Client.Get(AUrl, AStream);

      Result := (Response <> nil) and (Response.StatusCode div 100 = 2);
      if Result then
          AContentType := Response.HeaderValue['Content-Type']
      else
        AStream.Size := 0;

    except
      AStream.Size := 0;
      Result := False;
    end;

  finally
    AStream.Position := 0;
    Client.Free;
  end;
end;

end.
