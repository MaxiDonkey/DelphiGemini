unit Gemini.API.Utils;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, Gemini.API.JSONShield;

{$REGION 'Dev note'}
(*
   --- NOTE ---
    Each entry in this array corresponds to a  JSON field that is temporarily
    treated as  a string  during  parsing. In order  for these  fields  to be
    correctly restored as JSON objects upon re-marshalling, each unique field
    listed here must have a dedicated interceptor  that transforms the string
    back into a well-formed JSON object.

    Example: TMetadataInterceptor

      procedure TMetadataInterceptor.StringReverter(Data: TObject; Field,
        Arg: string);
      begin
        Arg := Format('{%s}', [Trim(Arg.Replace('`', '"').Replace(#10, ''))]);
        while Arg.Contains(', ') do Arg := Arg.Replace(', ', ',');
        RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, Arg.Replace(',', ', '));
      end;
*)
{$ENDREGION}

type
  /// <summary>
  /// Provides a mechanism for converting or transforming specific JSON fields in a string
  /// before deserialization. Typically used to handle scenarios where certain fields
  /// contain complex or nested structures that need to be converted into valid JSON.
  /// </summary>
  /// <remarks>
  /// <para>
  /// Implementations of this interface can adjust the JSON string prior to the deserialization
  /// process to address inconsistencies, remove or replace invalid characters, or convert
  /// problematic JSON fields into formats that a JSON deserializer can handle properly.
  /// </para>
  /// <para>
  /// For example, the implementation may detect fields named "metadata" and convert their
  /// content from a raw, non-standard structure into a valid JSON string by replacing certain
  /// delimiters or escape characters.
  /// </para>
  /// </remarks>
  ICustomFieldsPrepare = interface
    ['{B09FEEBA-747E-4E6E-B916-ECBEC2467415}']
    /// <summary>
    /// Converts or transforms specified fields in the provided JSON string to ensure
    /// deserialization compatibility.
    /// </summary>
    /// <param name="Value">
    /// The raw JSON string containing fields that may require transformation.
    /// </param>
    /// <returns>
    /// A revised JSON string after applying the necessary field conversions or
    /// transformations.
    /// </returns>
    function Convert(const Value: string): string; overload;
  end;

  /// <summary>
  /// Implements the <c>ICustomFieldsPrepare</c> interface to transform specific JSON fields
  /// before deserialization. The class applies rules for handling particular fields that may
  /// contain nested objects or invalid characters, ensuring the resulting JSON is valid and
  /// ready for further processing.
  /// </summary>
  /// <remarks>
  /// <para>
  /// This class is most commonly used to modify JSON fields such as "metadata" that might
  /// otherwise cause errors during deserialization. It replaces problematic delimiters and
  /// characters (like quotation marks or braces) within specified field blocks, enabling
  /// compliant JSON output.
  /// </para>
  /// <para>
  /// <c>TDeserializationPrepare</c> scans the JSON string for patterns and adjusts the content
  /// accordingly, preventing typical parsing exceptions arising from malformed or unexpected
  /// inline structures.
  /// </para>
  /// </remarks>
  TDeserializationPrepare = class(TInterfacedObject, ICustomFieldsPrepare)
  public
    /// <summary>
    /// Scans and modifies the input JSON string to replace fields that contain nested
    /// objects or invalid characters, ensuring the JSON is suitable for deserialization.
    /// </summary>
    /// <param name="Value">
    /// The original JSON string needing transformation.
    /// </param>
    /// <returns>
    /// A revised JSON string after applying all necessary field modifications.
    /// </returns>
    /// <remarks>
    /// <para>
    /// The conversion logic is determined by which fields or patterns are defined
    /// within the implementation. Currently, the class targets fields labeled
    /// <c>"metadata"</c>, converting them from non-standard structures into proper
    /// JSON-friendly strings.
    /// </para>
    /// </remarks>
    function Convert(const Value: string): string;

    /// <summary>
    /// Factory method for creating an instance of the <c>TDeserializationPrepare</c> class.
    /// Returns an interface reference to <c>ICustomFieldsPrepare</c>.
    /// </summary>
    /// <returns>
    /// A newly constructed <c>TDeserializationPrepare</c> object as <c>ICustomFieldsPrepare</c>.
    /// </returns>
    /// <remarks>
    /// This method hides the constructor, enforcing interface-based usage.
    /// </remarks>
    class function CreateInstance: ICustomFieldsPrepare;
  end;

implementation

{ TDeserializationPrepare }

class function TDeserializationPrepare.CreateInstance: ICustomFieldsPrepare;
begin
  Result := TDeserializationPrepare.Create;
end;

function TDeserializationPrepare.Convert(const Value: string): string;
begin
  Result := TJsonPolyShield.Prepare(Value, ['args','response','metadata','partMetadata','arguments','result']);
end;

end.
