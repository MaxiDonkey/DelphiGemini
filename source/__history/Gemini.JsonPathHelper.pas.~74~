//unit Gemini.JsonPathHelper;
//
//interface
//
//uses
//  System.SysUtils, System.JSON, System.Generics.Collections;
//
//type
//  TJSONValueHelper = class helper for TJSONValue
//  public
//    function GetPathValue(const Path: string): TJSONValue;
//    function GetPathString(const Path: string; const Default: string = ''): string;
//    function GetPathInteger(const Path: string; const Default: Integer = 0): Integer;
//    function GetPathBoolean(const Path: string; const Default: Boolean = False): Boolean;
//    function GetPathDouble(const Path: string; const Default: Double = 0.0): Double;
//    function GetPathObjectText(const Path: string; const Default: string = ''): string;
//    function GetPathArrayText(const Path: string; const Default: string = ''): string;
//    function GetPathCount(const Path: string; const Default: Integer = 0): Integer;
//  end;
//
//  TJsonQuery = record
//  private
//    FRoot: TJSONValue;
//  public
//    class function Parse(const JsonText: string): TJsonQuery; static;
//
//    class operator Initialize(out Dest: TJsonQuery);
//    class operator Finalize(var Dest: TJsonQuery);
//
//    function IsValid: Boolean; inline;
//
//    function Value(const Path: string): TJSONValue; inline;
//
//    function AsString(const Path: string; const Default: string = ''): string;
//    function AsInteger(const Path: string; const Default: Integer = 0): Integer;
//    function AsBoolean(const Path: string; const Default: Boolean = False): Boolean;
//    function AsDouble(const Path: string; const Default: Double = 0.0): Double;
//
//    function ObjectText(const Path: string; const Default: string = ''): string;
//    function ArrayText(const Path: string; const Default: string = ''): string;
//    function Count(const Path: string; const Default: Integer = 0): Integer;
//  end;
//
//implementation
//
//function NextToken(const S: string; var Index: Integer): string;
//begin
//  while (Index <= S.Length) and (S[Index] = '.') do
//    Inc(Index);
//
//  var Start := Index;
//
//  while (Index <= S.Length) and (S[Index] <> '.') do
//    Inc(Index);
//
//  Result := S.Substring(Start - 1, Index - Start);
//end;
//
//function ParseArrayIndex(const Token: string; out Name: string; out HasIndex: Boolean; out Index: Integer): Boolean;
//begin
//  Name := Token;
//  HasIndex := False;
//  Index := -1;
//
//  var Left := Token.IndexOf('[');
//  if Left < 0 then
//    Exit(True);
//
//  var Right := Token.IndexOf(']', Left + 1);
//  if Right < 0 then
//    Exit(False);
//
//  Name := Token.Substring(0, Left);
//  var IndexStr := Token.Substring(Left + 1, Right - (Left + 1));
//  HasIndex := True;
//  Result := TryStrToInt(IndexStr, Index) and (Index >= 0);
//end;
//
//function TJSONValueHelper.GetPathValue(const Path: string): TJSONValue;
//var
//  Index: Integer;
//  Name: string;
//  HasIndex: Boolean;
//begin
//  Result := nil;
//  var Current := Self;
//  if (Current = nil) or Path.IsEmpty then
//    Exit;
//
//  var I := 1;
//  while I <= Path.Length do
//    begin
//      var Token := NextToken(Path, I);
//      if Token.IsEmpty then
//        Break;
//
//      if not ParseArrayIndex(Token, Name, HasIndex, Index) then
//        Exit(nil);
//
//      if not Name.IsEmpty then
//        begin
//          if not (Current is TJSONObject) then
//            Exit(nil);
//
//          var JSONObjet := TJSONObject(Current);
//          Current := JSONObjet.GetValue(Name);
//          if Current = nil then
//            Exit(nil);
//        end;
//
//      if HasIndex then
//        begin
//          if not (Current is TJSONArray) then
//            Exit(nil);
//
//          var JSONArray := TJSONArray(Current);
//          if (Index < 0) or (Index >= JSONArray.Count) then
//            Exit(nil);
//
//          Current := JSONArray.Items[Index];
//          if Current = nil then
//            Exit(nil);
//        end;
//  end;
//
//  Result := Current;
//end;
//
//function TJSONValueHelper.GetPathString(const Path: string; const Default: string): string;
//begin
//  var JSONValue := GetPathValue(Path);
//  if JSONValue = nil then
//    Exit(Default);
//
//  if JSONValue is TJSONString then
//    Exit(TJSONString(JSONValue).Value);
//
//  if JSONValue is TJSONNumber then
//    Exit(TJSONNumber(JSONValue).ToString);
//
//  Result := JSONValue.Value;
//  if Result.IsEmpty then
//    Result := JSONValue.ToString;
//end;
//
//function TJSONValueHelper.GetPathInteger(const Path: string; const Default: Integer): Integer;
//begin
//  var PathString := GetPathString(Path, '');
//  if not PathString.IsEmpty and TryStrToInt(PathString, Result) then
//    Exit;
//
//  Result := Default;
//end;
//
//function TJSONValueHelper.GetPathArrayText(const Path, Default: string): string;
//begin
//  var JSONValue := GetPathValue(Path);
//  if (JSONValue <> nil) and (JSONValue is TJSONArray) then
//    Exit(TJSONArray(JSONValue).ToJSON);
//
//  Result := Default;
//end;
//
//function TJSONValueHelper.GetPathObjectText(const Path, Default: string): string;
//begin
//  var JSONValue := GetPathValue(Path);
//  if (JSONValue <> nil) and (JSONValue is TJSONObject) then
//    Exit(TJSONObject(JSONValue).ToJSON);
//
//  Result := Default;
//end;
//
//function TJSONValueHelper.GetPathBoolean(const Path: string; const Default: Boolean): Boolean;
//begin
//  var PathString := GetPathString(Path, '');
//  if SameText(PathString, 'true') then
//    Exit(True);
//
//  if SameText(PathString, 'false') then
//    Exit(False);
//
//  Result := Default;
//end;
//
//function TJSONValueHelper.GetPathCount(const Path: string; const Default: Integer): Integer;
//begin
//  var V := GetPathValue(Path);
//  if V = nil then
//    Exit(Default);
//
//  if V is TJSONArray then
//    Exit(TJSONArray(V).Count);
//
//  if V is TJSONObject then
//    Exit(TJSONObject(V).Count);
//
//  Result := Default;
//end;
//
//function TJSONValueHelper.GetPathDouble(const Path: string; const Default: Double): Double;
//begin
//  var PathString := GetPathString(Path, '');
//  var FS := TFormatSettings.Invariant;
//  if (PathString <> '') and TryStrToFloat(PathString, Result, FS) then
//    Exit;
//
//  Result := Default;
//end;
//
//{ TJsonQuery }
//
//class function TJsonQuery.Parse(const JsonText: string): TJsonQuery;
//begin
//  Result.FRoot := TJSONObject.ParseJSONValue(JsonText);
//end;
//
//class operator TJsonQuery.Initialize(out Dest: TJsonQuery);
//begin
//  Dest.FRoot := nil;
//end;
//
//class operator TJsonQuery.Finalize(var Dest: TJsonQuery);
//begin
//  Dest.FRoot.Free;
//  Dest.FRoot := nil;
//end;
//
//function TJsonQuery.IsValid: Boolean;
//begin
//  Result := FRoot <> nil;
//end;
//
//function TJsonQuery.Value(const Path: string): TJSONValue;
//begin
//  if FRoot = nil then Exit(nil);
//  Result := FRoot.GetPathValue(Path);
//end;
//
//function TJsonQuery.AsString(const Path, Default: string): string;
//begin
//  if FRoot = nil then Exit(Default);
//  Result := FRoot.GetPathString(Path, Default);
//end;
//
//function TJsonQuery.AsInteger(const Path: string; const Default: Integer): Integer;
//begin
//  if FRoot = nil then Exit(Default);
//  Result := FRoot.GetPathInteger(Path, Default);
//end;
//
//function TJsonQuery.AsBoolean(const Path: string; const Default: Boolean): Boolean;
//begin
//  if FRoot = nil then Exit(Default);
//  Result := FRoot.GetPathBoolean(Path, Default);
//end;
//
//function TJsonQuery.AsDouble(const Path: string; const Default: Double): Double;
//begin
//  if FRoot = nil then Exit(Default);
//  Result := FRoot.GetPathDouble(Path, Default);
//end;
//
//function TJsonQuery.ObjectText(const Path, Default: string): string;
//begin
//  if FRoot = nil then Exit(Default);
//  Result := FRoot.GetPathObjectText(Path, Default);
//end;
//
//function TJsonQuery.ArrayText(const Path, Default: string): string;
//begin
//  if FRoot = nil then Exit(Default);
//  Result := FRoot.GetPathArrayText(Path, Default);
//end;
//
//function TJsonQuery.Count(const Path: string; const Default: Integer): Integer;
//begin
//  if FRoot = nil then Exit(Default);
//  Result := FRoot.GetPathCount(Path, Default);
//end;
//
//end.



unit Gemini.JsonPathHelper;

interface

uses
  System.SysUtils, System.JSON, System.Generics.Collections;

type
  TJSONValueHelper = class helper for TJSONValue
  public
    function GetPathValue(const Path: string): TJSONValue;
    function GetPathString(const Path: string; const Default: string = ''): string;
    function GetPathInteger(const Path: string; const Default: Integer = 0): Integer;
    function GetPathBoolean(const Path: string; const Default: Boolean = False): Boolean;
    function GetPathDouble(const Path: string; const Default: Double = 0.0): Double;
    function GetPathObjectText(const Path: string; const Default: string = ''): string;
    function GetPathArrayText(const Path: string; const Default: string = ''): string;
    function GetPathCount(const Path: string; const Default: Integer = 0): Integer;
  end;




function JsonGetString(const JsonText, Path: string; const Default: string = ''): string;
function JsonGetObjectText(const JsonText, Path: string; const Default: string = ''): string;
function JsonGetArrayText(const JsonText, Path: string; const Default: string = ''): string;
function JsonGetCount(const JsonText, Path: string; const Default: Integer = 0): Integer;

implementation

function NextToken(const S: string; var I: Integer): string;
begin
  while (I <= S.Length) and (S[I] = '.') do
    Inc(I);

  var Start := I;

  while (I <= S.Length) and (S[I] <> '.') do
    Inc(I);

  Result := S.Substring(Start-1, I-Start);
end;

function ParseArrayIndex(const Token: string; out Name: string; out HasIndex: Boolean; out Index: Integer): Boolean;
begin
  Name := Token;
  HasIndex := False;
  Index := -1;

  var L := Token.IndexOf('[');
  if L < 0 then
    Exit(True);

  var R := Token.IndexOf(']', L+1);
  if R < 0 then
    Exit(False);

  Name := Token.Substring(0, L);
  var IndexStr := Token.Substring(L+1, R-(L+1));
  HasIndex := True;
  Result := TryStrToInt(IndexStr, Index) and (Index >= 0);
end;

function TJSONValueHelper.GetPathValue(const Path: string): TJSONValue;
var
  Cur: TJSONValue;
  Obj: TJSONObject;
  Arr: TJSONArray;
  Index: Integer;
  Name: string;
  HasIndex: Boolean;
begin
  Result := nil;
  Cur := Self;
  if (Cur = nil) or Path.IsEmpty
    then Exit;

  var I := 1;
  while I <= Path.Length do
    begin
      var Token := NextToken(Path, I);
      if Token.IsEmpty then
        Break;

      if not ParseArrayIndex(Token, Name, HasIndex, Index) then
        Exit(nil);

      {--- object field }
      if not Name.IsEmpty then
        begin
          if not (Cur is TJSONObject) then
            Exit(nil);

          Obj := TJSONObject(Cur);
          Cur := Obj.GetValue(Name);
          if Cur = nil then
            Exit(nil);
        end;

      {--- table index }
      if HasIndex then
        begin
          if not (Cur is TJSONArray) then
            Exit(nil);

          Arr := TJSONArray(Cur);
          if (Index < 0) or (Index >= Arr.Count) then
            Exit(nil);

          Cur := Arr.Items[Index];
          if Cur = nil then
            Exit(nil);
        end;
    end;

  Result := Cur;
end;

function TJSONValueHelper.GetPathString(const Path: string; const Default: string): string;
begin
  var JSONValue := GetPathValue(Path);
  if JSONValue = nil then
    Exit(Default);

  if JSONValue is TJSONString then
    Exit(TJSONString(JSONValue).Value);

  if JSONValue is TJSONNumber then
    Exit(TJSONNumber(JSONValue).ToString);

  Result := JSONValue.Value;
  if Result.IsEmpty then
    Result := JSONValue.ToString;
end;

function TJSONValueHelper.GetPathInteger(const Path: string; const Default: Integer): Integer;
begin
  var PathString := GetPathString(Path, '');
  if not PathString.IsEmpty and TryStrToInt(PathString, Result) then
    Exit;

  Result := Default;
end;

function TJSONValueHelper.GetPathArrayText(const Path, Default: string): string;
begin
  var JSONValue := GetPathValue(Path);
  if (JSONValue <> nil) and (JSONValue is TJSONArray) then
    Exit(TJSONArray(JSONValue).ToJSON);

  Result := Default;
end;

function TJSONValueHelper.GetPathObjectText(const Path,
  Default: string): string;
begin
  var JSONValue := GetPathValue(Path);
  if (JSONValue <> nil) and (JSONValue is TJSONObject) then
    Exit(TJSONObject(JSONValue).ToJSON);

  Result := Default;
end;

function TJSONValueHelper.GetPathBoolean(const Path: string; const Default: Boolean): Boolean;
begin
  var PathString := GetPathString(Path, '');
  if SameText(PathString, 'true') then
    Exit(True);

  if SameText(PathString, 'false') then
    Exit(False);

  Result := Default;
end;

function TJSONValueHelper.GetPathCount(const Path: string;
  const Default: Integer): Integer;
begin
  var V := GetPathValue(Path);
  if V = nil then
    Exit(Default);

  if V is TJSONArray then
    Exit(TJSONArray(V).Count);

  if V is TJSONObject then
    Exit(TJSONObject(V).Count);

  Result := Default;
end;

function TJSONValueHelper.GetPathDouble(const Path: string; const Default: Double): Double;
begin
  var PathString := GetPathString(Path, '');
  var FS := TFormatSettings.Invariant;
  if (PathString <> '') and TryStrToFloat(PathString, Result, FS) then
    Exit;

  Result := Default;
end;

function JsonGetString(const JsonText, Path: string; const Default: string): string;
begin
  var JSONValue := TJSONObject.ParseJSONValue(JsonText);
  try
    if JSONValue = nil then
      Exit(Default);

    Result := JSONValue.GetPathString(Path, Default);
  finally
    JSONValue.Free;
  end;
end;

function JsonGetObjectText(const JsonText, Path: string; const Default: string = ''): string;
begin
  var JSONValue := TJSONObject.ParseJSONValue(JsonText);
  try
    if JSONValue = nil then
      Exit(Default);

    Result := JSONValue.GetPathObjectText(Path, Default);
  finally
    JSONValue.Free;
  end;
end;

function JsonGetArrayText(const JsonText, Path: string; const Default: string = ''): string;
begin
  var JSONValue := TJSONObject.ParseJSONValue(JsonText);
  try
    if JSONValue = nil then
      Exit(Default);

    Result := JSONValue.GetPathArrayText(Path, Default);
  finally
    JSONValue.Free;
  end;
end;

function JsonGetCount(const JsonText, Path: string; const Default: Integer): Integer;
begin
  var JSONValue := TJSONObject.ParseJSONValue(JsonText);
  try
    if JSONValue = nil then
      Exit(Default);

    Result := JSONValue.GetPathCount(Path, Default);
  finally
    JSONValue.Free;
  end;
end;

end.

