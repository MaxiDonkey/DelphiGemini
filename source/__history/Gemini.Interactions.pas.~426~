unit Gemini.Interactions;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils,
  REST.JsonReflect, REST.Json.Types,
  Gemini.API, Gemini.API.Params, Gemini.Types, Gemini.Exceptions,
  Gemini.Interactions.Request,Gemini.Interactions.Responses, Gemini.Interactions.Stream,
  Gemini.Interactions.StreamEngine, Gemini.Interactions.StreamCallbacks,
  Gemini.Async.Support, Gemini.Async.Promise;

type
  TUrlRetrieving = class(TUrlParam)
    /// <summary>
    /// If set to true, the generated content will be streamed incrementally.
    /// </summary>
    /// <param name="Value">
    /// Defaults to: False
    /// </param>
    function Stream(const Value: Boolean): TUrlRetrieving;

    /// <summary>
    /// Optional. If set, resumes the interaction stream from the next chunk after the event marked by the event id.
    /// </summary>
    /// <remarks>
    /// Can only be used if `stream` is true.
    /// </remarks>
    function LastEventId(const Value: string): TUrlRetrieving;

    /// <summary>
    /// Which version of the API to use.
    /// </summary>
    function ApiVersion(const Value: string): TUrlRetrieving;
  end;

  TCRUDDeleted = class end;

  /// <summary>
  /// Asynchronous callback container for interaction delete operations.
  /// </summary>
  /// <remarks>
  /// <c>TAsynCRUDDeleted</c> is an alias of <c>TAsynCallBack&lt;TCRUDDeleted&gt;</c> and is used to configure
  /// lifecycle callbacks for asynchronous calls that delete an interaction resource.
  /// <para>
  /// • Typical handlers include <c>OnStart</c> (invoked when the asynchronous work begins),
  /// <c>OnSuccess</c> (invoked with the resulting <c>TCRUDDeleted</c>), and <c>OnError</c>
  /// (invoked with an error message if the call fails).
  /// </para>
  /// <para>
  /// • The <c>TCRUDDeleted</c> result is an empty marker type that represents a successful delete
  /// operation (i.e., the server acknowledged the deletion). Consumers usually only need to check
  /// whether the operation completed without error.
  /// </para>
  /// <para>
  /// • This type only defines the callback bundle and does not execute any asynchronous work by itself.
  /// </para>
  /// </remarks>
  TAsynCRUDDeleted = TAsynCallBack<TCRUDDeleted>;

  /// <summary>
  /// Promise-style callback container for interaction delete operations.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseCRUDDeleted</c> is an alias of <c>TPromiseCallback&lt;TCRUDDeleted&gt;</c> and is intended for
  /// promise-based APIs that delete an interaction resource.
  /// <para>
  /// • It allows callers to register lifecycle callbacks that are invoked while the promise is pending
  /// and when it settles, either resolved with a <c>TCRUDDeleted</c> or rejected with an error.
  /// </para>
  /// <para>
  /// • Typical handlers include <c>OnStart</c> (invoked when the asynchronous work begins),
  /// <c>OnSuccess</c> (invoked with the resulting <c>TCRUDDeleted</c>), and <c>OnError</c>
  /// (invoked with an error message if the call fails).
  /// </para>
  /// <para>
  /// • The <c>TCRUDDeleted</c> result is an empty marker type that represents a successful delete
  /// operation (i.e., the server acknowledged the deletion). Consumers usually only need to check
  /// whether the operation completed without error.
  /// </para>
  /// <para>
  /// • This type only defines the callback bundle and does not execute any asynchronous work by itself.
  /// </para>
  /// </remarks>
  TPromiseCRUDDeleted = TPromiseCallback<TCRUDDeleted>;

  /// <summary>
  /// Callback signature used to receive streamed interaction SSE events.
  /// </summary>
  /// <param name="Interaction">
  /// A streamed event payload. When <paramref name="IsDone"/> is False, this is typically a valid
  /// <c>TInteractionStream</c> instance representing the current SSE event. When <paramref name="IsDone"/>
  /// is True, this may be nil (end-of-stream marker) depending on the caller implementation.
  /// </param>
  /// <param name="IsDone">
  /// Indicates whether the stream has reached a terminal state. When True, no further events are expected
  /// (completion or error).
  /// </param>
  /// <param name="Cancel">
  /// Set to True to request cancellation/abort of the ongoing stream. The caller should stop reading and
  /// return as soon as possible after this flag is set.
  /// </param>
  /// <remarks>
  /// <c>TInteractionEvent</c> is a procedure reference used by streaming APIs (for example, <c>CreateStream</c>)
  /// to push decoded Server-Sent Events (SSE) to the consumer.
  /// <para>
  /// • While <paramref name="IsDone"/> is False, the callback is invoked for each intermediate event
  /// (status updates, content start/delta/stop, etc.).
  /// </para>
  /// <para>
  /// • When <paramref name="IsDone"/> becomes True, the callback is invoked once to signal termination,
  /// either because an <c>interaction_complete</c> event was received or an <c>error</c> event occurred.
  /// </para>
  /// <para>
  /// • Ownership of <paramref name="Interaction"/> depends on the streaming implementation. In this unit,
  /// <c>CreateStream</c> frees the event instance after invoking the callback, so consumers should not
  /// retain the reference beyond the callback scope (copy any needed data).
  /// </para>
  /// </remarks>
  TInteractionEvent = reference to procedure(var Interaction: TInteractionStream; IsDone: Boolean; var Cancel: Boolean);

  TAbstractSupport = class(TGeminiAPIRoute)
  protected
    function Create(const ParamProc: TProc<TInteractionParams>): TInteraction; virtual; abstract;

    function CreateStream(const ParamProc: TProc<TInteractionParams>;
      const Event: TInteractionEvent;
      const StreamEvents: IEventEngineManager = nil): Boolean; virtual; abstract;

    function Retrieve(const Id: string; const UrlProc: TProc<TUrlRetrieving> = nil): TInteraction; virtual; abstract;

    function Cancel(const Id: string): TInteraction; virtual; abstract;

    function Delete(const Id: string): TCRUDDeleted; virtual; abstract;
  end;

  TAsynchronousSupport = class(TAbstractSupport)
  protected
    procedure AsynCreate(const ParamProc: TProc<TInteractionParams>;
      const CallBacks: TFunc<TAsynInteraction>);

    procedure AsynCreateStream(const ParamProc: TProc<TInteractionParams>;
      const CallBacks: TFunc<TAsynInteractionStream>;
      const StreamEvents: IEventEngineManager = nil);

    procedure AsynRetrieve(const Id: string; const UrlProc: TProc<TUrlRetrieving>;
      const CallBacks: TFunc<TAsynInteraction>); overload;

    procedure AsynRetrieve(const Id: string;
      const CallBacks: TFunc<TAsynInteraction>); overload;

    procedure AsynCancel(const Id: string;
      const CallBacks: TFunc<TAsynInteraction>);

    procedure AsynDelete(const Id: string;
      const CallBacks: TFunc<TAsynCRUDDeleted>);

    function AsyncAwaitCreateStream(
      const ParamProc: TProc<TInteractionParams>;
      const Callbacks: TFunc<TPromiseInteractionStream> = nil;
      const StreamEvents: IEventEngineManager = nil): TPromise<TEventData>; overload;
  end;

  TInteractionsRoute = class(TAsynchronousSupport)
    /// <summary>
    /// Creates a new interaction synchronously and returns the resulting <c>TInteraction</c> resource.
    /// </summary>
    /// <param name="ParamProc">
    /// Callback used to configure the request parameters (model/agent, input, tools, generation config, etc.)
    /// via a <c>TInteractionParams</c> instance.
    /// </param>
    /// <returns>
    /// The created <c>TInteraction</c> resource returned by the server.
    /// </returns>
    /// <remarks>
    /// This method issues a synchronous HTTP POST to the interactions endpoint and blocks until the request
    /// completes.
    /// <para>
    /// • The returned <c>TInteraction</c> typically includes identifiers/status (for example <c>Id</c>,
    /// <c>Status</c>, <c>Created</c>, <c>Updated</c>), generated outputs (<c>Outputs</c>), and usage statistics
    /// (<c>Usage</c>), depending on the server response and request options.
    /// </para>
    /// <para>
    /// • For a non-blocking version, use <c>AsynCreate</c> or <c>AsyncAwaitCreate</c>.
    /// For SSE streaming output, use <c>CreateStream</c> / <c>AsynCreateStream</c> / <c>AsyncAwaitCreateStream</c>.
    /// </para>
    /// </remarks>
    function Create(const ParamProc: TProc<TInteractionParams>): TInteraction; override;

    /// <summary>
    /// Creates a new interaction using Server-Sent Events (SSE) streaming and dispatches decoded stream
    /// events to the provided callback.
    /// </summary>
    /// <param name="ParamProc">
    /// Callback used to configure the request parameters via a <c>TInteractionParams</c> instance.
    /// The request should enable streaming (for example, by setting the <c>stream</c> flag).
    /// </param>
    /// <param name="Event">
    /// Callback invoked for each decoded <c>TInteractionStream</c> SSE payload.
    /// The callback can request early termination by setting <c>Cancel</c> to True.
    /// </param>
    /// <returns>
    /// True if the underlying HTTP request completed successfully; otherwise False (depending on the HTTP
    /// client behavior). Exceptions may still be raised for decoding/transport failures.
    /// </returns>
    /// <remarks>
    /// This method performs a streaming POST to the interactions endpoint and incrementally decodes SSE frames
    /// into <c>TInteractionStream</c> instances.
    /// <para>
    /// • While the stream is active, <paramref name="Event"/> is invoked with <c>IsDone=False</c> for intermediate
    /// events (status updates, content start/delta/stop, etc.).
    /// </para>
    /// <para>
    /// • Termination: when an <c>interaction_complete</c> or <c>error</c> event is received, the callback is
    /// invoked once with <c>IsDone=True</c> and no further events are expected.
    /// </para>
    /// <para>
    /// • Ownership: the streaming implementation may free the event instance after the callback returns.
    /// Consumers should not retain the <c>TInteractionStream</c> reference beyond the callback scope; copy any
    /// required data out of the object during the callback.
    /// </para>
    /// <para>
    /// • For asynchronous wrappers, see <c>AsynCreateStream</c> and <c>AsyncAwaitCreateStream</c>.
    /// </para>
    /// </remarks>
    function CreateStream(const ParamProc: TProc<TInteractionParams>;
      const Event: TInteractionEvent;
      const StreamEvents: IEventEngineManager = nil): Boolean; override;

    /// <summary>
    /// Cancels a running background interaction synchronously and returns the resulting
    /// <c>TInteraction</c> resource snapshot.
    /// </summary>
    /// <param name="Id">
    /// The unique identifier of the interaction to cancel.
    /// </param>
    /// <returns>
    /// A <c>TInteraction</c> instance representing the interaction state after the cancellation request
    /// (typically reflecting a <c>cancelled</c> status).
    /// </returns>
    /// <remarks>
    /// This method issues a synchronous POST to the <c>/interactions/{id}/cancel</c> endpoint and blocks until
    /// completion.
    /// <para>
    /// • Cancellation applies only to background interactions that are still running. If the interaction
    /// has already completed, the server may return a completed/cancelled state or an error depending on
    /// API behavior.
    /// </para>
    /// <para>
    /// • For non-blocking variants, use <c>AsynCancel</c> or <c>AsyncAwaitCancel</c>.
    /// </para>
    /// </remarks>
    function Cancel(const Id: string): TInteraction; override;

    /// <summary>
    /// Deletes an interaction synchronously and returns a marker instance when the deletion is acknowledged
    /// by the server.
    /// </summary>
    /// <param name="Id">
    /// The unique identifier of the interaction to delete.
    /// </param>
    /// <returns>
    /// A <c>TCRUDDeleted</c> marker instance representing a successful delete operation.
    /// </returns>
    /// <remarks>
    /// This method issues a synchronous HTTP DELETE to the <c>/interactions/{id}</c> endpoint and blocks until
    /// the request completes.
    /// <para>
    /// • The API's delete response is empty when successful. In this library, <c>TCRUDDeleted</c> is used as an
    /// empty marker type to represent that acknowledgement.
    /// </para>
    /// <para>
    /// • For non-blocking variants, use <c>AsynDelete</c> or <c>AsyncAwaitDelete</c>.
    /// </para>
    /// </remarks>
    function Delete(const Id: string): TCRUDDeleted; override;

    /// <summary>
    /// Retrieves the full details of a single interaction synchronously.
    /// </summary>
    /// <param name="Id">
    /// The unique identifier of the interaction to retrieve.
    /// </param>
    /// <param name="UrlProc">
    /// Optional. Callback used to configure URL/query parameters via a <c>TUrlRetrieving</c> instance
    /// (for example <c>Stream</c>, <c>LastEventId</c>, and <c>ApiVersion</c>). If not provided, default
    /// query parameters are used.
    /// </param>
    /// <returns>
    /// The retrieved <c>TInteraction</c> resource returned by the server.
    /// </returns>
    /// <remarks>
    /// This method issues a synchronous HTTP GET to the <c>/interactions/{id}</c> endpoint and blocks until
    /// completion.
    /// <para>
    /// • Query parameters: use <paramref name="UrlProc"/> to request streaming retrieval (<c>Stream(True)</c>)
    /// and/or resume from a specific SSE event (<c>LastEventId</c>). Resuming is only applicable when
    /// streaming is enabled.
    /// </para>
    /// <para>
    /// • The returned <c>TInteraction</c> typically includes identifiers/status (for example <c>Id</c>,
    /// <c>Status</c>, <c>Created</c>, <c>Updated</c>), generated outputs (<c>Outputs</c>), and usage statistics
    /// (<c>Usage</c>), depending on the server response.
    /// </para>
    /// <para>
    /// • For non-blocking variants, use <c>AsynRetrieve</c> or <c>AsyncAwaitRetrieve</c>.
    /// </para>
    /// </remarks>
    function Retrieve(const Id: string; const UrlProc: TProc<TUrlRetrieving> = nil): TInteraction; override;

    /// <summary>
    /// Creates a new interaction asynchronously and returns a promise that resolves to the created
    /// <c>TInteraction</c> resource.
    /// </summary>
    /// <param name="ParamProc">
    /// Callback used to configure the request parameters (model/agent, input, tools, generation config, etc.)
    /// via a <c>TInteractionParams</c> instance.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. Promise-style callback container used to receive lifecycle notifications
    /// (for example <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>).
    /// If not provided, the operation still runs and the returned promise is resolved/rejected accordingly.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TInteraction&gt;</c> that resolves with the created <c>TInteraction</c> on success
    /// or rejects with an exception if the request fails.
    /// </returns>
    /// <remarks>
    /// This method is the promise-based counterpart of <c>AsynCreate</c> and wraps the callback-style
    /// asynchronous execution into a <c>TPromise</c>.
    /// <para>
    /// • The returned <c>TInteraction</c> typically includes identifiers/status (for example <c>Id</c>,
    /// <c>Status</c>, <c>Created</c>, <c>Updated</c>), generated outputs (<c>Outputs</c>), and usage
    /// statistics (<c>Usage</c>), depending on the server response.
    /// </para>
    /// <para>
    /// • Error handling: failures reject the promise with an exception (message derived from the underlying
    /// request/serialization error). If <paramref name="Callbacks"/> is provided and defines <c>OnError</c>,
    /// it is invoked before rejection.
    /// </para>
    /// </remarks>
    function AsyncAwaitCreate(
      const ParamProc: TProc<TInteractionParams>;
      const Callbacks: TFunc<TPromiseInteraction> = nil): TPromise<TInteraction>;

    /// <summary>
    /// Creates a new interaction using Server-Sent Events (SSE) streaming and returns a promise that resolves
    /// to the aggregated event data captured during the stream.
    /// </summary>
    /// <param name="ParamProc">
    /// Callback used to configure the request parameters via a <c>TInteractionParams</c> instance
    /// (model/agent, input, tools, generation config, etc.). The request should enable streaming
    /// (for example, by setting the <c>stream</c> flag).
    /// </param>
    /// <param name="StreamEvents">
    /// Optional. Custom stream event engine used to aggregate and/or dispatch streamed SSE events.
    /// If <c>nil</c>, a default engine instance is created and used.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TEventData&gt;</c> that resolves with the final <c>TEventData</c> buffer produced by
    /// aggregating all streamed events, or rejects with an exception if the stream fails or is cancelled.
    /// </returns>
    /// <remarks>
    /// This overload is a convenience wrapper that wires up SSE streaming without requiring explicit
    /// promise-style callbacks. It is useful when you want the full aggregated stream result as a single
    /// value.
    /// <para>
    /// • Aggregation: the underlying stream pipeline calls <c>IEventEngineManager.AggregateStreamEvents</c>
    /// for each decoded <c>TInteractionStream</c> event. The provided <paramref name="StreamEvents"/> controls
    /// how events are aggregated into the resulting <c>TEventData</c>.
    /// </para>
    /// <para>
    /// • Default engine: when <paramref name="StreamEvents"/> is <c>nil</c>, the route creates a default
    /// engine manager (typically via <c>TEventEngineManagerFactory</c>) to accumulate events.
    /// </para>
    /// <para>
    /// • Cancellation: cancellation is driven by the dispatcher associated with <paramref name="StreamEvents"/>
    /// (when provided) or by the default dispatcher created by the route. If cancellation is requested, the
    /// stream is aborted and the promise is rejected.
    /// </para>
    /// <para>
    /// • Errors: transport, decoding, or API errors cause the promise to be rejected. If a dispatcher
    /// is present and exposes an error callback, it is invoked before rejection (implementation dependent).
    /// </para>
    /// <para>
    /// • For per-event handling, use the overload that accepts <c>TPromiseInteractionStream</c> callbacks,
    /// which exposes <c>OnProgress</c> for each <c>TInteractionStream</c> chunk.
    /// </para>
    /// </remarks>

    function AsyncAwaitCreateStream(
      const ParamProc: TProc<TInteractionParams>;
      const StreamEvents: IEventEngineManager = nil): TPromise<TEventData>; overload;

    /// <summary>
    /// Creates a new interaction using Server-Sent Events (SSE) streaming and returns a promise that resolves
    /// to the aggregated event data captured during the stream, while also exposing per-event lifecycle hooks
    /// through promise-style stream callbacks.
    /// </summary>
    /// <param name="ParamProc">
    /// Callback used to configure the request parameters via a <c>TInteractionParams</c> instance
    /// (model/agent, input, tools, generation config, etc.). The request should enable streaming
    /// (for example, by setting the <c>stream</c> flag).
    /// </param>
    /// <param name="Callbacks">
    /// Promise-style stream callback container used to receive lifecycle notifications and streamed events.
    /// Typical handlers include:
    /// <para>
    /// • <c>OnStart</c> — invoked when the streaming operation starts.
    /// </para>
    /// <para>
    /// • <c>OnProgress</c> — invoked for each decoded <c>TInteractionStream</c> chunk.
    /// </para>
    /// <para>
    /// • <c>OnSuccess</c> — invoked when the stream completes successfully.
    /// </para>
    /// <para>
    /// • <c>OnError</c> — invoked when an error occurs (may return a rewritten message).
    /// </para>
    /// <para>
    /// • <c>OnDoCancel</c> / <c>OnCancellation</c> — queried/raised to support cooperative cancellation.
    /// </para>
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TEventData&gt;</c> that resolves with the final <c>TEventData</c> buffer produced by aggregating
    /// all streamed events, or rejects with an exception if the stream fails or is cancelled.
    /// </returns>
    /// <remarks>
    /// This overload combines two concerns:
    /// <para>
    /// • Per-event handling via <paramref name="Callbacks"/> (notably <c>OnProgress</c> receiving each
    /// <c>TInteractionStream</c> event), and
    /// </para>
    /// <para>
    /// • Final aggregation into a single <c>TEventData</c> value that becomes the promise resolution.
    /// </para>
    /// <para>
    /// Aggregation: each streamed chunk is merged into an internal <c>TEventData</c> buffer via
    /// <c>Buffer.Aggregate(Event, ...)</c>. If the aggregation callback signals failure, the promise is rejected
    /// (and <c>Callbacks.OnError</c> is invoked if assigned).
    /// </para>
    /// <para>
    /// Completion: when the stream terminates normally, <c>Callbacks.OnSuccess</c> (if assigned) is invoked and the
    /// promise is resolved with the final aggregated <c>TEventData</c>.
    /// </para>
    /// <para>
    /// Errors: transport, decoding, or server-side <c>error</c> events cause the promise to be rejected with an
    /// exception. If <c>Callbacks.OnError</c> is provided, it is invoked first and may return a replacement message
    /// used for the rejection exception.
    /// </para>
    /// <para>
    /// Cancellation: if <c>Callbacks.OnDoCancel</c> returns <c>True</c> (polled by the streaming pipeline), the stream is
    /// aborted. If <c>Callbacks.OnCancellation</c> is provided, its returned string is used as the rejection message;
    /// otherwise a default message (for example <c>'aborted'</c>) is used.
    /// </para>
    /// <para>
    /// Ownership: the lifetime of <c>TInteractionStream</c> instances is controlled by the streaming pipeline.
    /// Treat the <c>Event</c> argument received in <c>OnProgress</c> as ephemeral; copy any needed data during the callback.
    /// </para>
    /// </remarks>

    function AsyncAwaitCreateStream(
      const ParamProc: TProc<TInteractionParams>;
      const Callbacks: TFunc<TPromiseInteractionStream>): TPromise<TEventData>; overload;

    /// <summary>
    /// Cancels a running background interaction asynchronously and returns a promise that resolves to
    /// the resulting <c>TInteraction</c> resource snapshot.
    /// </summary>
    /// <param name="Id">
    /// The unique identifier of the interaction to cancel.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. Promise-style callback container used to receive lifecycle notifications
    /// (for example <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TInteraction&gt;</c> that resolves with the updated <c>TInteraction</c> on success
    /// (typically reflecting a <c>cancelled</c> status) or rejects with an exception if the request fails.
    /// </returns>
    /// <remarks>
    /// This method is the promise-based counterpart of <c>AsynCancel</c> and wraps the callback-style
    /// asynchronous execution into a <c>TPromise</c>.
    /// <para>
    /// • Cancellation applies only to background interactions that are still running. If the interaction
    /// has already completed, the server may return a completed/cancelled state or an error depending on
    /// API behavior.
    /// </para>
    /// <para>
    /// • The resolved <c>TInteraction</c> typically includes identifiers/status (for example <c>Id</c>,
    /// <c>Status</c>, <c>Created</c>, <c>Updated</c>) and may omit outputs depending on the cancellation timing.
    /// </para>
    /// <para>
    /// • Error handling: failures reject the promise with an exception. If <paramref name="Callbacks"/> is
    /// provided and defines <c>OnError</c>, it is invoked before rejection.
    /// </para>
    /// </remarks>
    function AsyncAwaitCancel(
      const Id: string;
      const Callbacks: TFunc<TPromiseInteraction> = nil): TPromise<TInteraction>;

    /// <summary>
    /// Deletes an interaction asynchronously and returns a promise that resolves when the deletion
    /// is acknowledged by the server.
    /// </summary>
    /// <param name="Id">
    /// The unique identifier of the interaction to delete.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. Promise-style callback container used to receive lifecycle notifications
    /// (for example <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TCRUDDeleted&gt;</c> that resolves with a <c>TCRUDDeleted</c> marker instance on success
    /// or rejects with an exception if the request fails.
    /// </returns>
    /// <remarks>
    /// This method is the promise-based counterpart of <c>AsynDelete</c> and wraps the callback-style
    /// asynchronous execution into a <c>TPromise</c>.
    /// <para>
    /// • The API's delete response is empty when successful. In this library, <c>TCRUDDeleted</c> is used
    /// as a marker type to represent a successful delete operation.
    /// </para>
    /// <para>
    /// • Error handling: failures reject the promise with an exception. If <paramref name="Callbacks"/> is
    /// provided and defines <c>OnError</c>, it is invoked before rejection.
    /// </para>
    /// </remarks>
    function AsyncAwaitDelete(
      const Id: string;
      const Callbacks: TFunc<TPromiseCRUDDeleted> = nil): TPromise<TCRUDDeleted>;

    /// <summary>
    /// Retrieves an existing interaction asynchronously and returns a promise that resolves to the
    /// corresponding <c>TInteraction</c> resource.
    /// </summary>
    /// <param name="Id">
    /// The unique identifier of the interaction to retrieve.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. Promise-style callback container used to receive lifecycle notifications
    /// (for example <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TInteraction&gt;</c> that resolves with the retrieved <c>TInteraction</c> on success
    /// or rejects with an exception if the request fails.
    /// </returns>
    /// <remarks>
    /// This overload retrieves the interaction using default URL/query parameters (no <c>TUrlRetrieving</c>
    /// customization). Use the overload that accepts <c>UrlProc</c> if you need to pass query parameters such
    /// as <c>Stream</c>, <c>LastEventId</c>, or <c>ApiVersion</c>.
    /// <para>
    /// • This method is the promise-based counterpart of <c>AsynRetrieve</c> and wraps the callback-style
    /// asynchronous execution into a <c>TPromise</c>.
    /// </para>
    /// <para>
    /// • Error handling: failures reject the promise with an exception. If <paramref name="Callbacks"/> is
    /// provided and defines <c>OnError</c>, it is invoked before rejection.
    /// </para>
    /// </remarks>
    function AsyncAwaitRetrieve(
      const Id: string;
      const Callbacks: TFunc<TPromiseInteraction> = nil): TPromise<TInteraction>; overload;

    /// <summary>
    /// Retrieves an existing interaction asynchronously and returns a promise that resolves to the
    /// corresponding <c>TInteraction</c> resource.
    /// </summary>
    /// <param name="Id">
    /// The unique identifier of the interaction to retrieve.
    /// </param>
    /// <param name="UrlProc">
    /// Callback used to configure optional URL/query parameters via a <c>TUrlRetrieving</c> instance
    /// (for example <c>Stream</c>, <c>LastEventId</c>, and <c>ApiVersion</c>).
    /// </param>
    /// <param name="Callbacks">
    /// Optional. Promise-style callback container used to receive lifecycle notifications
    /// (for example <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TInteraction&gt;</c> that resolves with the retrieved <c>TInteraction</c> on success
    /// or rejects with an exception if the request fails.
    /// </returns>
    /// <remarks>
    /// This method is the promise-based counterpart of <c>AsynRetrieve</c> and wraps the callback-style
    /// asynchronous execution into a <c>TPromise</c>.
    /// <para>
    /// • Query parameters: use <paramref name="UrlProc"/> to request streaming retrieval (<c>Stream(True)</c>)
    /// and/or resume from a specific SSE event (<c>LastEventId</c>). Resuming is only applicable when
    /// streaming is enabled.
    /// </para>
    /// <para>
    /// • The resolved <c>TInteraction</c> typically includes identifiers/status (for example <c>Id</c>,
    /// <c>Status</c>, <c>Created</c>, <c>Updated</c>), generated outputs (<c>Outputs</c>), and usage statistics
    /// (<c>Usage</c>), depending on the server response.
    /// </para>
    /// <para>
    /// • Error handling: failures reject the promise with an exception. If <paramref name="Callbacks"/> is
    /// provided and defines <c>OnError</c>, it is invoked before rejection.
    /// </para>
    /// </remarks>
    function AsyncAwaitRetrieve(
      const Id: string;
      const UrlProc: TProc<TUrlRetrieving>;
      const Callbacks: TFunc<TPromiseInteraction> = nil): TPromise<TInteraction>; overload;
  end;

implementation

uses
  System.Classes, System.Threading, System.SyncObjs,
  Rest.Json,
  Gemini.Async.Params, Gemini.API.Streams, Gemini.API.SSEDecoder;

{ TUrlRetrieving }

function TUrlRetrieving.ApiVersion(const Value: string): TUrlRetrieving;
begin
  Result := TUrlRetrieving(Add('api_version', Value));
end;

function TUrlRetrieving.LastEventId(const Value: string): TUrlRetrieving;
begin
  Result := TUrlRetrieving(Add('last_event_id', Value));
end;

function TUrlRetrieving.Stream(const Value: Boolean): TUrlRetrieving;
begin
  Result := TUrlRetrieving(Add('stream', Value));
end;

{ TInteractionsRoute }

function TInteractionsRoute.AsyncAwaitCancel(const Id: string;
  const Callbacks: TFunc<TPromiseInteraction>): TPromise<TInteraction>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TInteraction>(
    procedure(const CallbackParams: TFunc<TAsynInteraction>)
    begin
      Self.AsynCancel(Id, CallbackParams);
    end,
    Callbacks);
end;

function TInteractionsRoute.AsyncAwaitCreate(
  const ParamProc: TProc<TInteractionParams>;
  const Callbacks: TFunc<TPromiseInteraction>): TPromise<TInteraction>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TInteraction>(
    procedure(const CallbackParams: TFunc<TAsynInteraction>)
    begin
      Self.AsynCreate(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TInteractionsRoute.AsyncAwaitCreateStream(
  const ParamProc: TProc<TInteractionParams>;
  const StreamEvents: IEventEngineManager): TPromise<TEventData>;
begin
  Result := Self.AsyncAwaitCreateStream(ParamProc, nil, StreamEvents);
end;

function TInteractionsRoute.AsyncAwaitCreateStream(
  const ParamProc: TProc<TInteractionParams>;
  const Callbacks: TFunc<TPromiseInteractionStream>): TPromise<TEventData>;
begin
  Result := Self.AsyncAwaitCreateStream(ParamProc, Callbacks, nil);
end;

function TInteractionsRoute.AsyncAwaitDelete(const Id: string;
  const Callbacks: TFunc<TPromiseCRUDDeleted>): TPromise<TCRUDDeleted>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TCRUDDeleted>(
    procedure(const CallbackParams: TFunc<TAsynCRUDDeleted>)
    begin
      Self.AsynDelete(Id, CallbackParams);
    end,
    Callbacks);
end;

function TInteractionsRoute.AsyncAwaitRetrieve(const Id: string;
  const Callbacks: TFunc<TPromiseInteraction>): TPromise<TInteraction>;
begin
  Result := Self.AsyncAwaitRetrieve(Id, nil, CallBacks);
end;

function TInteractionsRoute.AsyncAwaitRetrieve(
  const Id: string;
  const UrlProc: TProc<TUrlRetrieving>;
  const Callbacks: TFunc<TPromiseInteraction>): TPromise<TInteraction>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TInteraction>(
    procedure(const CallbackParams: TFunc<TAsynInteraction>)
    begin
      Self.AsynRetrieve(Id, UrlProc, CallbackParams);
    end,
    Callbacks);
end;

function TInteractionsRoute.Cancel(const Id: string): TInteraction;
begin
  Result := API.Post<TInteraction>('interactions/' + Id);
end;

function TInteractionsRoute.Create(
  const ParamProc: TProc<TInteractionParams>): TInteraction;
begin
  Result := API.Post<TInteraction, TInteractionParams>('interactions', ParamProc);
end;

function TInteractionsRoute.CreateStream(const ParamProc: TProc<TInteractionParams>;
  const Event: TInteractionEvent;
  const StreamEvents: IEventEngineManager): Boolean;
var
  Response: TLockedMemoryStream;
  RetPos: Int64;
  Prev: Int64;
  Decoder: TSSEDecoder;
  DoneSent: Boolean;
  LocalEvent: IEventEngineManager;
  Buffer: TEventData;
begin
  if StreamEvents = nil then
    begin
      LocalEvent := TEventEngineManagerFactory.CreateInstance(
        function : TStreamEventCallBack begin end);
    end
  else
    LocalEvent := StreamEvents;

  Response := TLockedMemoryStream.Create;
  try
    RetPos := 0;
    Prev := 0;
    DoneSent := False;

    Decoder := TSSEDecoder.Create(
      procedure(const Data: string; var AAbort: Boolean)
      var
        IxEvent: TInteractionStream;
      begin
        IxEvent := nil;
        if SameText(Trim(Data), '[DONE]') then
          begin
            if not DoneSent then
            begin
              DoneSent := True;
              if Assigned(IxEvent) then
                LocalEvent.AggregateStreamEvents(IxEvent, Buffer);

              Event(IxEvent, True, AAbort);
            end;
            Exit;
          end;

        IxEvent := nil;
        try
          IxEvent := TApiDeserializer.Parse<TInteractionStream>(Data);
        except
          IxEvent := nil;
        end;

        if not Assigned(IxEvent) then
          begin
            Exit;
          end;

        try
          case IxEvent.EventType of
            interaction_complete,
            error:
              begin
                if not DoneSent then
                  begin
                    DoneSent := True;
                    LocalEvent.AggregateStreamEvents(IxEvent, Buffer);
                    Event(IxEvent, True, AAbort);
                  end;
                Exit;
              end;

          else
            begin
              LocalEvent.AggregateStreamEvents(IxEvent, Buffer);
              Event(IxEvent, False, AAbort);
            end;
          end;

        finally
          IxEvent.Free;
        end;
      end);

    try
      Result := API.Post<TInteractionParams>(
        'interactions',
        '?alt=sse',
        ParamProc,
        Response,
        procedure(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var AAbort: Boolean)
        var
          Bytes: TBytes;
        begin
          Prev := RetPos;
          try
            while Response.ExtractDelta(RetPos, Bytes) do
              Decoder.Feed(Bytes, AAbort);
          except
            RetPos := Prev;
            raise;
          end;
        end);

    finally
      if not DoneSent then
        begin
          var AbortFlag := False;

          var Bytes: TBytes;
          Prev := RetPos;
          try
            while Response.ExtractDelta(RetPos, Bytes) do
              Decoder.Feed(Bytes, AbortFlag);
          except
            RetPos := Prev;
            raise;
          end;

          Decoder.Flush(AbortFlag);

          if not DoneSent then
            begin
              var AAbort := False;
              var IxEvent: TInteractionStream := nil;
              Event(IxEvent, True, AAbort);
              FreeAndNil(IxEvent);
            end;
        end;

      Decoder.Free;
    end;

  finally
    Response.Free;
  end;
end;

function TInteractionsRoute.Delete(const Id: string): TCRUDDeleted;
begin
  Result := API.Delete<TCRUDDeleted>('interactions/' + Id);
end;

function TInteractionsRoute.Retrieve(const Id: string; const UrlProc: TProc<TUrlRetrieving>): TInteraction;
begin
  Result := API.Get<TInteraction, TUrlRetrieving>('interactions/' + Id, UrlProc);
end;

{ TAsynchronousSupport }

procedure TAsynchronousSupport.AsynCancel(const Id: string;
  const CallBacks: TFunc<TAsynInteraction>);
begin
  with TAsynCallBackExec<TAsynInteraction, TInteraction>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TInteraction
      begin
        Result := Self.Cancel(Id);
      end);
  finally
    Free;
  end;
end;

function TAsynchronousSupport.AsyncAwaitCreateStream(
  const ParamProc: TProc<TInteractionParams>;
  const Callbacks: TFunc<TPromiseInteractionStream>;
  const StreamEvents: IEventEngineManager): TPromise<TEventData>;
begin
  Result := TPromise<TEventData>.Create(
    procedure(Resolve: TProc<TEventData>; Reject: TProc<Exception>)
    begin
      var Buffer := Default(TEventData);
      AsynCreateStream(ParamProc,
        function : TAsynInteractionStream
        begin
          if Assigned(Callbacks) then
            Result.Sender := Callbacks.Sender;

          if Assigned(Callbacks) and Assigned(Callbacks.OnStart) then
            Result.OnStart := Callbacks.OnStart;

          Result.OnProgress :=
            procedure (Sender: TObject; Event: TInteractionStream)
            begin
              Buffer.Aggregate(Event, procedure
                begin
                  var Error := EmptyStr;
                  if Assigned(Callbacks) and Assigned(Callbacks.OnError) then
                    Error := Callbacks.OnError(Sender, Error);
                  Reject(Exception.Create(Error));
                end);

              if Assigned(Callbacks) and Assigned(Callbacks.OnProgress) then
                Callbacks.OnProgress(Sender, Event);
            end;

          Result.OnSuccess :=
            procedure (Sender: TObject)
            begin
              Resolve(Buffer);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              if Assigned(Callbacks) and Assigned(Callbacks.OnError) then
                Error := Callbacks.OnError(Sender, Error);
              Reject(Exception.Create(Error));
            end;

          Result.OnDoCancel :=
            function : Boolean
            begin
              if Assigned(Callbacks) and Assigned(Callbacks.OnDoCancel) then
                Result := Callbacks.OnDoCancel()
              else
                Result := False;
            end;

          Result.OnCancellation :=
            procedure (Sender: TObject)
            begin
              var Error := 'aborted';
              if Assigned(Callbacks) and Assigned(Callbacks.OnCancellation) then
                Error := Callbacks.OnCancellation(Sender);
              Reject(Exception.Create(Error));
            end;
        end,
      StreamEvents);
    end);
end;

procedure TAsynchronousSupport.AsynCreate(
  const ParamProc: TProc<TInteractionParams>;
  const CallBacks: TFunc<TAsynInteraction>);
begin
  with TAsynCallBackExec<TAsynInteraction, TInteraction>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TInteraction
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TAsynchronousSupport.AsynCreateStream(
  const ParamProc: TProc<TInteractionParams>;
  const CallBacks: TFunc<TAsynInteractionStream>;
  const StreamEvents: IEventEngineManager);
var
  Sender: TObject;
  OnCancellation: TProc<TObject>;
  OnDoCancel: TFunc<Boolean>;
begin
  var CallBackParams := TUseParamsFactory<TAsynInteractionStream>.CreateInstance(CallBacks);

  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var CancelTag := 0;

  if Assigned(StreamEvents) then
    begin
      Sender := StreamEvents.GetStreamEventDispatcher.CallBacks.Sender;
      OnCancellation := StreamEvents.GetStreamEventDispatcher.CallBacks.OnCancellation;
      OnDoCancel := StreamEvents.GetStreamEventDispatcher.CallBacks.OnDoCancel;
    end
  else
    begin
      Sender := CallBackParams.Param.Sender;
      OnCancellation := CallBackParams.Param.OnCancellation;
      OnDoCancel := CallBackParams.Param.OnDoCancel;
    end;

  var Task: ITask := TTask.Create(
        procedure()
        begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var IxEvent: TInteractionStream; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                      procedure
                      begin
                        Stop := OnDoCancel();
                      end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if (CancelTag = 0) and Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Inc(CancelTag);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(IxEvent) then
                    begin
                      var LocalEvent := IxEvent;
                      IxEvent := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(nil, //TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalEvent);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalEvent.Free;
                          end;
                        end)
                      else
                       LocalEvent.Free;
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end,
              StreamEvents);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
        end);
  Task.Start;
end;

procedure TAsynchronousSupport.AsynDelete(const Id: string;
  const CallBacks: TFunc<TAsynCRUDDeleted>);
begin
  with TAsynCallBackExec<TAsynCRUDDeleted, TCRUDDeleted>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TCRUDDeleted
      begin
        Result := Self.Delete(Id);
      end);
  finally
    Free;
  end;
end;

procedure TAsynchronousSupport.AsynRetrieve(const Id: string;
  const UrlProc: TProc<TUrlRetrieving>;
  const CallBacks: TFunc<TAsynInteraction>);
begin
  with TAsynCallBackExec<TAsynInteraction, TInteraction>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TInteraction
      begin
        Result := Self.Retrieve(Id, UrlProc);
      end);
  finally
    Free;
  end;
end;

procedure TAsynchronousSupport.AsynRetrieve(const Id: string;
  const CallBacks: TFunc<TAsynInteraction>);
begin
  Self.AsynRetrieve(Id, nil, CallBacks);
end;

end.
