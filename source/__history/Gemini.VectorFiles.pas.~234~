unit Gemini.VectorFiles;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.JSON,
  REST.JsonReflect, REST.Json.Types,
  Gemini.API.Params, Gemini.API, Gemini.Types,
  Gemini.Operation, Gemini.Vectors.Endpoints,
  Gemini.Async.Support, Gemini.Async.Promise;

type
  TFileSearchStoreParams = class(TJSONParam)
    /// <summary>
    /// Optional. The human-readable display name for the FileSearchStore.
    /// </summary>
    /// <remarks>
    /// The display name must be no more than 512 characters in length, including spaces.
    /// <para>
    /// • Example: "Docs on Semantic Retriever"
    /// </para>
    /// </remarks>
    function DisplayName(const Value: string): TFileSearchStoreParams;
  end;

  TCustomMetadata = class(TJSONParam)
    /// <summary>
    /// Required. The key of the metadata to store.
    /// </summary>
    function Key(const Value: string): TCustomMetadata;

    function StringValue(const Value: string): TCustomMetadata;

    /// <summary>
    /// The string value of the metadata to store.
    /// </summary>
    function StringListValue(const Value: TArray<string>): TCustomMetadata;

    /// <summary>
    /// The numeric value of the metadata to store.
    /// </summary>
    function NumericValue(const Value: Double): TCustomMetadata;
  end;

  TChunkingConfig = class(TJSONParam)
    /// <summary>
    /// Smaller chunks for more precise retrieval
    /// </summary>
    function MaxTokensPerChunk(const Value: Integer): TChunkingConfig;

    /// <summary>
    /// Ensure context isn't lost between chunks
    /// </summary>
    function MaxOverlapTokens(const Value: Integer): TChunkingConfig;
  end;

  TUploadFileParams = class(TJSONParam)
    /// <summary>
    /// Optional. Display name of the created document.
    /// </summary>
    function DisplayName(const Value: string): TUploadFileParams;

    /// <summary>
    /// Custom metadata to be associated with the data.
    /// </summary>
    function CustomMetadata(const Value: TArray<TCustomMetadata>): TUploadFileParams;

    /// <summary>
    /// Optional. Config for telling the service how to chunk the data. If not provided, the service will
    /// use default parameters.
    /// </summary>
    function ChunkingConfig(const Value: TChunkingConfig): TUploadFileParams;

    /// <summary>
    /// Optional. MIME type of the data. If not provided, it will be inferred from the uploaded content.
    /// </summary>
    function MimeType(const Value: string): TUploadFileParams;
  end;

  TImportFileParams = class(TJSONParam)
    /// <summary>
    /// Obligatoire. Nom du File à importer. Exemple : files/abc-123
    /// </summary>
    function FileName(const Value: string): TImportFileParams;

    /// <summary>
    /// Custom metadata to be associated with the file.
    /// </summary>
    function CustomMetadata(const Value: TArray<TCustomMetadata>): TImportFileParams;

    /// <summary>
    /// Optional. Config for telling the service how to chunk the file.
    /// </summary>
    /// <remarks>
    /// If not provided, the service will use default parameters.
    /// </remarks>
    function ChunkingConfig(const Value: TChunkingConfig): TImportFileParams;
  end;

  TFileSearchStore = class(TJSONFingerprint)
  private
    FName: string;
    FDisplayName: string;
    FCreateTime: string;
    FUpdateTime: string;
    FActiveDocumentsCount: Int64;
    FPendingDocumentsCount: Int64;
    FFailedDocumentsCount: Int64;
    FSizeBytes: Int64;
  public
    /// <summary>
    /// Immutable. Identifier. The FileSearchStore resource name.
    /// </summary>
    /// <remarks>
    /// It is an ID (name excluding the "fileSearchStores/" prefix) that can contain up to 40 characters
    /// that are lowercase alphanumeric or dashes (-). It is output only. The unique name will be derived
    /// from displayName along with a 12 character random suffix.
    /// <para>
    /// • Example: fileSearchStores/my-awesome-file-search-store-123a456b789c If displayName is not provided,
    /// the name will be randomly generated.
    /// </para>
    /// </remarks>
    property Name: string read FName write FName;

    /// <summary>
    /// The human-readable display name for the FileSearchStore.
    /// </summary>
    property DisplayName: string read FDisplayName write FDisplayName;

    /// <summary>
    /// The Timestamp of when the FileSearchStore was created.
    /// </summary>
    /// <remarks>
    /// Uses RFC 3339, where generated output will always be Z-normalized and use 0, 3, 6 or 9 fractional
    /// digits. Offsets other than "Z" are also accepted.
    /// <para>
    /// • Examples: "2014-10-02T15:01:23Z", "2014-10-02T15:01:23.045123456Z" or "2014-10-02T15:01:23+05:30".
    /// </para>
    /// </remarks>
    property CreateTime: string read FCreateTime write FCreateTime;

    /// <summary>
    /// The Timestamp of when the FileSearchStore was last updated.
    /// </summary>
    /// <remarks>
    /// Uses RFC 3339, where generated output will always be Z-normalized and use 0, 3, 6 or 9 fractional
    /// digits. Offsets other than "Z" are also accepted.
    /// <para>
    /// • Examples: "2014-10-02T15:01:23Z", "2014-10-02T15:01:23.045123456Z" or "2014-10-02T15:01:23+05:30".
    /// </para>
    /// </remarks>
    property UpdateTime: string read FUpdateTime write FUpdateTime;

    /// <summary>
    /// The number of documents in the FileSearchStore that are active and ready for retrieval.
    /// </summary>
    property ActiveDocumentsCount: Int64 read FActiveDocumentsCount write FActiveDocumentsCount;

    /// <summary>
    /// The number of documents in the FileSearchStore that are being processed.
    /// </summary>
    property PendingDocumentsCount: Int64 read FPendingDocumentsCount write FPendingDocumentsCount;

    /// <summary>
    /// The number of documents in the FileSearchStore that have failed processing.
    /// </summary>
    property FailedDocumentsCount: Int64 read FFailedDocumentsCount write FFailedDocumentsCount;

    /// <summary>
    /// The size of raw bytes ingested into the FileSearchStore.
    /// </summary>
    /// <remarks>
    /// This is the total size of all the documents in the FileSearchStore.
    /// </remarks>
    property SizeBytes: Int64 read FSizeBytes write FSizeBytes;
  end;

  TFileSearchStoreList = class(TJSONFingerprint)
  private
    FFileSearchStores: TArray<TFileSearchStore>;
    FNextPageToken: string;
  public
    /// <summary>
    /// The returned ragStores.
    /// </summary>
    property FileSearchStores: TArray<TFileSearchStore> read FFileSearchStores write FFileSearchStores;

    /// <summary>
    /// A token, which can be sent as pageToken to retrieve the next page. If this field is omitted,
    /// there are no more pages.
    /// </summary>
    property NextPageToken: string read FNextPageToken write FNextPageToken;

    destructor Destroy; override;
  end;

  TFileSearchStoreDelete = class(TJSONFingerprint)
  end;

  /// <summary>
  /// Asynchronous callback container for operations that return a <c>TFileSearchStore</c>.
  /// </summary>
  /// <remarks>
  /// <c>TAsynFileSearchStore</c> is an alias of <c>TAsynCallBack&lt;TFileSearchStore&gt;</c> and is used to
  /// configure the lifecycle callbacks for asynchronous File Search Store requests (for example,
  /// <c>Create</c> or <c>Retrieve</c>).
  /// <para>
  /// • Common handlers are <c>OnStart</c> (invoked when the asynchronous work begins), <c>OnSuccess</c>
  /// (invoked with the resulting <c>TFileSearchStore</c> instance), and <c>OnError</c> (invoked with an
  /// error message if the call fails).
  /// </para>
  /// <para>
  /// • The returned <c>TFileSearchStore</c> provides store metadata such as <c>Name</c>, <c>DisplayName</c>,
  /// timestamps, document counts, and raw ingested size.
  /// </para>
  /// </remarks>
  TAsynFileSearchStore = TAsynCallBack<TFileSearchStore>;

  /// <summary>
  /// Promise-style callback container for operations that return a <c>TFileSearchStore</c>.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseFileSearchStore</c> is an alias of <c>TPromiseCallback&lt;TFileSearchStore&gt;</c> and is
  /// intended for promise-based File Search Store endpoints (for example, async/await wrappers around
  /// <c>Create</c> or <c>Retrieve</c> operations).
  /// <para>
  /// • It allows callers to register lifecycle callbacks that may be invoked while the promise is pending
  /// and when it settles, either resolved with a <c>TFileSearchStore</c> instance or rejected with an
  /// error.
  /// </para>
  /// <para>
  /// • The resolved <c>TFileSearchStore</c> typically contains store metadata such as <c>Name</c>,
  /// <c>DisplayName</c>, timestamps, document counters, and ingested size.
  /// </para>
  /// <para>
  /// • This type only defines the callback bundle and does not execute any asynchronous work by itself.
  /// </para>
  /// </remarks>
  TPromiseFileSearchStore = TPromiseCallback<TFileSearchStore>;

  /// <summary>
  /// Asynchronous callback container for operations that return a <c>TFileSearchStoreDelete</c>.
  /// </summary>
  /// <remarks>
  /// <c>TAsynFileSearchStoreDelete</c> is an alias of <c>TAsynCallBack&lt;TFileSearchStoreDelete&gt;</c> and
  /// is used to configure the lifecycle callbacks for asynchronous File Search Store deletion requests
  /// (for example, <c>Delete</c> or <c>DeleteForced</c>).
  /// <para>
  /// • Common handlers are <c>OnStart</c> (invoked when the asynchronous work begins), <c>OnSuccess</c>
  /// (invoked when the delete request completes successfully and yields a <c>TFileSearchStoreDelete</c>
  /// marker instance), and <c>OnError</c> (invoked with an error message if the call fails).
  /// </para>
  /// <para>
  /// • <c>TFileSearchStoreDelete</c> is a compatibility/result marker type and typically carries no payload.
  /// </para>
  /// </remarks>
  TAsynFileSearchStoreDelete = TAsynCallBack<TFileSearchStoreDelete>;

  /// <summary>
  /// Promise-style callback container for operations that return a <c>TFileSearchStoreDelete</c>.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseFileSearchStoreDelete</c> is an alias of <c>TPromiseCallback&lt;TFileSearchStoreDelete&gt;</c>
  /// and is intended for promise-based File Search Store deletion endpoints (for example, async/await
  /// wrappers around <c>Delete</c> or <c>DeleteForced</c> operations).
  /// <para>
  /// • It allows callers to register lifecycle callbacks that may be invoked while the promise is pending
  /// and when it settles, either resolved with a <c>TFileSearchStoreDelete</c> marker instance or rejected
  /// with an error.
  /// </para>
  /// <para>
  /// • <c>TFileSearchStoreDelete</c> is a compatibility/result marker type and typically carries no payload.
  /// </para>
  /// <para>
  /// • This type only defines the callback bundle and does not execute any asynchronous work by itself.
  /// </para>
  /// </remarks>
  TPromiseFileSearchStoreDelete = TPromiseCallback<TFileSearchStoreDelete>;

  /// <summary>
  /// Asynchronous callback container for operations that return a <c>TFileSearchStoreList</c>.
  /// </summary>
  /// <remarks>
  /// <c>TAsynFileSearchStoreList</c> is an alias of <c>TAsynCallBack&lt;TFileSearchStoreList&gt;</c> and is used
  /// to configure the lifecycle callbacks for asynchronous File Search Store listing requests (for example,
  /// <c>List</c> with or without pagination parameters).
  /// <para>
  /// • Common handlers are <c>OnStart</c> (invoked when the asynchronous work begins), <c>OnSuccess</c> (invoked
  /// with the resulting <c>TFileSearchStoreList</c> instance), and <c>OnError</c> (invoked with an error message
  /// if the call fails).
  /// </para>
  /// <para>
  /// • The returned <c>TFileSearchStoreList</c> typically contains an array of <c>TFileSearchStore</c> items and may
  /// include a <c>NextPageToken</c> to continue pagination.
  /// </para>
  /// </remarks>
  TAsynFileSearchStoreList = TAsynCallBack<TFileSearchStoreList>;

  /// <summary>
  /// Promise-style callback container for operations that return a <c>TFileSearchStoreList</c>.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseFileSearchStoreList</c> is an alias of <c>TPromiseCallback&lt;TFileSearchStoreList&gt;</c> and is
  /// intended for promise-based File Search Store listing endpoints (for example, async/await wrappers around
  /// <c>List</c> operations with or without pagination parameters).
  /// <para>
  /// • It allows callers to register lifecycle callbacks that may be invoked while the promise is pending and when
  /// it settles, either resolved with a <c>TFileSearchStoreList</c> instance or rejected with an error.
  /// </para>
  /// <para>
  /// • The resolved <c>TFileSearchStoreList</c> typically contains a collection of <c>TFileSearchStore</c> items and
  /// may include a <c>NextPageToken</c> to retrieve the next page of results.
  /// </para>
  /// <para>
  /// • This type only defines the callback bundle and does not execute any asynchronous work by itself.
  /// </para>
  /// </remarks>
  TPromiseFileSearchStoreList = TPromiseCallback<TFileSearchStoreList>;

  TAbstractSupport = class(TGeminiAPIRoute)
  protected
    function Create(const ParamProc: TProc<TFileSearchStoreParams>): TFileSearchStore; virtual; abstract;

    function Delete(const VectorName: string): TFileSearchStoreDelete; virtual; abstract;

    function DeleteForced(const VectorName: string): TFileSearchStoreDelete; virtual; abstract;

    function Import(const VectorName: string; const ParamProc: TProc<TImportFileParams>): TOperation; virtual; abstract;

    function List: TFileSearchStoreList; overload; virtual; abstract;

    function List(const PageSize: Integer; const PageToken: string): TFileSearchStoreList; overload; virtual; abstract;

    function OperationsGet(const Name: string): TOperation; virtual; abstract;

    function Retrieve(const VectorName: string): TFileSearchStore; virtual; abstract;

    function Upload(const VectorName: string; const ParamProc: TProc<TUploadFileParams>): TOperation; virtual; abstract;
  end;

  TAsynchronousSupport = class(TAbstractSupport)
  protected
    procedure AsynCreate(
      const ParamProc: TProc<TFileSearchStoreParams>;
      const CallBacks: TFunc<TAsynFileSearchStore>);

    procedure AsynDelete(const VectorName: string;
      const CallBacks: TFunc<TAsynFileSearchStoreDelete>);

    procedure AsynDeleteForced(const VectorName: string;
      const CallBacks: TFunc<TAsynFileSearchStoreDelete>);

    procedure AsynImport(const VectorName: string;
      const ParamProc: TProc<TImportFileParams>;
      const CallBacks: TFunc<TAsynOperation>);

    procedure AsynList(
      const CallBacks: TFunc<TAsynFileSearchStoreList>); overload;

    procedure AsynList(const PageSize: Integer;
      const PageToken: string;
      const CallBacks: TFunc<TAsynFileSearchStoreList>); overload;

    procedure AsynOperationsGet(const Name: string;
      const CallBacks: TFunc<TAsynOperation>);

    procedure AsynRetrieve(const VectorName: string;
      const CallBacks: TFunc<TAsynFileSearchStore>);

    procedure AsynUpload(const VectorName: string;
      const ParamProc: TProc<TUploadFileParams>;
      const CallBacks: TFunc<TAsynOperation>);
  end;

  TVectorFilesRoute = class(TAsynchronousSupport)

    /// <summary>
    /// Synchronously creates an empty <c>FileSearchStore</c>.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the request parameters (for example, setting <c>displayName</c>).
    /// </param>
    /// <returns>
    /// The newly created <c>TFileSearchStore</c> instance returned by the service.
    /// </returns>
    /// <remarks>
    /// This is a synchronous (blocking) call. It corresponds to the File Search Store create endpoint and returns
    /// the server-assigned <c>Name</c> along with store metadata such as timestamps and document counters.
    /// For a non-blocking alternative, use <c>AsyncAwaitCreate</c> or <c>AsynCreate</c>.
    /// </remarks>
    function Create(const ParamProc: TProc<TFileSearchStoreParams>): TFileSearchStore; override;

    /// <summary>
    /// Synchronously deletes a <c>FileSearchStore</c>.
    /// </summary>
    /// <param name="VectorName">
    /// The File Search Store resource name to delete (for example, <c>fileSearchStores/my-store-...</c>).
    /// </param>
    /// <returns>
    /// A <c>TFileSearchStoreDelete</c> marker instance returned on successful deletion.
    /// </returns>
    /// <remarks>
    /// This is a synchronous (blocking) call. This method performs a standard delete. If the store still contains
    /// documents, the service may reject the request (for example, with a precondition failure). Use
    /// <c>DeleteForced</c> to delete a non-empty store and its associated documents, if supported by the service.
    /// For non-blocking alternatives, use <c>AsyncAwaitDelete</c> or <c>AsynDelete</c>.
    /// </remarks>
    function Delete(const VectorName: string): TFileSearchStoreDelete; override;

    /// <summary>
    /// Synchronously deletes a <c>FileSearchStore</c> and its contents.
    /// </summary>
    /// <param name="VectorName">
    /// The File Search Store resource name to delete (for example, <c>fileSearchStores/my-store-...</c>).
    /// </param>
    /// <returns>
    /// A <c>TFileSearchStoreDelete</c> marker instance returned on successful deletion.
    /// </returns>
    /// <remarks>
    /// This is a synchronous (blocking) call. This method performs a forced delete (typically equivalent to
    /// <c>force=true</c>), meaning that any documents contained in the store and associated resources are also
    /// deleted. Use with care, as the operation is destructive.
    /// For non-blocking alternatives, use <c>AsyncAwaitDeleteForced</c> or <c>AsynDeleteForced</c>.
    /// </remarks>
    function DeleteForced(const VectorName: string): TFileSearchStoreDelete; override;

    /// <summary>
    /// Synchronously imports an existing <c>File</c> resource into a <c>FileSearchStore</c>.
    /// </summary>
    /// <param name="VectorName">
    /// The target File Search Store resource name (for example, <c>fileSearchStores/my-store-...</c>).
    /// </param>
    /// <param name="ParamProc">
    /// A procedure used to configure the import request parameters (for example, setting <c>fileName</c>,
    /// optional <c>customMetadata</c>, and optional <c>chunkingConfig</c>).
    /// </param>
    /// <returns>
    /// A <c>TOperation</c> representing the long-running import operation.
    /// </returns>
    /// <remarks>
    /// This is a synchronous (blocking) call that starts the import request and returns the server-created
    /// long-running operation handle. The ingestion itself may continue after this call returns; poll the
    /// returned operation using <c>OperationsGet</c> until <c>Done</c> is <c>true</c>, then inspect <c>Error</c>
    /// or <c>Response</c>.
    /// For non-blocking alternatives, use <c>AsyncAwaitImport</c> or <c>AsynImport</c>.
    /// </remarks>
    function Import(const VectorName: string; const ParamProc: TProc<TImportFileParams>): TOperation; override;

    /// <summary>
    /// Synchronously retrieves the list of <c>FileSearchStore</c> resources.
    /// </summary>
    /// <returns>
    /// A <c>TFileSearchStoreList</c> instance containing the returned stores and possibly a <c>NextPageToken</c>.
    /// </returns>
    /// <remarks>
    /// This is a synchronous (blocking) call. This overload retrieves the default (non-paginated) list of stores.
    /// If the service returns a <c>NextPageToken</c>, call the paginated overload to continue listing subsequent pages.
    /// For non-blocking alternatives, use <c>AsyncAwaitList</c> or <c>AsynList</c>.
    /// </remarks>
    function List: TFileSearchStoreList; overload; override;

    /// <summary>
    /// Synchronously retrieves a paginated list of <c>FileSearchStore</c> resources.
    /// </summary>
    /// <param name="PageSize">
    /// The maximum number of File Search Stores to return in the response (per page).
    /// </param>
    /// <param name="PageToken">
    /// A token identifying the page of results to retrieve. This is typically obtained from a previous
    /// <c>TFileSearchStoreList</c> result via <c>NextPageToken</c>.
    /// </param>
    /// <returns>
    /// A <c>TFileSearchStoreList</c> instance containing the requested page of stores and possibly a
    /// <c>NextPageToken</c>.
    /// </returns>
    /// <remarks>
    /// This is a synchronous (blocking) call. Use this overload to page through store listings. Pass the
    /// <c>NextPageToken</c> from a previous response as <paramref name="PageToken"/> to retrieve the next page.
    /// For non-blocking alternatives, use the paginated <c>AsyncAwaitList</c> overload or <c>AsynList</c>.
    /// </remarks>
    function List(const PageSize: Integer; const PageToken: string): TFileSearchStoreList; overload; override;

    /// <summary>
    /// Synchronously retrieves the latest state of a long-running operation.
    /// </summary>
    /// <param name="Name">
    /// The operation resource name to retrieve (for example,
    /// <c>fileSearchStores/{store}/operations/{operation}</c> or
    /// <c>fileSearchStores/{store}/upload/operations/{operation}</c>).
    /// </param>
    /// <returns>
    /// The current <c>TOperation</c> state returned by the service.
    /// </returns>
    /// <remarks>
    /// This is a synchronous (blocking) call. Use it to poll an operation until <c>Done</c> becomes <c>true</c>,
    /// then inspect <c>Error</c> or <c>Response</c> as appropriate.
    /// For non-blocking alternatives, use <c>AsyncAwaitOperationsGet</c> or <c>AsynOperationsGet</c>.
    /// </remarks>
    function OperationsGet(const Name: string): TOperation; override;

    /// <summary>
    /// Synchronously retrieves a <c>FileSearchStore</c> by resource name.
    /// </summary>
    /// <param name="VectorName">
    /// The File Search Store resource name to retrieve (for example, <c>fileSearchStores/my-store-...</c>).
    /// </param>
    /// <returns>
    /// The retrieved <c>TFileSearchStore</c> instance returned by the service.
    /// </returns>
    /// <remarks>
    /// This is a synchronous (blocking) call. The returned <c>TFileSearchStore</c> typically includes store metadata
    /// such as <c>Name</c>, <c>DisplayName</c>, timestamps, document counters, and raw ingested size.
    /// For non-blocking alternatives, use <c>AsyncAwaitRetrieve</c> or <c>AsynRetrieve</c>.
    /// </remarks>
    function Retrieve(const VectorName: string): TFileSearchStore; override;

    /// <summary>
    /// Synchronously uploads data into a <c>FileSearchStore</c>.
    /// </summary>
    /// <param name="VectorName">
    /// The target File Search Store resource name (for example, <c>fileSearchStores/my-store-...</c>).
    /// </param>
    /// <param name="ParamProc">
    /// A procedure used to configure the upload request parameters (for example, setting <c>displayName</c>,
    /// optional <c>customMetadata</c>, optional <c>chunkingConfig</c>, and optional <c>mimeType</c>).
    /// </param>
    /// <returns>
    /// A <c>TOperation</c> representing the long-running upload and ingestion process.
    /// </returns>
    /// <remarks>
    /// This is a synchronous (blocking) call that initiates the upload request and returns the server-created
    /// long-running operation handle. The ingestion itself may continue after this call returns; poll the returned
    /// operation using <c>OperationsGet</c> until <c>Done</c> is <c>true</c>, then inspect <c>Error</c> or
    /// <c>Response</c>.
    /// For non-blocking alternatives, use <c>AsyncAwaitUpload</c> or <c>AsynUpload</c>.
    /// </remarks>
    function Upload(const VectorName: string; const ParamProc: TProc<TUploadFileParams>): TOperation; override;

    /// <summary>
    /// Asynchronously creates an empty <c>FileSearchStore</c> using a promise-based interface.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the request parameters (for example, setting <c>displayName</c>).
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function that returns a <c>TPromiseFileSearchStore</c> record containing lifecycle callbacks
    /// that may be invoked while the promise is pending and when it settles (success or error).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TFileSearchStore&gt;</c> that resolves with the created <c>TFileSearchStore</c> instance,
    /// or rejects with an exception on failure.
    /// </returns>
    /// <remarks>
    /// This method corresponds to the File Search Store create endpoint and returns the server-assigned store
    /// name along with metadata such as timestamps and document counters.
    /// </remarks>
    function AsyncAwaitCreate(
      const ParamProc: TProc<TFileSearchStoreParams>;
      const Callbacks: TFunc<TPromiseFileSearchStore> = nil): TPromise<TFileSearchStore>;

    /// <summary>
    /// Asynchronously deletes a <c>FileSearchStore</c> using a promise-based interface.
    /// </summary>
    /// <param name="VectorName">
    /// The File Search Store resource name to delete (for example, <c>fileSearchStores/my-store-...</c>).
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function that returns a <c>TPromiseFileSearchStoreDelete</c> record containing lifecycle
    /// callbacks that may be invoked while the promise is pending and when it settles (success or error).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TFileSearchStoreDelete&gt;</c> that resolves when the delete operation completes
    /// successfully, or rejects with an exception on failure.
    /// </returns>
    /// <remarks>
    /// This method performs a standard delete. If the store still contains documents, the service may reject
    /// the request (for example, with a precondition failure). Use <c>AsyncAwaitDeleteForced</c> when you want
    /// to delete a non-empty store and its associated documents, if supported by the service.
    /// </remarks>
    function AsyncAwaitDelete(const VectorName: string;
      const Callbacks: TFunc<TPromiseFileSearchStoreDelete> = nil): TPromise<TFileSearchStoreDelete>;

    /// <summary>
    /// Asynchronously deletes a <c>FileSearchStore</c> and its contents using a promise-based interface.
    /// </summary>
    /// <param name="VectorName">
    /// The File Search Store resource name to delete (for example, <c>fileSearchStores/my-store-...</c>).
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function that returns a <c>TPromiseFileSearchStoreDelete</c> record containing lifecycle
    /// callbacks that may be invoked while the promise is pending and when it settles (success or error).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TFileSearchStoreDelete&gt;</c> that resolves when the forced delete operation completes
    /// successfully, or rejects with an exception on failure.
    /// </returns>
    /// <remarks>
    /// This method performs a forced delete (typically equivalent to <c>force=true</c>), meaning that any
    /// documents contained in the store and associated resources are also deleted. Use with care, as the
    /// operation is destructive.
    /// </remarks>
    function AsyncAwaitDeleteForced(const VectorName: string;
      const Callbacks: TFunc<TPromiseFileSearchStoreDelete> = nil): TPromise<TFileSearchStoreDelete>;

    /// <summary>
    /// Asynchronously imports an existing <c>File</c> resource into a <c>FileSearchStore</c> using a promise-based interface.
    /// </summary>
    /// <param name="VectorName">
    /// The target File Search Store resource name (for example, <c>fileSearchStores/my-store-...</c>).
    /// </param>
    /// <param name="ParamProc">
    /// A procedure used to configure the import request parameters (for example, setting <c>fileName</c>,
    /// optional <c>customMetadata</c>, and optional <c>chunkingConfig</c>).
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function that returns a <c>TPromiseOperation</c> record containing lifecycle callbacks that may be
    /// invoked while the promise is pending and when it settles (success or error).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TOperation&gt;</c> that resolves with a <c>TOperation</c> representing the long-running import,
    /// or rejects with an exception on failure.
    /// </returns>
    /// <remarks>
    /// This method corresponds to the <c>fileSearchStores.importFile</c> endpoint. The returned <c>TOperation</c> can be
    /// polled via <c>AsyncAwaitOperationsGet</c> until <c>Done</c> becomes <c>true</c>, then inspected for <c>Error</c>
    /// or a successful <c>Response</c>.
    /// </remarks>
    function AsyncAwaitImport(const VectorName: string;
      const ParamProc: TProc<TImportFileParams>;
      const Callbacks: TFunc<TPromiseOperation> = nil): TPromise<TOperation>;

    /// <summary>
    /// Asynchronously retrieves the list of <c>FileSearchStore</c> resources using a promise-based interface.
    /// </summary>
    /// <param name="Callbacks">
    /// Optional. A function that returns a <c>TPromiseFileSearchStoreList</c> record containing lifecycle callbacks
    /// that may be invoked while the promise is pending and when it settles (success or error).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TFileSearchStoreList&gt;</c> that resolves with a <c>TFileSearchStoreList</c> instance containing
    /// the returned stores (and possibly a <c>NextPageToken</c>), or rejects with an exception on failure.
    /// </returns>
    /// <remarks>
    /// This overload retrieves the default (non-paginated) list of stores. If the service returns a
    /// <c>NextPageToken</c>, use the paginated overload to continue listing subsequent pages.
    /// </remarks>
    function AsyncAwaitList(
      const Callbacks: TFunc<TPromiseFileSearchStoreList> = nil): TPromise<TFileSearchStoreList>; overload;

    /// <summary>
    /// Asynchronously retrieves a paginated list of <c>FileSearchStore</c> resources using a promise-based interface.
    /// </summary>
    /// <param name="PageSize">
    /// The maximum number of File Search Stores to return in the response (per page).
    /// </param>
    /// <param name="PageToken">
    /// A token identifying the page of results to retrieve. This is typically obtained from a previous
    /// <c>TFileSearchStoreList</c> result via <c>NextPageToken</c>.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function that returns a <c>TPromiseFileSearchStoreList</c> record containing lifecycle callbacks
    /// that may be invoked while the promise is pending and when it settles (success or error).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TFileSearchStoreList&gt;</c> that resolves with a <c>TFileSearchStoreList</c> instance containing
    /// the requested page of stores (and possibly a <c>NextPageToken</c>), or rejects with an exception on failure.
    /// </returns>
    /// <remarks>
    /// Use this overload to page through store listings. Pass the <c>NextPageToken</c> from a previous response as
    /// <paramref name="PageToken"/> to retrieve the next page.
    /// </remarks>
    function AsyncAwaitList(const PageSize: Integer;
      const PageToken: string;
      const Callbacks: TFunc<TPromiseFileSearchStoreList> = nil): TPromise<TFileSearchStoreList>; overload;

    /// <summary>
    /// Asynchronously retrieves the latest state of a long-running operation using a promise-based interface.
    /// </summary>
    /// <param name="Name">
    /// The operation resource name to retrieve (for example,
    /// <c>fileSearchStores/{store}/operations/{operation}</c> or
    /// <c>fileSearchStores/{store}/upload/operations/{operation}</c>).
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function that returns a <c>TPromiseOperation</c> record containing lifecycle callbacks that may be
    /// invoked while the promise is pending and when it settles (success or error).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TOperation&gt;</c> that resolves with the current <c>TOperation</c> state, or rejects with an
    /// exception on failure.
    /// </returns>
    /// <remarks>
    /// This method corresponds to the operation polling endpoint. Use it to periodically query an operation until
    /// <c>Done</c> becomes <c>true</c>, then inspect <c>Error</c> or <c>Response</c> as appropriate.
    /// </remarks>
    function AsyncAwaitOperationsGet(const Name: string;
      const Callbacks: TFunc<TPromiseOperation> = nil): TPromise<TOperation>;

    /// <summary>
    /// Asynchronously retrieves a <c>FileSearchStore</c> by resource name using a promise-based interface.
    /// </summary>
    /// <param name="VectorName">
    /// The File Search Store resource name to retrieve (for example, <c>fileSearchStores/my-store-...</c>).
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function that returns a <c>TPromiseFileSearchStore</c> record containing lifecycle callbacks
    /// that may be invoked while the promise is pending and when it settles (success or error).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TFileSearchStore&gt;</c> that resolves with the retrieved <c>TFileSearchStore</c> instance,
    /// or rejects with an exception on failure.
    /// </returns>
    /// <remarks>
    /// The resolved <c>TFileSearchStore</c> typically includes store metadata such as <c>Name</c>, <c>DisplayName</c>,
    /// timestamps, document counters, and raw ingested size.
    /// </remarks>
    function AsyncAwaitRetrieve(const VectorName: string;
      const Callbacks: TFunc<TPromiseFileSearchStore> = nil): TPromise<TFileSearchStore>;

    /// <summary>
    /// Asynchronously uploads data into a <c>FileSearchStore</c> using a promise-based interface.
    /// </summary>
    /// <param name="VectorName">
    /// The target File Search Store resource name (for example, <c>fileSearchStores/my-store-...</c>).
    /// </param>
    /// <param name="ParamProc">
    /// A procedure used to configure the upload request parameters (for example, setting <c>displayName</c>,
    /// optional <c>customMetadata</c>, optional <c>chunkingConfig</c>, and optional <c>mimeType</c>).
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function that returns a <c>TPromiseOperation</c> record containing lifecycle callbacks that may be
    /// invoked while the promise is pending and when it settles (success or error).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TOperation&gt;</c> that resolves with a <c>TOperation</c> representing the long-running upload
    /// and ingestion process, or rejects with an exception on failure.
    /// </returns>
    /// <remarks>
    /// This method corresponds to the <c>uploadToFileSearchStore</c> endpoint (media upload). The returned
    /// <c>TOperation</c> can be polled via <c>AsyncAwaitOperationsGet</c> until <c>Done</c> becomes <c>true</c>, then
    /// inspected for <c>Error</c> or a successful <c>Response</c>.
    /// </remarks>
    function AsyncAwaitUpload(const VectorName: string;
      const ParamProc: TProc<TUploadFileParams>;
      const Callbacks: TFunc<TPromiseOperation> = nil): TPromise<TOperation>;

  end;

implementation

{ TFileSearchStoreParams }

function TFileSearchStoreParams.DisplayName(
  const Value: string): TFileSearchStoreParams;
begin
  Result := TFileSearchStoreParams(Add('displayName', Value));
end;

{ TVectorFilesRoute }

function TVectorFilesRoute.AsyncAwaitCreate(
  const ParamProc: TProc<TFileSearchStoreParams>;
  const Callbacks: TFunc<TPromiseFileSearchStore>): TPromise<TFileSearchStore>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TFileSearchStore>(
    procedure(const CallbackParams: TFunc<TAsynFileSearchStore>)
    begin
      Self.AsynCreate(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TVectorFilesRoute.AsyncAwaitDelete(const VectorName: string;
  const Callbacks: TFunc<TPromiseFileSearchStoreDelete>): TPromise<TFileSearchStoreDelete>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TFileSearchStoreDelete>(
    procedure(const CallbackParams: TFunc<TAsynFileSearchStoreDelete>)
    begin
      Self.AsynDelete(VectorName, CallbackParams);
    end,
    Callbacks);
end;

function TVectorFilesRoute.AsyncAwaitDeleteForced(const VectorName: string;
  const Callbacks: TFunc<TPromiseFileSearchStoreDelete>): TPromise<TFileSearchStoreDelete>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TFileSearchStoreDelete>(
    procedure(const CallbackParams: TFunc<TAsynFileSearchStoreDelete>)
    begin
      Self.AsynDeleteForced(VectorName, CallbackParams);
    end,
    Callbacks);
end;

function TVectorFilesRoute.AsyncAwaitImport(const VectorName: string;
  const ParamProc: TProc<TImportFileParams>;
  const Callbacks: TFunc<TPromiseOperation>): TPromise<TOperation>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TOperation>(
    procedure(const CallbackParams: TFunc<TAsynOperation>)
    begin
      Self.AsynImport(VectorName, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TVectorFilesRoute.AsyncAwaitList(const PageSize: Integer;
  const PageToken: string;
  const Callbacks: TFunc<TPromiseFileSearchStoreList>): TPromise<TFileSearchStoreList>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TFileSearchStoreList>(
    procedure(const CallbackParams: TFunc<TAsynFileSearchStoreList>)
    begin
      Self.AsynList(PageSize, PageToken, CallbackParams);
    end,
    Callbacks);
end;

function TVectorFilesRoute.AsyncAwaitList(
  const Callbacks: TFunc<TPromiseFileSearchStoreList>): TPromise<TFileSearchStoreList>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TFileSearchStoreList>(
    procedure(const CallbackParams: TFunc<TAsynFileSearchStoreList>)
    begin
      Self.AsynList(CallbackParams);
    end,
    Callbacks);
end;

function TVectorFilesRoute.AsyncAwaitOperationsGet(const Name: string;
  const Callbacks: TFunc<TPromiseOperation>): TPromise<TOperation>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TOperation>(
    procedure(const CallbackParams: TFunc<TAsynOperation>)
    begin
      Self.AsynOperationsGet(Name, CallbackParams);
    end,
    Callbacks);
end;

function TVectorFilesRoute.AsyncAwaitRetrieve(const VectorName: string;
  const Callbacks: TFunc<TPromiseFileSearchStore>): TPromise<TFileSearchStore>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TFileSearchStore>(
    procedure(const CallbackParams: TFunc<TAsynFileSearchStore>)
    begin
      Self.AsynRetrieve(VectorName, CallbackParams);
    end,
    Callbacks);
end;

function TVectorFilesRoute.AsyncAwaitUpload(const VectorName: string;
  const ParamProc: TProc<TUploadFileParams>;
  const Callbacks: TFunc<TPromiseOperation>): TPromise<TOperation>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TOperation>(
    procedure(const CallbackParams: TFunc<TAsynOperation>)
    begin
      Self.AsynUpload(VectorName, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TVectorFilesRoute.Create(
  const ParamProc: TProc<TFileSearchStoreParams>): TFileSearchStore;
begin
  Result := API.Post<TFileSearchStore, TFileSearchStoreParams>('fileSearchStores', ParamProc);
end;

function TVectorFilesRoute.Delete(const VectorName: string): TFileSearchStoreDelete;
begin
  Result := API.Delete<TFileSearchStoreDelete>(VectorName);
end;

function TVectorFilesRoute.DeleteForced(
  const VectorName: string): TFileSearchStoreDelete;
begin
  Result := API.Delete<TFileSearchStoreDelete>(VectorName, ParamsBuilder(True));
end;

function TVectorFilesRoute.Import(const VectorName: string;
  const ParamProc: TProc<TImportFileParams>): TOperation;
begin
  Result := API.Post<TOperation, TImportFileParams>(VectorName + ':importFile', ParamProc);
end;

function TVectorFilesRoute.List(const PageSize: Integer;
  const PageToken: string): TFileSearchStoreList;
begin
  Result := API.Get<TFileSearchStoreList>('fileSearchStores', ParamsBuilder(PageSize, PageToken));
end;

function TVectorFilesRoute.OperationsGet(const Name: string): TOperation;
begin
  Result := API.Get<TOperation>(Name);
end;

function TVectorFilesRoute.List: TFileSearchStoreList;
begin
  Result := API.Get<TFileSearchStoreList>('fileSearchStores');
end;

function TVectorFilesRoute.Retrieve(const VectorName: string): TFileSearchStore;
begin
   Result := API.Get<TFileSearchStore>( TVectorEndpoints.RequireStoreOnly(VectorName) );
end;

function TVectorFilesRoute.Upload(const VectorName: string;
  const ParamProc: TProc<TUploadFileParams>): TOperation;
begin
  TMonitor.Enter(API);
  try
    var VersionBase := API.Version;
    API.Version := 'upload/v1beta';
    try
      Result := API.Post<TOperation, TUploadFileParams>(VectorName + ':uploadToFileSearchStore', ParamProc);
    finally
      API.Version := VersionBase;
    end;
  finally
    TMonitor.Exit(API);
  end;
end;

{ TFileSearchStoreList }

destructor TFileSearchStoreList.Destroy;
begin
  for var Item in FFileSearchStores do
    Item.Free;
  inherited;
end;

{ TImportFileParams }

function TImportFileParams.ChunkingConfig(
  const Value: TChunkingConfig): TImportFileParams;
begin
  Result := TImportFileParams(Add('chunkingConfig', Value.Detach));
end;

function TImportFileParams.CustomMetadata(
  const Value: TArray<TCustomMetadata>): TImportFileParams;
begin
  Result := TImportFileParams(Add('customMetadata',
    TJSONHelper.ToJsonArray<TCustomMetadata>(Value)));
end;

function TImportFileParams.FileName(const Value: string): TImportFileParams;
begin
  Result := TImportFileParams(Add('fileName', Value));
end;

{ TCustomMetadata }

function TCustomMetadata.Key(const Value: string): TCustomMetadata;
begin
  Result := TCustomMetadata(Add('key', Value));
end;

function TCustomMetadata.NumericValue(const Value: Double): TCustomMetadata;
begin
  Result := TCustomMetadata(Add('numericValue', Value));
end;

function TCustomMetadata.StringListValue(const Value: TArray<string>): TCustomMetadata;
begin
  var JSONValues := TJSONParam.Create.Add('values', Value);

  Result := TCustomMetadata(Add('stringValue', JSONValues.Detach));
end;

function TCustomMetadata.StringValue(const Value: string): TCustomMetadata;
begin
  Result := TCustomMetadata(Add('stringValue', Value));
end;

{ TChunkingConfig }

function TChunkingConfig.MaxOverlapTokens(
  const Value: Integer): TChunkingConfig;
begin
  Result := TChunkingConfig(Add('maxOverlapTokens', Value));
end;

function TChunkingConfig.MaxTokensPerChunk(
  const Value: Integer): TChunkingConfig;
begin
  Result := TChunkingConfig(Add('maxTokensPerChunk', Value));
end;

{ TUploadFileParams }

function TUploadFileParams.ChunkingConfig(
  const Value: TChunkingConfig): TUploadFileParams;
begin
  Result := TUploadFileParams(Add('chunkingConfig', Value.Detach));
end;

function TUploadFileParams.CustomMetadata(
  const Value: TArray<TCustomMetadata>): TUploadFileParams;
begin
  Result := TUploadFileParams(Add('customMetadata',
    TJSONHelper.ToJsonArray<TCustomMetadata>(Value)));
end;

function TUploadFileParams.DisplayName(const Value: string): TUploadFileParams;
begin
  Result := TUploadFileParams(Add('displayName', Value));
end;

function TUploadFileParams.MimeType(const Value: string): TUploadFileParams;
begin
  Result := TUploadFileParams(Add('mimeType', Value));
end;

{ TAsynchronousSupport }

procedure TAsynchronousSupport.AsynCreate(
  const ParamProc: TProc<TFileSearchStoreParams>;
  const CallBacks: TFunc<TAsynFileSearchStore>);
begin
  with TAsynCallBackExec<TAsynFileSearchStore, TFileSearchStore>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFileSearchStore
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TAsynchronousSupport.AsynDelete(const VectorName: string;
  const CallBacks: TFunc<TAsynFileSearchStoreDelete>);
begin
  with TAsynCallBackExec<TAsynFileSearchStoreDelete, TFileSearchStoreDelete>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFileSearchStoreDelete
      begin
        Result := Self.Delete(VectorName);
      end);
  finally
    Free;
  end;
end;

procedure TAsynchronousSupport.AsynDeleteForced(const VectorName: string;
  const CallBacks: TFunc<TAsynFileSearchStoreDelete>);
begin
  with TAsynCallBackExec<TAsynFileSearchStoreDelete, TFileSearchStoreDelete>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFileSearchStoreDelete
      begin
        Result := Self.DeleteForced(VectorName);
      end);
  finally
    Free;
  end;
end;

procedure TAsynchronousSupport.AsynImport(const VectorName: string;
  const ParamProc: TProc<TImportFileParams>;
  const CallBacks: TFunc<TAsynOperation>);
begin
  with TAsynCallBackExec<TAsynOperation, TOperation>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TOperation
      begin
        Result := Self.Import(VectorName, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TAsynchronousSupport.AsynList(
  const CallBacks: TFunc<TAsynFileSearchStoreList>);
begin
  with TAsynCallBackExec<TAsynFileSearchStoreList, TFileSearchStoreList>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFileSearchStoreList
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

procedure TAsynchronousSupport.AsynList(const PageSize: Integer;
  const PageToken: string; const CallBacks: TFunc<TAsynFileSearchStoreList>);
begin
  with TAsynCallBackExec<TAsynFileSearchStoreList, TFileSearchStoreList>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFileSearchStoreList
      begin
        Result := Self.List(PageSize, PageToken);
      end);
  finally
    Free;
  end;
end;

procedure TAsynchronousSupport.AsynOperationsGet(const Name: string;
  const CallBacks: TFunc<TAsynOperation>);
begin
  with TAsynCallBackExec<TAsynOperation, TOperation>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TOperation
      begin
        Result := Self.OperationsGet(Name);
      end);
  finally
    Free;
  end;
end;

procedure TAsynchronousSupport.AsynRetrieve(const VectorName: string;
  const CallBacks: TFunc<TAsynFileSearchStore>);
begin
  with TAsynCallBackExec<TAsynFileSearchStore, TFileSearchStore>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFileSearchStore
      begin
        Result := Self.Retrieve(VectorName);
      end);
  finally
    Free;
  end;
end;

procedure TAsynchronousSupport.AsynUpload(const VectorName: string;
  const ParamProc: TProc<TUploadFileParams>;
  const CallBacks: TFunc<TAsynOperation>);
begin
  with TAsynCallBackExec<TAsynOperation, TOperation>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TOperation
      begin
        Result := Self.Upload(VectorName, ParamProc);
      end);
  finally
    Free;
  end;
end;

end.
