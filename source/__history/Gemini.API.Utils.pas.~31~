unit Gemini.API.Utils;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections;

const
  FIELDSASSTRING : TArray<string> = [
    '"args": {', '"args":{',
    '"response": {', '"response":{',
    '"metadata": {', '"metadata":{',
    '"partMetadata": {', '"partMetadata":{',
    '"arguments": {', '"arguments":{',
    '"result": {', '"result":{'
  ];

{$REGION 'Dev note'}
(*
   --- NOTE ---
    Each entry in this array corresponds to a  JSON field that is temporarily
    treated as  a string  during  parsing. In order  for these  fields  to be
    correctly restored as JSON objects upon re-marshalling, each unique field
    listed here must have a dedicated interceptor  that transforms the string
    back into a well-formed JSON object.

    Example: TMetadataInterceptor

      procedure TMetadataInterceptor.StringReverter(Data: TObject; Field,
        Arg: string);
      begin
        Arg := Format('{%s}', [Trim(Arg.Replace('`', '"').Replace(#10, ''))]);
        while Arg.Contains(', ') do Arg := Arg.Replace(', ', ',');
        RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, Arg.Replace(',', ', '));
      end;
*)
{$ENDREGION}

type
  /// <summary>
  /// Provides a mechanism for converting or transforming specific JSON fields in a string
  /// before deserialization. Typically used to handle scenarios where certain fields
  /// contain complex or nested structures that need to be converted into valid JSON.
  /// </summary>
  /// <remarks>
  /// <para>
  /// Implementations of this interface can adjust the JSON string prior to the deserialization
  /// process to address inconsistencies, remove or replace invalid characters, or convert
  /// problematic JSON fields into formats that a JSON deserializer can handle properly.
  /// </para>
  /// <para>
  /// For example, the implementation may detect fields named "metadata" and convert their
  /// content from a raw, non-standard structure into a valid JSON string by replacing certain
  /// delimiters or escape characters.
  /// </para>
  /// </remarks>
  ICustomFieldsPrepare = interface
    ['{B09FEEBA-747E-4E6E-B916-ECBEC2467415}']
    /// <summary>
    /// Converts or transforms specified fields in the provided JSON string to ensure
    /// deserialization compatibility.
    /// </summary>
    /// <param name="Value">
    /// The raw JSON string containing fields that may require transformation.
    /// </param>
    /// <returns>
    /// A revised JSON string after applying the necessary field conversions or
    /// transformations.
    /// </returns>
    function Convert(const Value: string): string; overload;
  end;

  /// <summary>
  /// Implements the <c>ICustomFieldsPrepare</c> interface to transform specific JSON fields
  /// before deserialization. The class applies rules for handling particular fields that may
  /// contain nested objects or invalid characters, ensuring the resulting JSON is valid and
  /// ready for further processing.
  /// </summary>
  /// <remarks>
  /// <para>
  /// This class is most commonly used to modify JSON fields such as "metadata" that might
  /// otherwise cause errors during deserialization. It replaces problematic delimiters and
  /// characters (like quotation marks or braces) within specified field blocks, enabling
  /// compliant JSON output.
  /// </para>
  /// <para>
  /// <c>TDeserializationPrepare</c> scans the JSON string for patterns and adjusts the content
  /// accordingly, preventing typical parsing exceptions arising from malformed or unexpected
  /// inline structures.
  /// </para>
  /// </remarks>
  TDeserializationPrepare = class(TInterfacedObject, ICustomFieldsPrepare)
  private
    /// <summary>
    /// Searches for a single specified field in the JSON string and updates its content
    /// to ensure valid JSON syntax. Replaces certain delimiters and characters inside
    /// the field's scope with safe alternatives.
    /// </summary>
    /// <param name="Value">
    /// The entire JSON string being scanned.
    /// </param>
    /// <param name="Field">
    /// The name of the field whose content needs to be transformed.
    /// </param>
    /// <returns>
    /// A modified JSON string with the specified field's content replaced as necessary.
    /// </returns>
    /// <remarks>
    /// <para>
    /// This overload specifically handles updating a single <c>Field</c>. If multiple fields
    /// need to be processed, consider using the array overload of this method.
    /// </para>
    /// </remarks>
    function UpdateFieldValue(const Value, Field: string): string; overload;

    /// <summary>
    /// Scans the JSON string for multiple specified fields and updates each of their
    /// contents to ensure valid JSON syntax. Replaces certain delimiters and characters
    /// inside the scope of these fields with safe alternatives.
    /// </summary>
    /// <param name="Value">
    /// The entire JSON string being scanned.
    /// </param>
    /// <param name="Field">
    /// An array of field names whose content must be transformed.
    /// </param>
    /// <returns>
    /// A modified JSON string with each listed field’s content replaced as necessary.
    /// </returns>
    /// <remarks>
    /// <para>
    /// This overload iterates through each field name in <c>Field</c> and applies the
    /// transformations one by one. If you need to handle only a single field, use the
    /// other <c>UpdateFieldValue</c> method.
    /// </para>
    /// </remarks>
    function UpdateFieldValue(const Value: string; const Field: TArray<string>): string; overload;
  public
    /// <summary>
    /// Scans and modifies the input JSON string to replace fields that contain nested
    /// objects or invalid characters, ensuring the JSON is suitable for deserialization.
    /// </summary>
    /// <param name="Value">
    /// The original JSON string needing transformation.
    /// </param>
    /// <returns>
    /// A revised JSON string after applying all necessary field modifications.
    /// </returns>
    /// <remarks>
    /// <para>
    /// The conversion logic is determined by which fields or patterns are defined
    /// within the implementation. Currently, the class targets fields labeled
    /// <c>"metadata"</c>, converting them from non-standard structures into proper
    /// JSON-friendly strings.
    /// </para>
    /// </remarks>
    function Convert(const Value: string): string;

    /// <summary>
    /// Factory method for creating an instance of the <c>TDeserializationPrepare</c> class.
    /// Returns an interface reference to <c>ICustomFieldsPrepare</c>.
    /// </summary>
    /// <returns>
    /// A newly constructed <c>TDeserializationPrepare</c> object as <c>ICustomFieldsPrepare</c>.
    /// </returns>
    /// <remarks>
    /// This method hides the constructor, enforcing interface-based usage.
    /// </remarks>
    class function CreateInstance: ICustomFieldsPrepare;
  end;

    TJsonPolyShield = record
  public
    const S_QUOTE  = Char($E000); // replace "
    const S_BSLASH = Char($E001); // replace \
    const S_KIND_O = Char($E010); // objet
    const S_KIND_A = Char($E011); // array

    class function Prepare(const Json: string; const Keys: array of string): string; static;
    class function Unshield(const Shielded: string): string; static;

  private
    class function ReadJsonString(const S: string; var I: Integer; out Text: string): Boolean; static;
    class procedure SkipSpaces(const S: string; var I: Integer); static;
    class function FindBlockEnd(const S: string; StartIdx: Integer): Integer; static;
    class function InSet(const Key: string; const SetKeys: TDictionary<string, Byte>): Boolean; static;
  end;

  TJsonPolyUnshield = record
  public
    class function Restore(const Arg: string): string; static;
  end;

implementation

{ TDeserializationPrepare }

function TDeserializationPrepare.UpdateFieldValue(const Value,
  Field: string): string;
begin
  Result := Value;
  var i := Pos(Field, Result);
  while (i > 0) and (i < Result.Length) do
    begin
      i := i + Field.Length - 1;
      Result[i] := '"';
      Inc(i);
      var j := 0;
      while (j > 0) or ((j = 0) and not (Result[i] = '}')) do
        begin
          case Result[i] of
            '{':
              Inc(j);
            '}':
              j := j - 1;
            '"':
              Result[i] := '`';
          end;
          Inc(i);
          if i > Result.Length then
            raise Exception.Create('Invalid JSON string');
        end;
      Result[i] := '"';
      i := Pos(Field, Result);
    end;
end;

class function TDeserializationPrepare.CreateInstance: ICustomFieldsPrepare;
begin
  Result := TDeserializationPrepare.Create;
end;

function TDeserializationPrepare.Convert(const Value: string): string;
begin
//  Result := UpdateFieldValue(Value, FIELDSASSTRING);
  Result := TJsonPolyShield.Prepare(Value, ['args','response','metadata','partMetadata','arguments','result']);
end;

function TDeserializationPrepare.UpdateFieldValue(const Value: string;
  const Field: TArray<string>): string;
begin
  Result := Value;
  if Length(Field) > 0 then
    begin
      for var Item in Field do
        Result := UpdateFieldValue(Result, Item);
    end;
end;

{ TJsonPolyShield }

class function TJsonPolyShield.InSet(const Key: string; const SetKeys: TDictionary<string, Byte>): Boolean;
begin
  Result := SetKeys.ContainsKey(Key);
end;

class procedure TJsonPolyShield.SkipSpaces(const S: string; var I: Integer);
begin
  while (I <= S.Length) and (S[I] <= ' ') do
    Inc(I);
end;

// Lit une string JSON à partir de S[I] = '"', renvoie le texte décodé "minimalement"
// Ici on veut juste la clé, donc on récupère le contenu brut en gérant \" et \\ pour ne pas couper trop tôt.
class function TJsonPolyShield.ReadJsonString(const S: string; var I: Integer; out Text: string): Boolean;
var
  sb: TStringBuilder;
  esc: Boolean;
begin
  Result := False;
  Text := '';

  if (I > S.Length) or (S[I] <> '"') then
    Exit;

  sb := TStringBuilder.Create;
  try
    Inc(I); // saute le "
    esc := False;

    while I <= S.Length do
      begin
        if esc then
          begin
            // On conserve le caractère tel quel; pour la clé, ça suffit.
            sb.Append(S[I]);
            esc := False;
          end
        else
          begin
            if S[I] = '\' then
              esc := True
            else if S[I] = '"' then
              begin
                Inc(I); // consomme le "
                Text := sb.ToString;
                Exit(True);
              end
            else
              sb.Append(S[I]);
          end;
        Inc(I);
      end;

    // pas de fermeture
    Exit(False);
  finally
    sb.Free;
  end;
end;

class function TJsonPolyShield.FindBlockEnd(const S: string; StartIdx: Integer): Integer;
var
  i: Integer;
  inStr, esc: Boolean;
  braceDepth, bracketDepth: Integer;
begin
  i := StartIdx;
  inStr := False;
  esc := False;
  braceDepth := 0;
  bracketDepth := 0;

  case S[i] of
    '{': braceDepth := 1;
    '[': bracketDepth := 1;
  else
    raise Exception.Create('StartIdx must point to { or [');
  end;

  Inc(i);

  while i <= S.Length do
    begin
      if inStr then
        begin
          if esc then
            esc := False
          else
            begin
              if S[i] = '\' then esc := True
              else if S[i] = '"' then inStr := False;
            end;
        end
      else
        begin
          case S[i] of
            '"': inStr := True;
            '{': Inc(braceDepth);
            '}': Dec(braceDepth);
            '[': Inc(bracketDepth);
            ']': Dec(bracketDepth);
          end;

          if (braceDepth = 0) and (bracketDepth = 0) then
            Exit(i);
        end;

      Inc(i);
    end;

  raise Exception.Create('Invalid JSON string (unclosed block)');
end;

class function TJsonPolyShield.Prepare(const Json: string; const Keys: array of string): string;
var
  dict: TDictionary<string, Byte>;
  sb: TStringBuilder;
  i, n: Integer;
  key: string;
  keyStart, afterKey, j, blockEnd: Integer;
  kind: Char;
begin
  dict := TDictionary<string, Byte>.Create;
  try
    // whitelist
    for var k in Keys do
      if k <> '' then
        dict.AddOrSetValue(k, 0);

    sb := TStringBuilder.Create(Json.Length + 64);
    try
      i := 1;
      n := Json.Length;

      while i <= n do
        begin
          // Copie brute jusqu'à éventuellement tomber sur une string (début de clé potentielle)
          if Json[i] <> '"' then
            begin
              sb.Append(Json[i]);
              Inc(i);
              Continue;
            end;

          // Tentative: lire une string JSON (clé potentielle)
          keyStart := i;
          afterKey := i;
          if not ReadJsonString(Json, afterKey, key) then
            begin
              // string mal formée, on copie le reste tel quel
              sb.Append(Copy(Json, i, n - i + 1));
              Break;
            end;

          // On ne sait pas si c'est une clé ou une valeur. On regarde après la string:
          j := afterKey;
          SkipSpaces(Json, j);

          if (j <= n) and (Json[j] = ':') and InSet(key, dict) then
            begin
              // C'est une clé whitelistée: on regarde la valeur
              Inc(j); // saute ':'
              SkipSpaces(Json, j);

              if (j <= n) and CharInSet(Json[j], ['{', '[']) then
                begin
                  // 1) recopier '"key"' + espaces + ':' + espaces tels qu'ils étaient
                  sb.Append(Copy(Json, keyStart, j - keyStart));

                  // 2) shield du bloc {..} ou [..] => " + kind + contenu shieldé + "
                  if Json[j] = '{' then
                    kind := S_KIND_O
                  else
                    kind := S_KIND_A;

                  blockEnd := FindBlockEnd(Json, j);

                  sb.Append('"');
                  sb.Append(kind);

                  // contenu interne = Json[j+1 .. blockEnd-1], en shieldant " et \
                  for var p := j + 1 to blockEnd - 1 do
                    begin
                      case Json[p] of
                        '"': sb.Append(S_QUOTE);
                        '\': sb.Append(S_BSLASH);
                      else
                        sb.Append(Json[p]);
                      end;
                    end;

                  sb.Append('"');

                  i := blockEnd + 1;
                  Continue;
                end;
            end;

          // Sinon: on recopie la string telle qu'elle était
          sb.Append(Copy(Json, keyStart, afterKey - keyStart));
          i := afterKey;
        end;

      Result := sb.ToString;
    finally
      sb.Free;
    end;
  finally
    dict.Free;
  end;
end;

class function TJsonPolyShield.Unshield(const Shielded: string): string;
begin
  Result := Shielded
    .Replace(string(S_QUOTE), '"')
    .Replace(string(S_BSLASH), '\');
end;

{ TJsonPolyUnshield }

class function TJsonPolyUnshield.Restore(const Arg: string): string;
var
  s: string;
  kind: Char;
begin
  s := Arg.Replace(#10, '').Trim;
  s := TJsonPolyShield.Unshield(s);

  // normalisation comme toi (optionnel)
  while s.Contains(', ') do
    s := s.Replace(', ', ',');

  if (s <> '') and ((s[1] = TJsonPolyShield.S_KIND_O) or (s[1] = TJsonPolyShield.S_KIND_A)) then
    begin
      kind := s[1];
      Delete(s, 1, 1);
    end
  else
    kind := TJsonPolyShield.S_KIND_O; // fallback legacy

  if kind = TJsonPolyShield.S_KIND_A then
    Result := Format('[%s]', [s])
  else
    Result := Format('{%s}', [s]);

  Result := Result.Replace(',', ', ');
end;

end.
