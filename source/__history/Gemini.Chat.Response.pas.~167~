unit Gemini.Chat.Response;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.JSON,
  REST.JsonReflect, REST.Json.Types,
  Gemini.API.Params, Gemini.Types, Gemini.Safety, Gemini.Schema, Gemini.GoogleSearch;

type
  TFunctionCallPart = class
  private
    FId: string;
    FName: string;
    [JsonReflectAttribute(ctString, rtString, TArgsFixInterceptor)]
    FArgs: string;
  public
    /// <summary>
    /// Optional. The unique id of the function call. If populated, the client to execute the functionCall
    /// and return the response with the matching id.
    /// </summary>
    property Id: string read FId write FId;

    /// <summary>
    /// Required. The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
    /// </summary>
    property Name: string read FName write FName;

    /// <summary>
    /// Optional. The function parameters and values in JSON object format.
    /// </summary>
    property Args: string read FArgs write FArgs;
  end;

  TInlineDataPart = class
  private
    FMimeType: string;
    FData: string;
  public
    /// <summary>
    /// The IANA standard MIME type of the source data.
    /// </summary>
    property MimeType: string read FMimeType write FMimeType;

    /// <summary>
    /// Raw bytes for media formats.
    /// </summary>
    property Data: string read FData write FData;
  end;

  TFileDataPart = class
  private
    FMimeType: string;
    FFileUri: string;
  public
    /// <summary>
    /// The IANA standard MIME type of the source data.
    /// </summary>
    property MimeType: string read FMimeType write FMimeType;

    /// <summary>
    /// Uri of the data
    /// </summary>
    property FileUri: string read FFileUri write FFileUri;
  end;

  TFunctionResponseBlob = class
  private
    FMimeType: string;
    FData: string;
  public
    /// <summary>
    /// The IANA standard MIME type of the source data.
    /// </summary>
    property MimeType: string read FMimeType write FMimeType;

    /// <summary>
    /// Raw bytes for media formats.
    /// </summary>
    property Data: string read FData write FData;
  end;

  TFunctionResponsePartItem = class
  private
    FInlineData: TFunctionResponseBlob;
  public
    /// <summary>
    /// Inline media bytes.
    /// </summary>
    property InlineData: TFunctionResponseBlob read FInlineData write FInlineData;

    destructor Destroy; override;
  end;

  TFunctionResponsePart = class
  private
    FId: string;
    FName: string;
    [JsonReflectAttribute(ctString, rtString, TArgsFixInterceptor)]
    FResponse: string;
    FParts: TArray<TFunctionResponsePartItem>;
    FWillContinue: Boolean;
    [JsonReflectAttribute(ctString, rtString, TSchedulingTypeInterceptor)]
    FScheduling: TSchedulingType;
  public
    /// <summary>
    /// Optional. The id of the function call this response is for. Populated by the client to match
    /// the corresponding function call id.
    /// </summary>
    property Id: string read FId write FId;

    /// <summary>
    /// Required. The name of the function to call.
    /// </summary>
    /// <remarks>
    /// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
    /// </remarks>
    property Name: string read FName write FName;

    /// <summary>
    /// Required. The function response in JSON object format.
    /// </summary>
    property Response: string read FResponse write FResponse;

    /// <summary>
    /// Optional. Ordered Parts that constitute a function response. Parts may have different IANA MIME types.
    /// </summary>
    property Parts: TArray<TFunctionResponsePartItem> read FParts write FParts;

    /// <summary>
    /// Optional. Signals that function call continues, and more responses will be returned, turning
    /// the function call into a generator.
    /// </summary>
    /// <remarks>
    /// Is only applicable to NON_BLOCKING function calls, is ignored otherwise. If set to false, future
    /// responses will not be considered. It is allowed to return empty response with willContinue=False
    /// to signal that the function call is finished. This may still trigger the model generation.
    /// <para>
    /// • To avoid triggering the generation and finish the function call, additionally set scheduling to SILENT.
    /// </para>
    /// </remarks>
    property WillContinue: Boolean read FWillContinue write FWillContinue;

    /// <summary>
    /// Optional. Specifies how the response should be scheduled in the conversation.
    /// </summary>
    /// <remarks>
    /// Only applicable to NON_BLOCKING function calls, is ignored otherwise. Defaults to WHEN_IDLE.
    /// </remarks>
    property Scheduling: TSchedulingType read FScheduling write FScheduling;

    destructor Destroy; override;
  end;

  TExecutableCodePart = class
  private
    [JsonReflectAttribute(ctString, rtString, TLanguageTypeInterceptor)]
    FLanguage: TLanguageType;
    FCode: string;
  public
    /// <summary>
    /// Required. Programming language of the code.
    /// </summary>
    property Language: TLanguageType read FLanguage write FLanguage;

    /// <summary>
    /// Required. The code to be executed.
    /// </summary>
    property Code: string read FCode write FCode;
  end;

  TCodeExecutionResult = class
  private
    [JsonReflectAttribute(ctString, rtString, TOutcomeTypeInterceptor)]
    FOutcome: TOutcomeType;
    FOutput: string;
  public
    /// <summary>
    /// Required. Outcome of the code execution.
    /// </summary>
    property Outcome: TOutcomeType read FOutcome write FOutcome;

    /// <summary>
    /// Optional. Contains stdout when code execution is successful, stderr or other description otherwise.
    /// </summary>
    property Output: string read FOutput write FOutput;
  end;

  TVideoMetadata = class
  private
    FStartOffset: string;
    FEndOffset: string;
    FFps: Double;
  public
    /// <summary>
    /// Optional. The start offset of the video.
    /// </summary>
    /// <remarks>
    /// A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
    /// </remarks>
    property StartOffset: string read FStartOffset write FStartOffset;

    /// <summary>
    /// Optional. The end offset of the video.
    /// </summary>
    /// <remarks>
    /// A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
    /// </remarks>
    property EndOffset: string read FEndOffset write FEndOffset;

    /// <summary>
    /// Optional. The frame rate of the video sent to the model.
    /// </summary>
    /// <remarks>
    ///  If not specified, the default value will be 1.0. The fps range is (0.0, 24.0].
    /// </remarks>
    property Fps: Double read FFps write FFps;
  end;

  TChatPart = class
  private
    FThought: Boolean;
    FThoughtSignature: string;
    [JsonReflectAttribute(ctString, rtString, TArgsFixInterceptor)]
    FPartMetadata: string;
    FText: string;
    FInlineData: TInlineDataPart;
    FFunctionCall: TFunctionCallPart;
    FFunctionResponse: TFunctionResponsePart;
    FFileData: TFileDataPart;
    FExecutableCode: TExecutableCodePart;
    FCodeExecutionResult: TCodeExecutionResult;
    FVideoMetadata: TVideoMetadata;
  public
    /// <summary>
    /// Optional. Indicates if the part is thought from the model.
    /// </summary>
    property Thought: Boolean read FThought write FThought;

    /// <summary>
    /// Optional. An opaque signature for the thought so it can be reused in subsequent requests.
    /// </summary>
    /// <remarks>
    /// A base64-encoded string.
    /// </remarks>
    property ThoughtSignature: string read FThoughtSignature write FThoughtSignature;

    /// <summary>
    /// Custom metadata associated with the Part. Agents using genai.Part as content representation may
    /// need to keep track of the additional information.
    /// </summary>
    /// <remarks>
    /// For example it can be name of a file/source from which the Part originates or a way to multiplex
    /// multiple Part streams.
    /// </remarks>
    property PartMetadata: string read FPartMetadata write FPartMetadata;

    /// <summary>
    /// Inline text.
    /// </summary>
    property Text: string read FText write FText;

    /// <summary>
    /// A predicted FunctionCall returned from the model that contains a string representing the FunctionDeclaration.name with the arguments and their values.
    /// </summary>
    property FunctionCall: TFunctionCallPart read FFunctionCall write FFunctionCall;

    /// <summary>
    /// The result output of a FunctionCall that contains a string representing the FunctionDeclaration.name and a structured JSON object containing any output from the function is used as context to the model.
    /// </summary>
    property FunctionResponse: TFunctionResponsePart read FFunctionResponse write FFunctionResponse;

    /// <summary>
    /// Inline media bytes.
    /// </summary>
    property InlineData: TInlineDataPart read FInlineData write FInlineData;

    /// <summary>
    /// URI based data.
    /// </summary>
    property FileData: TFileDataPart read FFileData write FFileData;

    /// <summary>
    /// Code generated by the model that is meant to be executed.
    /// </summary>
    property ExecutableCode: TExecutableCodePart read FExecutableCode write FExecutableCode;

    /// <summary>
    /// Result of executing the ExecutableCode.
    /// </summary>
    property CodeExecutionResult: TCodeExecutionResult read FCodeExecutionResult write FCodeExecutionResult;

    /// <summary>
    /// Optional. The producer of the content.
    /// </summary>
    /// <remarks>
    /// Must be either 'user' or 'model'. Useful to set for multi-turn conversations, otherwise can be left
    /// blank or unset.
    /// </remarks>
    property VideoMetadata: TVideoMetadata read FVideoMetadata write FVideoMetadata;

    destructor Destroy; override;
  end;

  TChatContent = class
  private
    FParts: TArray<TChatPart>;
    [JsonReflectAttribute(ctString, rtString, TMessageRoleInterceptor)]
    FRole: TMessageRole;
  public
    /// <summary>
    /// Ordered Parts that constitute a single message. Parts may have different MIME types.
    /// </summary>
    property Parts: TArray<TChatPart> read FParts write FParts;

    /// <summary>
    /// Optional. The producer of the content. Must be either 'user' or 'model'.
    /// </summary>
    /// <remarks>
    /// Useful to set for multi-turn conversations, otherwise can be left blank or unset.
    /// </remarks>
    property Role: TMessageRole read FRole write FRole;

    destructor Destroy; override;
  end;

  TSafetyRatings = class
  private
    [JsonReflectAttribute(ctString, rtString, THarmCategoryInterceptor)]
    FCategory: THarmCategory;
    [JsonReflectAttribute(ctString, rtString, THarmProbabilityInterceptor)]
    FProbability: THarmProbability;
    FBlocked: Boolean;
  public
    /// <summary>
    /// Required. The category for this rating.
    /// </summary>
    property Category: THarmCategory read FCategory write FCategory;

    /// <summary>
    /// Required. The probability of harm for this content.
    /// </summary>
    property Probability: THarmProbability read FProbability write FProbability;

    /// <summary>
    /// Was this content blocked because of this rating?
    /// </summary>
    property Blocked: Boolean read FBlocked write FBlocked;
  end;

  TCitationSource = class
  private
    FStartIndex: Int64;
    FEndIndex: Int64;
    FUri: string;
    FLicense: string;
  public
    /// <summary>
    /// Optional. Start of segment of the response that is attributed to this source.
    /// </summary>
    /// <remarks>
    /// Index indicates the start of the segment, measured in bytes
    /// </remarks>
    property StartIndex: Int64 read FStartIndex write FStartIndex;

    /// <summary>
    /// Optional. End of the attributed segment, exclusive.
    /// </summary>
    property EndIndex: Int64 read FEndIndex write FEndIndex;

    /// <summary>
    /// Optional. URI that is attributed as a source for a portion of the text.
    /// </summary>
    property Uri: string read FUri write FUri;

    /// <summary>
    /// Optional. License for the GitHub project that is attributed as a source for segment.
    /// </summary>
    /// <remarks>
    /// License info is required for code citations.
    /// </remarks>
    property License: string read FLicense write FLicense;
  end;

  TCitationMetadata = class
  private
    FCitationSources: TArray<TCitationSource>;
  public
    /// <summary>
    /// Citations to sources for a specific response.
    /// </summary>
    property CitationSources: TArray<TCitationSource> read FCitationSources write FCitationSources;

    destructor Destroy; override;
  end;

  TCandidate = class
  private
    FToken: string;
    FTokenId: Int64;
    FLogProbability: Double;
  public
    /// <summary>
    /// The candidate’s token string value.
    /// </summary>
    property Token: string read FToken write FToken;

    /// <summary>
    /// The candidate’s token id value.
    /// </summary>
    property TokenId: Int64 read FTokenId write FTokenId;

    /// <summary>
    /// The candidate's log probability.
    /// </summary>
    property LogProbability: Double read FLogProbability write FLogProbability;
  end;

  /// <summary>
  /// Candidates with top log probabilities at each decoding step.
  /// </summary>
  TTopCandidates = class
  private
    FCandidates: TArray<TCandidate>;
  public
    /// <summary>
    /// Sorted by log probability in descending order.
    /// </summary>
    property Candidates: TArray<TCandidate> read Fcandidates write Fcandidates;
  end;

  /// <summary>
  /// Logprobs Result
  /// </summary>
  TLogprobsResult = class
  private
    FTopCandidates: TArray<TTopCandidates>;
    FChosenCandidates: TArray<TCandidate>;
  public
    /// <summary>
    /// Length = total number of decoding steps.
    /// </summary>
    property TopCandidates: TArray<TTopCandidates> read FTopCandidates write FTopCandidates;

    /// <summary>
    /// Length = total number of decoding steps. The chosen candidates may or may not be in topCandidates.
    /// </summary>
    property ChosenCandidates: TArray<TCandidate> read FChosenCandidates write FChosenCandidates;

    destructor Destroy; override;
  end;

  TGroundingPassageId = class
  private
    FPassageId: string;
    FPartIndex: string;
  public
    /// <summary>
    /// Output only. ID of the passage matching the GenerateAnswerRequest's GroundingPassage.id.
    /// </summary>
    property PassageId: string read FPassageId write FPassageId;

    /// <summary>
    /// Output only. Index of the part within the GenerateAnswerRequest's GroundingPassage.content.
    /// </summary>
    property PartIndex: string read FPartIndex write FPartIndex;
  end;

  TSemanticRetrieverChunk = class
  private
    FSource: string;
    FChunk: string;
  public
    /// <summary>
    /// Output only. Name of the source matching the request's SemanticRetrieverConfig.source.
    /// Example: corpora/123 or corpora/123/documents/abc
    /// </summary>
    property Source: string read FSource write FSource;

    /// <summary>
    /// Output only. Name of the Chunk containing the attributed text.
    /// Example: corpora/123/documents/abc/chunks/xyz
    /// </summary>
    property Chunk: string read FChunk write FChunk;
  end;

  TAttributionSourceId = class
  private
    FGroundingPassage: TGroundingPassageId;
    FSemanticRetrieverChunk: TSemanticRetrieverChunk;
  public
    /// <summary>
    /// Identifier for an inline passage.
    /// </summary>
    property GroundingPassage: TGroundingPassageId read FGroundingPassage write FGroundingPassage;

    /// <summary>
    /// Identifier for a Chunk fetched via Semantic Retriever.
    /// </summary>
    property SemanticRetrieverChunk: TSemanticRetrieverChunk read FSemanticRetrieverChunk write FSemanticRetrieverChunk;

    destructor Destroy; override;
  end;

  TGroundingAttribution = class
  private
    FSourceId: TAttributionSourceId;
    FContent: TChatContent;
  public
    /// <summary>
    /// Output only. Identifier for the source contributing to this attribution.
    /// </summary>
    property SourceId: TAttributionSourceId read FSourceId write FSourceId;

    /// <summary>
    /// Grounding source content that makes up this attribution.
    /// </summary>
    property Content: TChatContent read FContent write FContent;

    destructor Destroy; override;
  end;

  TUrlMetadata = class
  private
    FRetrievedUrl: string;
    [JsonReflectAttribute(ctString, rtString, TUrlRetrievalStatusTypeInterceptor)]
    FUrlRetrievalStatus: TUrlRetrievalStatusType;
  public
    /// <summary>
    /// Retrieved url by the tool.
    /// </summary>
    property RetrievedUrl: string read FRetrievedUrl write FRetrievedUrl;

    /// <summary>
    /// Status of the url retrieval.
    /// </summary>
    property UrlRetrievalStatus: TUrlRetrievalStatusType read FUrlRetrievalStatus write FUrlRetrievalStatus;
  end;

  TUrlContextMetadata = class
  private
    FUrlMetadata: TArray<TUrlMetadata>;
  public
    /// <summary>
    /// List of url context.
    /// </summary>
    property UrlMetadata: TArray<TUrlMetadata> read FUrlMetadata write FUrlMetadata;

    destructor Destroy; override;
  end;

  TChatCandidate = class
  private
    FContent: TChatContent;
    [JsonReflectAttribute(ctString, rtString, TFinishReasonInterceptor)]
    FFinishReason: TFinishReason;
    FSafetyRatings: TArray<TSafetyRatings>;
    FCitationMetadata: TCitationMetadata;
    FTokenCount: Int64;
    FGroundingAttributions: TArray<TGroundingAttribution>;
    FGroundingMetadata: TGroundingMetadata;
    FAvgLogprobs: Double;
    FLogprobsResult: TLogprobsResult;
    FUrlContextMetadata: TUrlContextMetadata;
    FIndex: Int64;
    FFinishMessage: string;
  public
    /// <summary>
    /// Output only. Generated content returned from the model.
    /// </summary>
    property Content: TChatContent read FContent write FContent;

    /// <summary>
    /// Optional. Output only. The reason why the model stopped generating tokens.
    /// </summary>
    /// <remarks>
    /// If empty, the model has not stopped generating tokens.
    /// </remarks>
    property FinishReason: TFinishReason read FFinishReason write FFinishReason;

    /// <summary>
    /// List of ratings for the safety of a response candidate.
    /// </summary>
    /// <remarks>
    /// There is at most one rating per category.
    /// </remarks>
    property SafetyRatings: TArray<TSafetyRatings> read FSafetyRatings write FSafetyRatings;

    /// <summary>
    /// Output only. Citation information for model-generated candidate.
    /// </summary>
    /// <summary>
    /// This field may be populated with recitation information for any text included in the content. These are passages that are "recited" from copyrighted material in the foundational LLM's training data.
    /// </summary>
    property CitationMetadata: TCitationMetadata read FCitationMetadata write FCitationMetadata;

    /// <summary>
    /// Output only. Token count for this candidate.
    /// </summary>
    property TokenCount: Int64 read FTokenCount write FTokenCount;

    /// <summary>
    /// Output only. Attribution information for sources that contributed to a grounded answer.
    /// </summary>
    /// <remarks>
    /// This field is populated for GenerateAnswer calls.
    /// </remarks>
    property GroundingAttributions: TArray<TGroundingAttribution> read FGroundingAttributions write FGroundingAttributions;

    /// <summary>
    /// Output only.
    /// </summary>
    property AvgLogprobs: Double read FAvgLogprobs write FAvgLogprobs;

    /// <summary>
    /// Output only. Log-likelihood scores for the response tokens and top tokens
    /// </summary>
    property LogprobsResult: TLogprobsResult read FLogprobsResult write FLogprobsResult;

    /// <summary>
    /// Contains metadata related to the grounding of the chat candidate's content.
    /// </summary>
    /// <remarks>
    /// The <c>GroundingMetadata</c> property provides detailed information about the sources and contextual grounding of the generated content.
    /// <para>• <c>SearchEntryPoint</c>: The initial point or context from which the search was conducted.</para>
    /// <para>• <c>GroundingChunks</c>: A collection of web sources that support the generated content, each containing a URI and title.</para>
    /// <para>• <c>WebSearchQueries</c>: The specific search queries used to retrieve information relevant to the content.</para>
    /// This metadata enhances transparency by linking the generated responses to their original sources, facilitating verification and trust in the content provided by the model.
    /// </remarks>
    property GroundingMetadata: TGroundingMetadata read FGroundingMetadata write FGroundingMetadata;

    /// <summary>
    /// Output only. Metadata related to url context retrieval tool.
    /// </summary>
    property UrlContextMetadata: TUrlContextMetadata read FUrlContextMetadata write FUrlContextMetadata;

    /// <summary>
    /// Output only. Index of the candidate in the list of response candidates.
    /// </summary>
    property Index: Int64 read FIndex write FIndex;

    /// <summary>
    /// Optional. Output only. Details the reason why the model stopped generating tokens.
    /// </summary>
    /// <remarks>
    /// This is populated only when finishReason is set.
    /// </remarks>
    property FinishMessage: string read FFinishMessage write FFinishMessage;

    destructor Destroy; override;
  end;

  TPromptFeedback = class
  private
    [JsonReflectAttribute(ctString, rtString, TBlockReasonInterceptor)]
    FBlockReason: TBlockReason;
    FSafetyRatings: TArray<TsafetyRatings>;
  public
    /// <summary>
    /// Optional. If set, the prompt was blocked and no candidates are returned. Rephrase the prompt.
    /// </summary>
    property BlockReason: TBlockReason read FBlockReason write FBlockReason;

    /// <summary>
    /// Ratings for safety of the prompt. There is at most one rating per category.
    /// </summary>
    property SafetyRatings: TArray<TsafetyRatings> read FSafetyRatings write FSafetyRatings;

    destructor Destroy; override;
  end;

  TModalityTokenCount = class
  private
    [JsonReflectAttribute(ctString, rtString, TTokenModalityTypeInterceptor)]
    FModality: TTokenModalityType;
    FTokenCount: Integer;
  public
    /// <summary>
    /// The modality associated with this token count.
    /// </summary>
    property Modality: TTokenModalityType read FModality write FModality;

    /// <summary>
    /// Number of tokens.
    /// </summary>
    property TokenCount: Integer read FTokenCount write FTokenCount;
  end;

  TUsageMetadata = class(TJSONFingerprint)
  private
    FPromptTokenCount: Int64;
    FCachedContentTokenCount: Int64;
    FCandidatesTokenCount: Int64;
    FThoughtsTokenCount: Int64;
    FTotalTokenCount: Int64;
    FPromptTokensDetails: TArray<TModalityTokenCount>;
    FCacheTokensDetails: TArray<TModalityTokenCount>;
    FCandidatesTokensDetails: TArray<TModalityTokenCount>;
    FToolUsePromptTokensDetails: TArray<TModalityTokenCount>;
    function GetText: string;
    function GetCount: Integer;
  public
    /// <summary>
    /// Gets or sets the number of tokens used in the prompt.
    /// </summary>
    /// <remarks>
    /// When <c>CachedContent</c> is set, this value still represents the total effective prompt size, including the tokens in the cached content.
    /// </remarks>
    property PromptTokenCount: Int64 read FPromptTokenCount write FPromptTokenCount;

    /// <summary>
    /// Gets or sets the number of tokens in the cached part of the prompt (the cached content).
    /// </summary>
    property CachedContentTokenCount: Int64 read FCachedContentTokenCount write FCachedContentTokenCount;

    /// <summary>
    /// Gets or sets the total number of tokens across all the generated response candidates.
    /// </summary>
    property CandidatesTokenCount: Int64 read FCandidatesTokenCount write FCandidatesTokenCount;

    /// <summary>
    /// Output only. Number of tokens of thoughts for thinking models.
    /// </summary>
    property ThoughtsTokenCount: Int64 read FThoughtsTokenCount write FThoughtsTokenCount;

    /// <summary>
    /// Gets or sets the total token count for the generation request, including both the prompt and the response candidates.
    /// </summary>
    property TotalTokenCount: Int64 read FTotalTokenCount write FTotalTokenCount;

    /// <summary>
    /// Output only. List of modalities that were processed in the request input.
    /// </summary>
    property PromptTokensDetails: TArray<TModalityTokenCount> read FPromptTokensDetails write FPromptTokensDetails;

    /// <summary>
    /// Output only. List of modalities of the cached content in the request input.
    /// </summary>
    property CacheTokensDetails: TArray<TModalityTokenCount> read FCacheTokensDetails write FCacheTokensDetails;

    /// <summary>
    /// Output only. List of modalities that were returned in the response.
    /// </summary>
    property CandidatesTokensDetails: TArray<TModalityTokenCount> read FCandidatesTokensDetails write FCandidatesTokensDetails;

    /// <summary>
    /// Output only. List of modalities that were processed for tool-use request inputs.
    /// </summary>
    property ToolUsePromptTokensDetails: TArray<TModalityTokenCount> read FToolUsePromptTokensDetails write FToolUsePromptTokensDetails;

    property Text: string read GetText;

    property Count: Integer read GetCount;

    destructor Destroy; override;
  end;

  TChat = class(TJSONFingerprint)
  private
    FCandidates: TArray<TChatCandidate>;
    FPromptFeedback: TPromptFeedback;
    FUsageMetadata: TUsageMetadata;
    FModelVersion: string;
    FResponseId: string;
  public
    /// <summary>
    /// Candidate responses from the model.
    /// </summary>
    property Candidates: TArray<TChatCandidate> read FCandidates write FCandidates;

    /// <summary>
    /// Returns the prompt's feedback related to the content filters.
    /// </summary>
    property PromptFeedback: TPromptFeedback read FPromptFeedback write FPromptFeedback;

    /// <summary>
    /// Output only. Metadata on the generation requests' token usage.
    /// </summary>
    property UsageMetadata: TUsageMetadata read FUsageMetadata write FUsageMetadata;

    /// <summary>
    /// Output only. The model version used to generate the response.
    /// </summary>
    property ModelVersion: string read FModelVersion write FModelVersion;

    /// <summary>
    /// Output only. responseId is used to identify each response.
    /// </summary>
    property ResponseId: string read FResponseId write FResponseId;

    destructor Destroy; override;
  end;

implementation

uses
  Gemini.JsonPathHelper;

{ TChatPart }

destructor TChatPart.Destroy;
begin
  if Assigned(FFunctionCall) then
    FFunctionCall.Free;
  if Assigned(FFunctionResponse) then
    FFunctionResponse.Free;
  if Assigned(FInlineData) then
    FInlineData.Free;
  if Assigned(FFileData) then
    FFileData.Free;
  if Assigned(FExecutableCode) then
    FExecutableCode.Free;
  if Assigned(FCodeExecutionResult) then
    FCodeExecutionResult.Free;
  if Assigned(FVideoMetadata) then
    FVideoMetadata.Free;
  inherited;
end;

{ TChatContent }

destructor TChatContent.Destroy;
begin
  for var Item in FParts do
    Item.Free;
  inherited;
end;

{ TCitationMetadata }

destructor TCitationMetadata.Destroy;
begin
  for var Item in FCitationSources do
    Item.Free;
  inherited;
end;

{ TLogprobsResult }

destructor TLogprobsResult.Destroy;
begin
  for var Item in FTopCandidates do
    Item.Free;
  for var Item in FChosenCandidates do
    Item.Free;
  inherited;
end;

{ TChatCandidate }

destructor TChatCandidate.Destroy;
begin
  if Assigned(FContent) then
    FContent.Free;
  for var Item in FSafetyRatings do
    Item.Free;
  if Assigned(FCitationMetadata) then
    FCitationMetadata.Free;
  for var Item in FGroundingAttributions do
    Item.Free;
  if Assigned(FGroundingMetadata) then
    FGroundingMetadata.Free;
  if Assigned(FlogprobsResult) then
    FlogprobsResult.Free;
  if Assigned(FUrlContextMetadata) then
    FUrlContextMetadata.Free;
  inherited;
end;

{ TPromptFeedback }

destructor TPromptFeedback.Destroy;
begin
  for var Item in FSafetyRatings do
    Item.Free;
  inherited;
end;

{ TChat }

destructor TChat.Destroy;
begin
  for var Item in FCandidates do
    Item.Free;
  if Assigned(FPromptFeedback) then
    FPromptFeedback.Free;
  if Assigned(FUsageMetadata) then
    FUsageMetadata.Free;
  inherited;
end;

{ TFunctionResponsePartItem }

destructor TFunctionResponsePartItem.Destroy;
begin
  if Assigned(FInlineData) then
    FInlineData.Free;
  inherited;
end;

{ TFunctionResponsePart }

destructor TFunctionResponsePart.Destroy;
begin
  for var Item in FParts do
    Item.Free;
  inherited;
end;

{ TAttributionSourceId }

destructor TAttributionSourceId.Destroy;
begin
  if Assigned(FGroundingPassage) then
    FGroundingPassage.Free;
  if Assigned(FSemanticRetrieverChunk) then
    FSemanticRetrieverChunk.Free;
  inherited;
end;

{ TGroundingAttribution }

destructor TGroundingAttribution.Destroy;
begin
  if Assigned(FSourceId) then
    FSourceId.Free;
  if Assigned(FContent) then
    FContent.Free;
  inherited;
end;

{ TUrlContextMetadata }

destructor TUrlContextMetadata.Destroy;
begin
  for var Item in FUrlMetadata do
    Item.Free;
  inherited;
end;

{ TUsageMetadata }

destructor TUsageMetadata.Destroy;
begin
  for var Item in FPromptTokensDetails do
    Item.Free;
  for var Item in FCacheTokensDetails do
    Item.Free;
  for var Item in FCandidatesTokensDetails do
    Item.Free;
  for var Item in FToolUsePromptTokensDetails do
    Item.Free;
  inherited;
end;

function TUsageMetadata.GetCount: Integer;
begin
  Result := TJsonQuery.Count(JSONResponse, 'candidates[0].tableau');
end;

function TUsageMetadata.GetText: string;
begin
  Result := JsonGetString(JSONResponse, 'candidates[0].avgLogprobs');
end;

end.
