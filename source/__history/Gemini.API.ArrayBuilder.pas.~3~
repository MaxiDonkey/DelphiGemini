unit Gemini.API.ArrayBuilder;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

type
  TArrayBuilder<T> = record
  private
    FItems: TArray<T>;
    FCount: Integer;
    procedure Append(const Item: T); inline;
  public
    class function Create(const Capacity: Integer = 2): TArrayBuilder<T>; static;

    function Reserve(const Capacity: Integer): TArrayBuilder<T>;

    function Add(const Item: T): TArrayBuilder<T>;

    class operator Implicit(const Value: TArrayBuilder<T>): TArray<T>;
  end;

implementation

{$REGION 'dev note'}

(*

  TArrayBuilder<T> is a small utility to make incremental construction of
  TArray<T> more ergonomic, especially when building nested JSON structures
  from fluent APIs.

  The idea is that user code works with a builder (Create, Add, Reserve, …)
  and only produces the final TArray<T> at the end via the implicit conversion.
  This keeps the public API signatures simple (they still accept plain
  TArray<T>), while allowing higher-level helpers to expose chained methods
  like:
    .AddFunction(...)
    .AddGoogleSearchRetrieval(...)
    .AddCodeExecution(...)
  without manual array bookkeeping in user code.

  Internally the builder manages the underlying buffer and its capacity, so the
  caller only has to express “append this element” in a fluent way. The goal is
  to make composing complex JSON payloads (lists of tools, parts, parameters,
  etc.) clearer, less error-prone, and easier to read.

*)

{$ENDREGION}

{ TArrayBuilder<T> }

function TArrayBuilder<T>.Add(const Item: T): TArrayBuilder<T>;
begin
  Result := Self;
  Result.Append(Item);
end;

procedure TArrayBuilder<T>.Append(const Item: T);
var
  NewCap: Integer;
begin
  if FCount = Length(FItems) then
  begin
    if Length(FItems) = 0 then
      NewCap := 4
    else
      NewCap := Length(FItems) * 2;
    SetLength(FItems, NewCap);
  end;

  FItems[FCount] := Item;
  Inc(FCount);
end;

class function TArrayBuilder<T>.Create(
  const Capacity: Integer): TArrayBuilder<T>;
begin
  Result.FItems := nil;
  Result.FCount := 0;

  if Capacity > 0 then
    SetLength(Result.FItems, Capacity);
end;

class operator TArrayBuilder<T>.Implicit(
  const Value: TArrayBuilder<T>): TArray<T>;
begin
  Result := Copy(Value.FItems, 0, Value.FCount);
end;

function TArrayBuilder<T>.Reserve(const Capacity: Integer): TArrayBuilder<T>;
begin
  Result := Self;
  if (Capacity > 0) and (Length(Result.FItems) < Capacity) then
    SetLength(Result.FItems, Capacity);
end;

end.
