unit Gemini.Interactions.GenerationConfig;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.JSON,
  REST.JsonReflect, REST.Json.Types,
  Gemini.API.Params, Gemini.API, Gemini.Types, Gemini.Exceptions, Gemini.Types.EnumWire,
  Gemini.Interactions.Common;

type
  TToolChoiceTypeIxParams = class(TJSONParam);

  TSpeechConfigIxParams = class(TJSONParam)
    /// <summary>
    /// The voice of the speaker.
    /// </summary>
    function Voice(const Value: string): TSpeechConfigIxParams;

    /// <summary>
    /// The language of the speech.
    /// </summary>
    function Language(const Value: string): TSpeechConfigIxParams;

    /// <summary>
    /// The speaker's name, it should match the speaker name given in the prompt.
    /// </summary>
    function Speaker(const Value: string): TSpeechConfigIxParams;
  end;

  TGenerationConfigIxParams = class(TJSONParam)
    /// <summary>
    /// Controls the randomness of the output.
    /// </summary>
    function Temperature(const Value: Double): TGenerationConfigIxParams;

    /// <summary>
    /// The maximum cumulative probability of tokens to consider when sampling.
    /// </summary>
    function TopP(const Value: Double): TGenerationConfigIxParams;

    /// <summary>
    /// Seed used in decoding for reproducibility.
    /// </summary>
    function Seed(const Value: Integer): TGenerationConfigIxParams;

    /// <summary>
    /// A list of character sequences that will stop output interaction.
    /// </summary>
    function StopSequences(const Value: TArray<string>): TGenerationConfigIxParams;

    /// <summary>
    /// The tool choice for the interaction.
    /// </summary>
    function ToolChoice(const Value: TToolChoiceTypeIxParams): TGenerationConfigIxParams; overload;

    /// <summary>
    /// The tool choice for the interaction.
    /// </summary>
    function ToolChoice(const Value: TAllowedToolsIxParams): TGenerationConfigIxParams; overload;

    /// <summary>
    /// The tool choice for the interaction.
    /// </summary>
    function ToolChoice(const Value: TJSONObject): TGenerationConfigIxParams; overload;

    /// <summary>
    /// The tool choice for the interaction.
    /// </summary>
    function ToolChoice(const Value: string): TGenerationConfigIxParams; overload;

    /// <summary>
    /// The level of thought tokens that the model should generate.
    /// </summary>
    function ThinkingLevel(const Value: TThinkingLevel): TGenerationConfigIxParams; overload;

    /// <summary>
    /// The level of thought tokens that the model should generate.
    /// </summary>
    function ThinkingLevel(const Value: string): TGenerationConfigIxParams; overload;

    /// <summary>
    /// Whether to include thought summaries in the response.
    /// </summary>
    function ThinkingSummaries(const Value: TThinkingSummaries): TGenerationConfigIxParams; overload;

    /// <summary>
    /// Whether to include thought summaries in the response.
    /// </summary>
    function ThinkingSummaries(const Value: string): TGenerationConfigIxParams; overload;

    /// <summary>
    /// The maximum number of tokens to include in the response.
    /// </summary>
    function MaxOutputTokens(const Value: Integer): TGenerationConfigIxParams;

    /// <summary>
    /// Configuration for speech interaction.
    /// </summary>
    function SpeechConfig(const Value: TSpeechConfigIxParams): TGenerationConfigIxParams; overload;

    /// <summary>
    /// Configuration for speech interaction.
    /// </summary>
    function SpeechConfig(const Value: TJSONObject): TGenerationConfigIxParams; overload;

    /// <summary>
    /// Configuration for speech interaction.
    /// </summary>
    function SpeechConfig(const Value: string): TGenerationConfigIxParams; overload;
  end;

implementation

{ TGenerationConfigIxParams }

function TGenerationConfigIxParams.MaxOutputTokens(
  const Value: Integer): TGenerationConfigIxParams;
begin
  Result := TGenerationConfigIxParams(Add('max_output_tokens', Value));
end;

function TGenerationConfigIxParams.Seed(
  const Value: Integer): TGenerationConfigIxParams;
begin
  Result := TGenerationConfigIxParams(Add('seed', Value));
end;

function TGenerationConfigIxParams.SpeechConfig(
  const Value: TJSONObject): TGenerationConfigIxParams;
begin
  Result := TGenerationConfigIxParams(Add('speech_config', Value));
end;

function TGenerationConfigIxParams.SpeechConfig(
  const Value: TSpeechConfigIxParams): TGenerationConfigIxParams;
begin
  Result := SpeechConfig(Value.Detach);
end;

function TGenerationConfigIxParams.StopSequences(
  const Value: TArray<string>): TGenerationConfigIxParams;
begin
  Result := TGenerationConfigIxParams(Add('stop_sequences', Value));
end;

function TGenerationConfigIxParams.Temperature(
  const Value: Double): TGenerationConfigIxParams;
begin
  Result := TGenerationConfigIxParams(Add('temperature', Value));
end;

function TGenerationConfigIxParams.ThinkingLevel(
  const Value: TThinkingLevel): TGenerationConfigIxParams;
begin
  Result := TGenerationConfigIxParams(Add('thinking_level', Value.ToString));
end;

function TGenerationConfigIxParams.ThinkingLevel(
  const Value: string): TGenerationConfigIxParams;
begin
  Result := Self.ThinkingLevel(TThinkingLevel.Parse(Value));
end;

function TGenerationConfigIxParams.ThinkingSummaries(
  const Value: TThinkingSummaries): TGenerationConfigIxParams;
begin
  Result := TGenerationConfigIxParams(Add('thinking_summaries', Value.ToString));
end;

function TGenerationConfigIxParams.ThinkingSummaries(
  const Value: string): TGenerationConfigIxParams;
begin
  Result := Self.ThinkingSummaries(TThinkingSummaries.Parse(Value));
end;

function TGenerationConfigIxParams.ToolChoice(
  const Value: TToolChoiceTypeIxParams): TGenerationConfigIxParams;
begin
  Result := TGenerationConfigIxParams(Add('tool_choice', Value.Detach));
end;

function TGenerationConfigIxParams.ToolChoice(
  const Value: TAllowedToolsIxParams): TGenerationConfigIxParams;
begin
  Result := Self.ToolChoice(
    TJSOnObject.Create.AddPair('allowed_tools', Value.Detach));
end;

function TGenerationConfigIxParams.ToolChoice(
  const Value: TJSONObject): TGenerationConfigIxParams;
begin
  Result := TGenerationConfigIxParams(Add('tool_choice', Value));
end;

function TGenerationConfigIxParams.ToolChoice(
  const Value: string): TGenerationConfigIxParams;
begin
  Result := Self.ToolChoice(TJSONHelper.StringToJson(Value))
end;

function TGenerationConfigIxParams.TopP(
  const Value: Double): TGenerationConfigIxParams;
begin
  Result := TGenerationConfigIxParams(Add('temperature', Value));
end;

{ TSpeechConfigIxParams }

function TSpeechConfigIxParams.Language(
  const Value: string): TSpeechConfigIxParams;
begin
  Result := TSpeechConfigIxParams(Add('language', Value));
end;

function TSpeechConfigIxParams.Speaker(
  const Value: string): TSpeechConfigIxParams;
begin
  Result := TSpeechConfigIxParams(Add('speaker', Value));
end;

function TSpeechConfigIxParams.Voice(
  const Value: string): TSpeechConfigIxParams;
begin
  Result := TSpeechConfigIxParams(Add('voice', Value));
end;

end.
