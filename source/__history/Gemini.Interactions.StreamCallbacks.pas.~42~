unit Gemini.Interactions.StreamCallbacks;

interface

uses
  System.SysUtils, System.Classes,
  Gemini.Types, Gemini.Interactions.Stream;

type
  TEventData = record
  private
    FId: string;
    FText: string;
    FBase64: string;
    FThought: string;
    FChunk: TInteractionStream;
  public
    function Aggregate(const AChunk: TInteractionStream; const ErrorProc: TProc = nil): TEventData;
    property Id: string read FId write FId;
    property Text: string read FText write FText;
    property Base64: string read FBase64 write FBase64;
    property Chunk: TInteractionStream read FChunk;
    property Thought: string read FThought write FThought;
  end;

  TStreamEventCallBack = record
  private
    FSender: TObject;
    FOnInteractionStart: TProc<TObject, TEventData>;
    FOnInteractionStatusUpdate: TProc<TObject, TEventData>;
    FOnInteractionComplete: TProc<TObject, TEventData>;
    FOnContentStart: TProc<TObject, TEventData>;
    FOnContentDelta: TProc<TObject, TEventData>;
    FOnContentStop: TProc<TObject, TEventData>;
    FOnError: TProc<TObject, TEventData>;
    FOnCancellation: TFunc<TObject, string>;
    FOnDoCancel: TFunc<Boolean>;
  public
    property Sender: TObject read FSender write FSender;
    property OnInteractionStart: TProc<TObject, TEventData> read FOnInteractionStart write FOnInteractionStart;
    property OnInteractionStatusUpdate: TProc<TObject, TEventData> read FOnInteractionStatusUpdate write FOnInteractionStatusUpdate;
    property OnInteractionComplete: TProc<TObject, TEventData> read FOnInteractionComplete write FOnInteractionComplete;
    property OnContentStart: TProc<TObject, TEventData> read FOnContentStart write FOnContentStart;
    property OnContentDelta: TProc<TObject, TEventData> read FOnContentDelta write FOnContentDelta;
    property OnContentStop: TProc<TObject, TEventData> read FOnContentStop write FOnContentStop;
    property OnError: TProc<TObject, TEventData> read FOnError write FOnError;
    property OnCancellation: TFunc<TObject, string> read FOnCancellation write FOnCancellation;
    property OnDoCancel: TFunc<Boolean> read FOnDoCancel write FOnDoCancel;
  end;

  IStreamEventDispatcher = interface
    ['{4B0DE7D4-7E57-4A9E-8B7A-49E7E7C9B1B7}']
    function GetCallBacks: TStreamEventCallBack;

    procedure DispatchEvent(EventType: TEventType; const Buffer: TEventData);

    property CallBacks: TStreamEventCallBack read GetCallBacks;
  end;

  TStreamEventDispatcher = class(TInterfacedObject, IStreamEventDispatcher)
  private
    FCallBacks: TStreamEventCallBack;

    procedure Invoke(const Proc: TProc<TObject, TEventData>; const Buffer: TEventData);
  public
    constructor Create(const CallBacks: TFunc<TStreamEventCallBack> = nil);

    function GetCallBacks: TStreamEventCallBack;

    procedure DispatchEvent(EventType: TEventType; const Buffer: TEventData);
  end;

implementation

{ TStreamEventDispatcher }

function TStreamEventDispatcher.GetCallBacks: TStreamEventCallBack;
begin
  Result := FCallBacks;
end;

procedure TStreamEventDispatcher.Invoke(const Proc: TProc<TObject, TEventData>; const Buffer: TEventData);
var
  LocalSender: TObject;
  LocalProc: TProc<TObject, TEventData>;
begin
  LocalSender := FCallBacks.Sender;
  LocalProc := Proc;

  if not Assigned(LocalSender) then
    LocalSender := Self;

  if Assigned(LocalProc) then
    LocalProc(LocalSender, Buffer);
end;

constructor TStreamEventDispatcher.Create(
  const CallBacks: TFunc<TStreamEventCallBack>);
begin
  inherited Create;
  if Assigned(CallBacks) then
    FCallBacks := CallBacks()
  else
    FCallBacks := Default(TStreamEventCallBack);
end;

procedure TStreamEventDispatcher.DispatchEvent(EventType: TEventType; const Buffer: TEventData);
begin
  case EventType of
    TEventType.interaction_start:
      Invoke(FCallBacks.OnInteractionStart, Buffer);

    TEventType.interaction_status_update:
      Invoke(FCallBacks.OnInteractionStatusUpdate, Buffer);

    TEventType.interaction_complete:
      Invoke(FCallBacks.OnInteractionComplete, Buffer);

    TEventType.content_start:
      Invoke(FCallBacks.OnContentStart, Buffer);

    TEventType.content_delta:
      Invoke(FCallBacks.OnContentDelta, Buffer);

    TEventType.content_stop:
      Invoke(FCallBacks.OnContentStop, Buffer);

    TEventType.error:
      Invoke(FCallBacks.OnError, Buffer);
    else ;
  end;
end;

{ TEventData }

function TEventData.Aggregate(const AChunk: TInteractionStream;
  const ErrorProc: TProc): TEventData;
begin
  FChunk := AChunk;
  if not Assigned(FChunk) then
    Exit;

  case FChunk.EventType of
    interaction_start:
      Id := FChunk.Interaction.Id;
    content_delta:
      case FChunk.Delta.&Type of
        TContentType.text:
          begin
            if Assigned(FChunk.Delta.Content) then
              Base64 := FChunk.Delta.Content.Data
            else
              Text := Text + FChunk.Delta.Text;
          end;
        TContentType.thought_summary:
          begin
            Thought := Thought + FChunk.Delta.Content.Text;
          end;
      end;
    error:
      begin
        if Assigned(ErrorProc) then
          ErrorProc();
      end;
  end;
end;

end.

