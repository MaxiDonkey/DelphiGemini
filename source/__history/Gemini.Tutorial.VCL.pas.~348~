unit Gemini.Tutorial.VCL;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
          https://github.com/MaxiDonkey/DelphiGemini
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, Winapi.ShellAPI,
  System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls,
  System.UITypes, Vcl.MPlayer, system.JSON,
  Gemini, Gemini.Types, Gemini.Chat.Response, Gemini.Models, Gemini.Embeddings,
  Gemini.Files, Gemini.Caching, Gemini.VectorFiles, Gemini.VectorFiles.Documents,
  Gemini.Operation, Gemini.Batch,

  Gemini.Interactions.ResponsesContent, Gemini.Interactions.Responses,
  Gemini.Interactions.Stream;

type
  TVCLTutorialHub = class
  private
    FClient: IGemini;
    FMemo1: TMemo;
    FMemo2: TMemo;
    FMemo3: TMemo;
    FMemo4: TMemo;
    FButton: TButton;
    FCancel: Boolean;
    FFileName: string;
    procedure OnButtonClick(Sender: TObject);
    procedure SetMemo1(const Value: TMemo);
    procedure SetMemo2(const Value: TMemo);
    procedure SetMemo3(const Value: TMemo);
    procedure SetJSONRequest(const Value: string);
    procedure SetMemo4(const Value: TMemo);
    procedure SetJSONResponse(const Value: string);
    procedure SetButton(const Value: TButton);

  public
    property Client: IGemini read FClient write FClient;
    property Memo1: TMemo read FMemo1 write SetMemo1;
    property Memo2: TMemo read FMemo2 write SetMemo2;
    property Memo3: TMemo read FMemo3 write SetMemo3;
    property Memo4: TMemo read FMemo4 write SetMemo4;
    property JSONRequest: string write SetJSONRequest;
    property JSONResponse: string write SetJSONResponse;
    property Button: TButton read FButton write SetButton;
    property Cancel: Boolean read FCancel write FCancel;
    property FileName: string read FFileName write FFileName;

    procedure JSONUIClear;
    procedure JSONRequestClear;
    procedure JSONResponseClear;

    constructor Create(const AClient: IGemini; const AMemo1, AMemo2, AMemo3, AMemo4: TMemo;
      const AButton: TButton);
  end;

  procedure Cancellation(Sender: TObject);
  function DoCancellation: Boolean;
  function DoCancellationStream(Sender: TObject): string;
  procedure Start(Sender: TObject);

  procedure Display(Sender: TObject); overload;
  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Value: TArray<string>); overload;
  procedure Display(Sender: TObject; Value: TChat); overload;
  procedure Display(Sender: TObject; Value: TModel); overload;
  procedure Display(Sender: TObject; Value: TModels); overload;
  procedure Display(Sender: TObject; Value: TEmbedding); overload;
  procedure Display(Sender: TObject; Value: TEmbedContent); overload;
  procedure Display(Sender: TObject; Value: TEmbeddingList); overload;
  procedure Display(Sender: TObject; Value: TFileContent); overload;
  procedure Display(Sender: TObject; Value: TFile); overload;
  procedure Display(Sender: TObject; Value: TFiles); overload;
  procedure Display(Sender: TObject; Value: TFileDelete); overload;
  procedure Display(Sender: TObject; Value: TCache); overload;
  procedure Display(Sender: TObject; Value: TCacheContents); overload;
  procedure Display(Sender: TObject; Value: TFileSearchStore); overload;
  procedure Display(Sender: TObject; Value: TFileSearchStoreList); overload;
  procedure Display(Sender: TObject; Value: TOperation); overload;
  procedure Display(Sender: TObject; Value: TOperationList); overload;
  procedure Display(Sender: TObject; Value: TFileSearchStoreDelete); overload;
  procedure Display(Sender: TObject; Value: TDocument); overload;
  procedure Display(Sender: TObject; Value: TDocumentList); overload;
  procedure Display(Sender: TObject; Value: TDocumentDelete); overload;
  procedure Display(Sender: TObject; Value: TBatchCancel); overload;
  procedure Display(Sender: TObject; Value: TBatchDelete); overload;
  procedure Display(Sender: TObject; Value: TJsonlDownload); overload;

  procedure Display(Sender: TObject; Value: TIxContent); overload;    //New
  procedure Display(Sender: TObject; Value: TInteraction); overload;  //New
  procedure Display(Sender: TObject; Value: TCRUDDeleted); overload;  //New

  procedure DisplayStream(Sender: TObject; Value: string); overload;
  procedure DisplayStream(Sender: TObject; Value: TChat); overload;

  procedure DisplayStream(Sender: TObject; Value: TInteractionStream); overload; //New

  procedure DisplayChunk(Value: string); overload;
  procedure DisplayChunk(Value: TChat); overload;

  procedure DisplayChunk(Value: TInteractionStream); overload; //New

  procedure DisplayInteractionStart(Sender: TObject; Chunk: TInteractionStream); overload;  //New
  procedure DisplayInteractionStart(Sender: TObject; EventData: TEventData); overload; //New
  procedure DisplayInteractionStatusUpdate(Sender: TObject; Chunk: TInteractionStream); overload; //New
  procedure DisplayInteractionStatusUpdate(Sender: TObject; EventData: TEventData); overload; //New
  procedure DisplayInteractionComplete(Sender: TObject; Chunk: TInteractionStream); overload; //New
  procedure DisplayInteractionComplete(Sender: TObject; EventData: TEventData); overload; //New
  procedure DisplayContentStart(Sender: TObject; Chunk: TInteractionStream); overload; //New
  procedure DisplayContentStart(Sender: TObject; EventData: TEventData); overload; //New
  procedure DisplayContentDelta(Sender: TObject; Chunk: TInteractionStream); overload; //New
  procedure DisplayContentDelta(Sender: TObject; EventData: TEventData); overload; //New
  procedure DisplayContentStop(Sender: TObject; Chunk: TInteractionStream); overload; //New
  procedure DisplayContentStop(Sender: TObject; EventData: TEventData); overload; //New
  procedure DisplayInteractionError(Sender: TObject; Chunk: TInteractionStream); overload; //New
  procedure DisplayInteractionError(Sender: TObject; EventData: TEventData); overload; //New

  function F(const Name, Value: string): string; overload;
  function F(const Name: string; const Value: TArray<string>): string; overload;
  function F(const Name: string; const Value: boolean): string; overload;
  function F(const Name: string; const State: Boolean; const Value: Double): string; overload;

var
  TutorialHub: TVCLTutorialHub = nil;

implementation

uses
  System.StrUtils;

procedure Cancellation(Sender: TObject);
begin
  if TutorialHub.Cancel then
    begin
      Display(Sender, 'The operation was cancelled');
      Display(Sender);
      TutorialHub.Cancel := False;
    end;
end;

function DoCancellation: Boolean;
begin
  Result := TutorialHub.Cancel;
end;

function DoCancellationStream(Sender: TObject): string;
begin
  Cancellation(Sender);
end;

procedure Start(Sender: TObject);
begin
  Display(Sender, 'Please wait...');
  Display(Sender);
  TutorialHub.Cancel := False;
  TutorialHub.JSONResponseClear;
end;

procedure Display(Sender: TObject);
begin
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := TMemo(Sender) else
    M := (Sender as TVCLTutorialHub).Memo1;

  var S := Value.Split([#10]);
  if System.Length(S) = 0 then
    begin
      M.Lines.Add(Value)
    end
  else
    begin
      for var Item in S do
        M.Lines.Add(Item);
    end;

  M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
end;

procedure Display(Sender: TObject; Value: TArray<string>);
begin
  var index := 0;
  for var Item in Value do
    begin
      if not Item.IsEmpty then
        begin
          if index = 0 then
            Display(Sender, Item) else
            Display(Sender, '    ' + Item);
        end;
      Inc(index);
    end;
end;

procedure Display(Sender: TObject; Value: TChat);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Candidates do
   begin
     if Item.FinishReason = TFinishReason.STOP then
       for var SubItem in Item.Content.Parts do
         begin
           Display(Sender, SubItem.Text);
         end;
   end;
end;

procedure Display(Sender: TObject; Value: TModel);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;

  var Supported := '- SupportedGenerationMethods';
  for var Item in Value.SupportedGenerationMethods do
    Supported := Format('%s'#10#13'   - %s', [Supported, Item]);

  Display(Sender,
  [
    Value.Name,
    F('models/nano-banana-pro-preview BaseModelId', Value.BaseModelId),
    F('• Version', Value.Version),
    F('• DisplayName', Value.DisplayName),
    F('• Description', Value.Description),
    F('• InputTokenLimit', Value.InputTokenLimit),
    F('• OutputTokenLimit', Value.OutputTokenLimit),
    F('• SupportedGenerationMethods', Value.SupportedGenerationMethods),
    F('• Thinking', BoolToStr(Value.Thinking, True)),
    F('• Temperature', Value.Temperature.ToString),
    F('• MaxTemperature', Value.MaxTemperature.ToString),
    F('• TopP', Value.TopP.ToString),
    F('• TopK', Value.TopK.ToString),
    ''
  ]);
end;

procedure Display(Sender: TObject; Value: TModels);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Models do
    Display(Sender, Item.Name);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TEmbedContent);
begin
  var index := 0;
  for var Item in Value.Values do
    begin
      Display(Sender, F('[' + index.ToString + ']: ', Item.ToString));
      Inc(index);
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TEmbedding);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.Embedding);
end;

procedure Display(Sender: TObject; Value: TEmbeddingList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Embeddings do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TFileContent);
begin
  Display(Sender, [
    Value.Name,
    F('• DisplayName', Value.DisplayName),
    F('• MimeType', Value.MimeType),
    F('• SizeBytes', Value.SizeBytes),
    F('• CreateTime', Value.CreateTime),
    F('• UpdateTime', Value.UpdateTime),
    F('• ExpirationTime', Value.ExpirationTime),
    F('• Sha256Hash', Value.Sha256Hash),
    F('• Uri', Value.Uri),
    F('• DownloadUri', Value.DownloadUri),
    F('• State', Value.State.ToString),
    F('• Source', Value.Source.ToString)
  ]);
  if Assigned(Value.Error) then
    begin
      Display(Sender, F('• Error', Value.Error.Code.ToString));
      Display(Sender, F('• Error', Value.Error.Message));
    end;
  if Assigned(Value.VideoMetadata) then
    Display(Sender, F('• Source', Value.VideoMetadata.videoDuration));
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TFile);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.&File);
end;

procedure Display(Sender: TObject; Value: TFiles);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Files do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TFileDelete);
begin
  Display(Sender, 'file deleted');
end;

procedure Display(Sender: TObject; Value: TCache);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('• Name', Value.Name),
    F('• DisplayName', Value.DisplayName),
    F('• Model', Value.Model),
    F('• CreateTime', Value.CreateTime),
    F('• ExpireTime', Value.ExpireTime)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TCacheContents);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.CachedContents do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TFileSearchStore);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('• Name', Value.Name),
    F('• DisplayName', Value.DisplayName),
    F('• CreateTime', Value.CreateTime),
    F('• UpdateTime', Value.UpdateTime),
    F('• ActiveDocumentsCount', Value.ActiveDocumentsCount.ToString),
    F('• PendingDocumentsCount', Value.PendingDocumentsCount.ToString),
    F('• FailedDocumentsCount', Value.FailedDocumentsCount.ToString),
    F('• SizeBytes', Value.SizeBytes.ToString)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TFileSearchStoreList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.FileSearchStores do
      Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TOperation);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;

  var ErrorMsg := EmptyStr;
  if Assigned(Value.Error) then
    ErrorMsg := F('• Error', Format('(%d) %s', [Value.Error.Code, Value.Error.Message]));

   Display(Sender, [
    IfThen( ErrorMsg.IsEmpty, F('• Name', Value.Name), ErrorMsg),
    F('• Type', Value.&Type),
    F('• Done', BoolToStr(Value.Done, True)),
    F('• Model', Value.Model),
    F('• DisplayName', Value.DisplayName),
    F('• inputConfig.FileName', Value.FileName),
    F('• CreateTime', Value.CreateTime),
    F('• EndTime', Value.EndTime),
    F('• UpdateTime', Value.UpdateTime),
    F('• batchStats.RequestCount', Value.RequestCount),
    F('• batchStats.SuccessfulRequestCount', Value.SuccessfulRequestCount),
    F('• batchStats.FailedRequestCount', Value.FailedRequestCount),
    F('• batchStats.PendingRequestCount', Value.PendingRequestCount),
    IfThen( Value.State <> BATCH_STATE_UNSPECIFIED, F('• State', Value.State.ToString)),
    F('• ResponseFile', Value.ResponseFile)
  ]);

  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TOperationList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Operations do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TFileSearchStoreDelete);
begin
  Display(Sender, 'File store deleted');
end;

procedure Display(Sender: TObject; Value: TDocument);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('• Name', Value.Name),
    F('• DisplayName', Value.DisplayName),
    F('• CreateTime', Value.CreateTime),
    F('• UpdateTime', Value.UpdateTime),
    F('• State', Value.State.ToString),
    F('• SizeBytes', Value.SizeBytes.ToString),
    F('• MimeType', Value.MimeType)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TDocumentList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  if not Value.NextPageToken.IsEmpty then
    Display(Sender, 'NextPageToken' + Value.NextPageToken);
  for var Item in Value.Documents do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TDocumentDelete);
begin
  Display(Sender, 'Deleted');
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TBatchCancel);
begin
  Display(Sender, 'Batch cancelled');
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TBatchDelete);
begin
  Display(Sender, 'Batch deleted');
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TJsonlDownload);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Value.SaveToJsonl(TutorialHub.FileName);
  Display(TutorialHub, Format('File %s created', [TutorialHub.FileName]));
end;

procedure Display(Sender: TObject; Value: TIxContent);
begin
  case Value.&Type of
    TContentType.google_search_Call:
      begin
        var SearchCall := Value.GoogleSearchCallArguments;
        if Assigned(SearchCall) then
          begin
            if Length(SearchCall.Queries) > 0 then
              Display(Sender, '-------------> Google Search Call: '#10);

            for var Item in SearchCall.Queries do
              begin
                Display(Sender, Item + #10);
              end;

            Display(Sender);
          end;
      end;

    TContentType.google_search_result:
      begin
        var SearchResult := Value.GoogleSearchResult;
        if Assigned(SearchResult) then
          begin
            if Length(SearchResult.Data) > 0 then
              Display(Sender, '-------------> Google Search Result: '#10);

            for var Item in SearchResult.Data do
              begin
                Display(Sender, Item.Title);
                Display(Sender, Item.Url);
//                Display(Sender, Item.RenderedContent);
                Display(Sender);
              end;

            Display(Sender);
          end;
      end;

    TContentType.text:
      begin
        if Length(Value.Annotations) > 0 then
          Display(Sender, '-------------> Annotations: '#10);
        for var Item in Value.Annotations do
          begin
            Display(Sender, Item.Source);
          end;

        Display(Sender, '-------------> Text: '#10);
        Display(Sender, Value.Text);
        Display(Sender);
      end;

    TContentType.thought:
      begin
        if Length(Value.Summary) > 0 then
          Display(Sender, '-------------> Thought: '#10);

        for var Item in Value.Summary do
          Display(Sender, Item.Text);

        Display(Sender);
      end;

  end;
end;

procedure Display(Sender: TObject; Value: TInteraction);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Outputs do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TCRUDDeleted);
begin
  Display(Sender, 'Deleted'#10);
end;

procedure DisplayStream(Sender: TObject; Value: string);
var
  M   : TMemo;
  Txt : string;
begin
  if Value.IsEmpty then Exit;

  if Sender is TMemo then
    M := TMemo(Sender)
  else
    M := (Sender as TVCLTutorialHub).Memo1;

  Txt := StringReplace(Value, '\n', sLineBreak, [rfReplaceAll]);
  Txt := StringReplace(Txt, #10,  sLineBreak, [rfReplaceAll]);

  M.Lines.BeginUpdate;
  try
    M.SelStart   := M.GetTextLen;
    M.SelLength  := 0;
    M.SelText    := Txt;
  finally
    M.Lines.EndUpdate;
  end;

  M.Perform(EM_SCROLLCARET, 0, 0);
end;

procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  if not Assigned(Value) then
    Exit;

//      if (Length(Value.Candidates) > 0) and (Value.Candidates[0].FinishReason <> TFinishReason.SAFETY) then

  for var Item in Value.Candidates do
    begin
      DisplayStream(Sender, Item.Content.Parts[0].Text);
    end;
  DisplayChunk(Value);
end;

procedure DisplayStream(Sender: TObject; Value: TInteractionStream);
begin
  if not Assigned(Value) then
    Exit;
//  try
    case Value.EventType of
      interaction_start:
        DisplayInteractionStart(Sender, Value);
      interaction_complete:
        DisplayInteractionComplete(Sender, Value);
      interaction_status_update:
        DisplayInteractionStatusUpdate(Sender, Value);
      content_start:
        DisplayContentStart(Sender, Value);
      content_delta:
        DisplayContentDelta(Sender, Value);
      content_stop:
        DisplayContentStop(Sender, Value);
      error:
        DisplayInteractionError(Sender, Value);
    end;
//  except
//  end;
end;

procedure DisplayChunk(Value: string);
begin
  if Value.Trim.IsEmpty then
    Exit;

  var JSONValue := TJSONObject.ParseJSONValue(Value);
  TutorialHub.Memo4.Lines.BeginUpdate;
  try
    Display(TutorialHub.Memo4, JSONValue.ToString);
  finally
    TutorialHub.Memo4.Lines.EndUpdate;
    JSONValue.Free;
  end;
end;

procedure DisplayChunk(Value: TChat);
begin
  DisplayChunk(Value.JSONResponse);
end;

procedure DisplayChunk(Value: TInteractionStream);
begin
  DisplayChunk(Value.JSONResponse);
end;

procedure DisplayInteractionStart(Sender: TObject; Chunk: TInteractionStream);
begin
  DisplayChunk(Chunk);
  Display(Sender, '-------------------------------------------');
  Display(Sender, Chunk.EventType.ToString);
  Display(Sender, Chunk.Interaction.Model);
  Display(Sender, Chunk.Interaction.Status.ToString);
  Display(Sender, F('ID', Chunk.Interaction.Id));
  Display(Sender, '-------------------------------------------');
end;

procedure DisplayInteractionStart(Sender: TObject; EventData: TEventData);
begin
  DisplayInteractionStart(Sender, EventData.Chunk);
end;

procedure DisplayInteractionComplete(Sender: TObject; Chunk: TInteractionStream);
begin
  DisplayChunk(Chunk);
  Display(Sender, Chunk.EventType.ToString);
  Display(Sender, Chunk.Interaction.Status.ToString);
  Display(Sender, Chunk.Interaction.Updated);
  Display(Sender, '-------------------------------------------> END');
end;

procedure DisplayInteractionComplete(Sender: TObject; EventData: TEventData);
begin
  DisplayInteractionComplete(Sender, EventData.Chunk);
end;

procedure DisplayInteractionStatusUpdate(Sender: TObject; Chunk: TInteractionStream);
begin
  DisplayChunk(Chunk);
end;

procedure DisplayInteractionStatusUpdate(Sender: TObject; EventData: TEventData);
begin
  DisplayInteractionStatusUpdate(Sender, EventData.Chunk);
end;

procedure DisplayContentStart(Sender: TObject; Chunk: TInteractionStream);
begin
  DisplayChunk(Chunk);
end;

procedure DisplayContentStart(Sender: TObject; EventData: TEventData);
begin
  DisplayContentStart(Sender, EventData.Chunk);
end;

procedure DisplayContentDelta(Sender: TObject; Chunk: TInteractionStream);
begin
  DisplayChunk(Chunk);
  var Value := Chunk.Delta;

  case Value.&Type of
    TContentType.Text:
      DisplayStream(Sender, Value.Text);

    TContentType.thought_summary:
      DisplayStream(Sender, Value.Content.Text);
  end;

end;

procedure DisplayContentDelta(Sender: TObject; EventData: TEventData);
begin
  DisplayContentDelta(Sender, EventData.Chunk);
end;

procedure DisplayContentStop(Sender: TObject; Chunk: TInteractionStream);
begin
  DisplayChunk(Chunk);
  Display(Sender, #10#10'-------------> Content stop'#10#10);
end;

procedure DisplayContentStop(Sender: TObject; EventData: TEventData);
begin
  DisplayContentStop(Sender, EventData.Chunk);
end;

procedure DisplayInteractionError(Sender: TObject; Chunk: TInteractionStream);
begin
  DisplayChunk(Chunk);
  DisplayStream(Sender, Chunk.Error.Code);
  DisplayStream(Sender, Chunk.Error.Message);
  Display(Sender);
end;

procedure DisplayInteractionError(Sender: TObject; EventData: TEventData);
begin
  DisplayInteractionError(Sender, EventData.Chunk);
end;

function F(const Name, Value: string): string;
begin
  if not Value.IsEmpty then
    Result := Format('%s: %s', [Name, Value])
end;

function F(const Name: string; const Value: TArray<string>): string;
begin
  Result := Name;
  for var Item in Value do
    begin
      Result := Result + #10 + #9'• ' + Item;
    end;
end;

function F(const Name: string; const Value: boolean): string;
begin
  Result := Format('%s: %s', [Name, BoolToStr(Value, True)])
end;

function F(const Name: string; const State: Boolean; const Value: Double): string;
begin
  Result := Format('%s (%s): %s%%', [Name, BoolToStr(State, True), (Value * 100).ToString(ffNumber, 3, 2)])
end;

{ TVCLTutorialHub }

constructor TVCLTutorialHub.Create(const AClient: IGemini; const AMemo1, AMemo2,
  AMemo3, AMemo4: TMemo; const AButton: TButton);
begin
  inherited Create;
  Memo1 := AMemo1;
  Memo2 := AMemo2;
  Memo3 := AMemo3;
  Memo4 := AMemo4;
  Button := AButton;
  Client := AClient;
end;

procedure TVCLTutorialHub.JSONRequestClear;
begin
  Memo3.Clear;
end;

procedure TVCLTutorialHub.JSONResponseClear;
begin
  Memo4.Clear;
end;

procedure TVCLTutorialHub.JSONUIClear;
begin
  JSONRequestClear;
  JSONResponseClear;
end;

procedure TVCLTutorialHub.OnButtonClick(Sender: TObject);
begin
  Cancel := True;
end;

procedure TVCLTutorialHub.SetButton(const Value: TButton);
begin
  FButton := Value;
  FButton.OnClick := OnButtonClick;
  FButton.Caption := 'Cancel';
end;

procedure TVCLTutorialHub.SetJSONRequest(const Value: string);
begin
  Memo3.Lines.Text := Value;
  Memo3.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TVCLTutorialHub.SetJSONResponse(const Value: string);
begin
  Memo4.Lines.Text := Value;
  Memo4.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TVCLTutorialHub.SetMemo1(const Value: TMemo);
begin
  FMemo1 := Value;
  FMemo1.ScrollBars := TScrollStyle.ssVertical;
end;

procedure TVCLTutorialHub.SetMemo2(const Value: TMemo);
begin
  FMemo2 := Value;
  FMemo2.ScrollBars := TScrollStyle.ssBoth;
end;

procedure TVCLTutorialHub.SetMemo3(const Value: TMemo);
begin
  FMemo3 := Value;
  FMemo3.ScrollBars := TScrollStyle.ssBoth;
end;

procedure TVCLTutorialHub.SetMemo4(const Value: TMemo);
begin
  FMemo4 := Value;
  FMemo4.ScrollBars := TScrollStyle.ssBoth;
end;

initialization
finalization
  if Assigned(TutorialHub) then
    TutorialHub.Free;
end.
