unit Gemini.Tutorial.FMX;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
          https://github.com/MaxiDonkey/DelphiGemini
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  System.SysUtils, System.Classes, Winapi.Messages, FMX.Types, FMX.StdCtrls, FMX.ExtCtrls,
  FMX.Controls, FMX.Forms, Winapi.Windows, FMX.Graphics, FMX.Dialogs, FMX.Memo.Types,
  FMX.Media, FMX.Objects, FMX.Controls.Presentation, FMX.ScrollBox, FMX.Memo, System.UITypes,
  System.Types, System.JSON,
  Gemini, Gemini.Types, Gemini.Chat.Response, Gemini.Models, Gemini.Embeddings,
  Gemini.Files, Gemini.Caching, Gemini.VectorFiles, Gemini.VectorFiles.Documents,
  Gemini.Operation;

type
  TToolProc = procedure (const Value: string) of object;

  TFMXTutorialHub = class
  private
    FClient: IGemini;
    FMemo1: TMemo;
    FMemo2: TMemo;
    FMemo3: TMemo;
    FMemo4: TMemo;
    FButton: TButton;
    FCancel: Boolean;
    procedure OnButtonClick(Sender: TObject);
    procedure SetMemo1(const Value: TMemo);
    procedure SetMemo2(const Value: TMemo);
    procedure SetMemo3(const Value: TMemo);
    procedure SetMemo4(const Value: TMemo);
    procedure SetJSONRequest(const Value: string);
    procedure SetJSONResponse(const Value: string);
    procedure SetButton(const Value: TButton);

  public
    property Client: IGemini read FClient write FClient;
    property Memo1: TMemo read FMemo1 write SetMemo1;
    property Memo2: TMemo read FMemo2 write SetMemo2;
    property Memo3: TMemo read FMemo3 write SetMemo3;
    property Memo4: TMemo read FMemo4 write SetMemo4;
    property JSONRequest: string write SetJSONRequest;
    property JSONResponse: string write SetJSONResponse;
    property Button: TButton read FButton write SetButton;
    property Cancel: Boolean read FCancel write FCancel;

    procedure JSONUIClear;
    procedure JSONRequestClear;
    procedure JSONResponseClear;

    constructor Create(const AClient: IGemini; const AMemo1, AMemo2, AMemo3, AMemo4: TMemo;
      const AButton: TButton);
  end;

  procedure Cancellation(Sender: TObject);
  function DoCancellation: Boolean;
  procedure Start(Sender: TObject);

  procedure Display(Sender: TObject); overload;
  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Value: TArray<string>); overload;
  procedure Display(Sender: TObject; Value: TChat); overload;
  procedure Display(Sender: TObject; Value: TModel); overload;
  procedure Display(Sender: TObject; Value: TModels); overload;
  procedure Display(Sender: TObject; Value: TEmbedding); overload;
  procedure Display(Sender: TObject; Value: TEmbedContent); overload;
  procedure Display(Sender: TObject; Value: TEmbeddingList); overload;
  procedure Display(Sender: TObject; Value: TFileContent); overload;
  procedure Display(Sender: TObject; Value: TFile); overload;
  procedure Display(Sender: TObject; Value: TFiles); overload;
  procedure Display(Sender: TObject; Value: TFileDelete); overload;
  procedure Display(Sender: TObject; Value: TCache); overload;
  procedure Display(Sender: TObject; Value: TCacheContents); overload;
  procedure Display(Sender: TObject; Value: TFileSearchStore); overload;
  procedure Display(Sender: TObject; Value: TFileSearchStoreList); overload;
  procedure Display(Sender: TObject; Value: TOperation); overload;
  procedure Display(Sender: TObject; Value: TOperationList); overload;
  procedure Display(Sender: TObject; Value: TFileSearchStoreDelete); overload;
  procedure Display(Sender: TObject; Value: TDocument); overload;
  procedure Display(Sender: TObject; Value: TDocumentList); overload;
  procedure Display(Sender: TObject; Value: TDocumentDelete); overload;

  procedure DisplayStream(Sender: TObject; Value: string); overload;
  procedure DisplayStream(Sender: TObject; Value: TChat); overload;

  procedure DisplayChunk(Value: string); overload;
  procedure DisplayChunk(Value: TChat); overload;

  function F(const Name, Value: string): string; overload;
  function F(const Name: string; const Value: TArray<string>): string; overload;
  function F(const Name: string; const Value: boolean): string; overload;
  function F(const Name: string; const State: Boolean; const Value: Double): string; overload;

var
  TutorialHub: TFMXTutorialHub = nil;

implementation

procedure Cancellation(Sender: TObject);
begin
  if TutorialHub.Cancel then
    begin
      Display(Sender, 'The operation was cancelled');
      Display(Sender);
      TutorialHub.Cancel := False;
    end;
end;

function DoCancellation: Boolean;
begin
  Result := TutorialHub.Cancel;
end;

procedure Start(Sender: TObject);
begin
  Display(Sender, 'Please wait...');
  Display(Sender);
  TutorialHub.Cancel := False;
  TutorialHub.JSONResponseClear;
end;

procedure Display(Sender: TObject);
begin
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := Sender as TMemo else
    M := (Sender as TFMXTutorialHub).Memo1;
  M.Lines.Add(Value);
  M.ViewportPosition := PointF(M.ViewportPosition.X, M.Content.Height - M.Height);
end;

procedure Display(Sender: TObject; Value: TArray<string>);
begin
  var index := 0;
  for var Item in Value do
    begin
      if not Item.IsEmpty then
        begin
          if index = 0 then
            Display(Sender, Item) else
            Display(Sender, '    ' + Item);
        end;
      Inc(index);
    end;
end;

procedure Display(Sender: TObject; Value: TChat);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Candidates do
   begin
     if Item.FinishReason = TFinishReason.STOP then
       for var SubItem in Item.Content.Parts do
         begin
           Display(Sender, SubItem.Text);
         end;
   end;
end;

procedure Display(Sender: TObject; Value: TModel);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;

  var Supported := '- SupportedGenerationMethods';
  for var Item in Value.SupportedGenerationMethods do
    Supported := Format('%s'#10#13'   - %s', [Supported, Item]);

  Display(Sender,
  [
    Value.Name,
    F('models/nano-banana-pro-preview BaseModelId', Value.BaseModelId),
    F('• Version', Value.Version),
    F('• DisplayName', Value.DisplayName),
    F('• Description', Value.Description),
    F('• InputTokenLimit', Value.InputTokenLimit),
    F('• OutputTokenLimit', Value.OutputTokenLimit),
    F('• SupportedGenerationMethods', Value.SupportedGenerationMethods),
    F('• Thinking', BoolToStr(Value.Thinking, True)),
    F('• Temperature', Value.Temperature.ToString),
    F('• MaxTemperature', Value.MaxTemperature.ToString),
    F('• TopP', Value.TopP.ToString),
    F('• TopK', Value.TopK.ToString),
    ''
  ]);
end;

procedure Display(Sender: TObject; Value: TModels);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Models do
    Display(Sender, Item.Name);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TEmbedContent);
begin
  var index := 0;
  for var Item in Value.Values do
    begin
      Display(Sender, F('[' + index.ToString + ']: ', Item.ToString));
      Inc(index);
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TEmbedding);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.Embedding);
end;

procedure Display(Sender: TObject; Value: TEmbeddingList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Embeddings do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TFileContent);
begin
  Display(Sender, [
    Value.Name,
    F('• DisplayName', Value.DisplayName),
    F('• MimeType', Value.MimeType),
    F('• SizeBytes', Value.SizeBytes),
    F('• CreateTime', Value.CreateTime),
    F('• UpdateTime', Value.UpdateTime),
    F('• ExpirationTime', Value.ExpirationTime),
    F('• Sha256Hash', Value.Sha256Hash),
    F('• Uri', Value.Uri),
    F('• DownloadUri', Value.DownloadUri),
    F('• State', Value.State.ToString),
    F('• Source', Value.Source.ToString)
  ]);
  if Assigned(Value.Error) then
    begin
      Display(Sender, F('• Error', Value.Error.Code.ToString));
      Display(Sender, F('• Error', Value.Error.Message));
    end;
  if Assigned(Value.VideoMetadata) then
    Display(Sender, F('• Source', Value.VideoMetadata.videoDuration));
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TFile);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.&File);
end;

procedure Display(Sender: TObject; Value: TFiles);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Files do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TFileDelete);
begin
  Display(Sender, 'file deleted');
end;

procedure Display(Sender: TObject; Value: TCache);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('• Name', Value.Name),
    F('• DisplayName', Value.DisplayName),
    F('• Model', Value.Model),
    F('• CreateTime', Value.CreateTime),
    F('• ExpireTime', Value.ExpireTime)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TCacheContents);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.CachedContents do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TFileSearchStore);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('• Name', Value.Name),
    F('• DisplayName', Value.DisplayName),
    F('• CreateTime', Value.CreateTime),
    F('• UpdateTime', Value.UpdateTime),
    F('• ActiveDocumentsCount', Value.ActiveDocumentsCount.ToString),
    F('• PendingDocumentsCount', Value.PendingDocumentsCount.ToString),
    F('• FailedDocumentsCount', Value.FailedDocumentsCount.ToString),
    F('• SizeBytes', Value.SizeBytes.ToString)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TFileSearchStoreList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.FileSearchStores do
      Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TOperation);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('• Name', Value.Name),
    F('• Done', BoolToStr(Value.Done, True)),
    F('• Metadata', Value.Metadata),
    F('• Response', Value.Response)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TOperationList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Operations do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TFileSearchStoreDelete);
begin
  Display(Sender, 'File store deleted');
end;

procedure Display(Sender: TObject; Value: TDocument);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('• Name', Value.Name),
    F('• DisplayName', Value.DisplayName),
    F('• CreateTime', Value.CreateTime),
    F('• UpdateTime', Value.UpdateTime),
    F('• State', Value.State.ToString),
    F('• SizeBytes', Value.SizeBytes.ToString),
    F('• MimeType', Value.MimeType)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TDocumentList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  if not Value.NextPageToken.IsEmpty then
    Display(Sender, 'NextPageToken' + Value.NextPageToken);
  for var Item in Value.Documents do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TDocumentDelete);
begin
  Display(Sender, 'Deleted');
  Display(Sender);
end;

procedure DisplayStream(Sender: TObject; Value: string);
var
  M: TMemo;
  CurrentLine: string;
  Lines: TArray<string>;
begin
  if Sender is TMemo then
    M := Sender as TMemo
  else
    M := (Sender as TFMXTutorialHub).Memo1;
  var ShouldScroll := M.ViewportPosition.Y >= (M.Content.Height - M.Height - 16);
  M.Lines.BeginUpdate;
  try
    Lines := Value.Replace(#13, '').Split([#10]);
    if System.Length(Lines) > 0 then
    begin
      if M.Lines.Count > 0 then
        CurrentLine := M.Lines[M.Lines.Count - 1]
      else
        CurrentLine := EmptyStr;
      CurrentLine := CurrentLine + Lines[0];
      if M.Lines.Count > 0 then
        M.Lines[M.Lines.Count - 1] := CurrentLine
      else
        M.Lines.Add(CurrentLine);
      for var i := 1 to High(Lines) do
        M.Lines.Add(Lines[i]);
    end;
  finally
    M.Lines.EndUpdate;
  end;
  if ShouldScroll then
    M.ViewportPosition := PointF(M.ViewportPosition.X, M.Content.Height - M.Height + 1);
end;

procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  if Assigned(Value) then
    begin
//      if (Length(Value.Candidates) > 0) and (Value.Candidates[0].FinishReason <> TFinishReason.SAFETY) then
//        begin
          for var Item in Value.Candidates do
            begin
              DisplayStream(Sender, Item.Content.Parts[0].Text);
            end;
          DisplayChunk(Value);
//        end;
    end;
end;

procedure DisplayChunk(Value: string);
begin
  if Value.Trim.IsEmpty then
    Exit;

  var JSONValue := TJSONObject.ParseJSONValue(Value);
  TutorialHub.Memo4.Lines.BeginUpdate;
  try
    Display(TutorialHub.Memo4, JSONValue.ToString);
  finally
    TutorialHub.Memo4.Lines.EndUpdate;
    JSONValue.Free;
  end;
end;

procedure DisplayChunk(Value: TChat);
begin
  DisplayChunk(Value.JSONResponse);
end;

function F(const Name, Value: string): string;
begin
  if not Value.IsEmpty then
    Result := Format('%s: %s', [Name, Value])
end;

function F(const Name: string; const Value: TArray<string>): string;
begin
  Result := Name;
  for var Item in Value do
    begin
      Result := Result + #10 + #9'• ' + Item;
    end;
end;

function F(const Name: string; const Value: boolean): string;
begin
  Result := Format('%s: %s', [Name, BoolToStr(Value, True)])
end;

function F(const Name: string; const State: Boolean; const Value: Double): string;
begin
  Result := Format('%s (%s): %s%%', [Name, BoolToStr(State, True), (Value * 100).ToString(ffNumber, 3, 2)])
end;

{ TFMXTutorialHub }

constructor TFMXTutorialHub.Create(const AClient: IGemini; const AMemo1, AMemo2,
  AMemo3, AMemo4: TMemo; const AButton: TButton);
begin
  inherited Create;
  Memo1 := AMemo1;
  Memo2 := AMemo2;
  Memo3 := AMemo3;
  Memo4 := AMemo4;
  Button := AButton;
  Client := AClient;
end;

procedure TFMXTutorialHub.JSONRequestClear;
begin
  Memo3.Lines.Clear;
end;

procedure TFMXTutorialHub.JSONResponseClear;
begin
  Memo4.Lines.Clear;
end;

procedure TFMXTutorialHub.JSONUIClear;
begin
  JSONRequestClear;
  JSONResponseClear;
end;

procedure TFMXTutorialHub.OnButtonClick(Sender: TObject);
begin
  Cancel := True;
end;

procedure TFMXTutorialHub.SetButton(const Value: TButton);
begin
  FButton := Value;
  FButton.OnClick := OnButtonClick;
  FButton.Text := 'Cancel';
end;

procedure TFMXTutorialHub.SetJSONRequest(const Value: string);
begin
  Memo3.Lines.Text := Value;
  Memo3.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TFMXTutorialHub.SetJSONResponse(const Value: string);
begin
  Memo4.Lines.Text := Value;
  Memo4.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TFMXTutorialHub.SetMemo1(const Value: TMemo);
begin
  FMemo1 := Value;
  FMemo1.TextSettings.WordWrap := True;
end;

procedure TFMXTutorialHub.SetMemo2(const Value: TMemo);
begin
  FMemo2 := Value;
  FMemo2.TextSettings.WordWrap := False;
end;

procedure TFMXTutorialHub.SetMemo3(const Value: TMemo);
begin
  FMemo3 := Value;
  FMemo3.TextSettings.WordWrap := False;
end;

procedure TFMXTutorialHub.SetMemo4(const Value: TMemo);
begin
  FMemo4 := Value;
  FMemo4.TextSettings.WordWrap := False;
end;

initialization
finalization
  if Assigned(TutorialHub) then
    TutorialHub.Free;
end.
