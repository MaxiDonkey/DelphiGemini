unit Gemini.Embeddings;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, REST.Json.Types, System.JSON,
  Gemini.API, Gemini.API.Params, Gemini.Async.Support,
  Gemini.Types, Gemini.Chat.Request, Gemini.Async.Promise;

type
  /// <summary>
  /// Represents the parameters required to create an embedding request.
  /// </summary>
  /// <remarks>
  /// This class encapsulates all necessary information for generating embeddings, including the model to use,
  /// the content to embed, the type of task, an optional title, and the desired output dimensionality.
  /// </remarks>
  TEmbeddingsParams = class(TJSONParam)
    /// <summary>
    /// Required. Contents to embed.
    /// </summary>
    function Content(const Value: TArray<string>): TEmbeddingsParams; overload;

    /// <summary>
    /// Required. The content to embed. Only the parts.text fields will be counted.
    /// </summary>
    function Content(const Value: TContentPayload): TEmbeddingsParams; overload;

    /// <summary>
    /// Optional. Optional task type for which the embeddings will be used. Not supported on earlier
    /// models (models/embedding-001).
    /// </summary>
    function TaskType(const Value: TTaskType): TEmbeddingsParams;

    /// <summary>
    /// Optional. An optional title for the text. Only applicable when TaskType is RETRIEVAL_DOCUMENT.
    /// </summary>
    /// <remarks>
    /// Specifying a title for RETRIEVAL_DOCUMENT provides better quality embeddings for retrieval.
    /// </remarks>
    function Title(const Value: string): TEmbeddingsParams;

    /// <summary>
    /// Optional. Optional reduced dimension for the output embedding.
    /// </summary>
    /// <remarks>
    /// If set, excessive values in the output embedding are truncated from the end. Supported by newer
    /// models since 2024 only. You cannot set this value if using the earlier model (models/embedding-001).
    /// </remarks>
    function OutputDimensionality(const Value: Integer): TEmbeddingsParams;
  end;

  /// <summary>
  /// Builder for a single embed-content request entry used by batch embedding endpoints.
  /// </summary>
  /// <remarks>
  /// <c>TEmbedContentParams</c> encapsulates the parameters for one embedding request within a batch, including
  /// the target model, the content to embed (as plain strings or a <c>TContentPayload</c>), an optional task type,
  /// an optional title (only applicable to retrieval-document use cases), and an optional reduced output dimensionality.
  /// <para>
  /// Instances of this class are typically created and configured fluently, then supplied to
  /// <c>TEmbeddingBatchParams.Requests</c>. When used in a batch request, the <c>model</c> specified here must match
  /// the model declared at the batch level.
  /// </para>
  /// </remarks>
  TEmbedContentParams = class(TJSONParam)
    /// <summary>
    /// Required. The model's resource name. This serves as an ID for the Model to use.
    /// </summary>
    /// <remarks>
    /// This name should match a model name returned by the ListModels method.
    /// </remarks>
    function Model(const Value: string): TEmbedContentParams;

    /// <summary>
    /// Required. Contents to embed.
    /// </summary>
    function Content(const Value: TArray<string>): TEmbedContentParams; overload;

    /// <summary>
    /// Required. The content to embed. Only the parts.text fields will be counted.
    /// </summary>
    function Content(const Value: TContentPayload): TEmbedContentParams; overload;

    /// <summary>
    /// Optional. Optional task type for which the embeddings will be used. Not supported on earlier
    /// models (models/embedding-001).
    /// </summary>
    function TaskType(const Value: TTaskType): TEmbedContentParams;

    /// <summary>
    /// Optional. An optional title for the text. Only applicable when TaskType is RETRIEVAL_DOCUMENT.
    /// </summary>
    /// <remarks>
    /// Specifying a title for RETRIEVAL_DOCUMENT provides better quality embeddings for retrieval.
    /// </remarks>
    function Title(const Value: string): TEmbedContentParams;

    /// <summary>
    /// Optional. Optional reduced dimension for the output embedding.
    /// </summary>
    /// <remarks>
    /// If set, excessive values in the output embedding are truncated from the end. Supported by newer
    /// models since 2024 only. You cannot set this value if using the earlier model (models/embedding-001).
    /// </remarks>
    function OutputDimensionality(const Value: Integer): TEmbedContentParams;

    class function NewEmbedContentParams(const Model: string; const Content: TArray<string>): TEmbedContentParams; overload;
    class function NewEmbedContentParams(const Model: string; const Content: TContentPayload): TEmbedContentParams; overload;
  end;

  /// <summary>
  /// Represents the parameters required for a batch embedding request.
  /// </summary>
  /// <remarks>
  /// This class encapsulates a collection of embedding requests, allowing for the processing of multiple inputs
  /// in a single API call. Each request in the batch must conform to the specified model.
  /// </remarks>
  TEmbeddingBatchParams = class(TJSONParam)
    /// <summary>
    /// Required. Embed requests for the batch. The model in each of these requests must match the model
    /// specified BatchEmbedContentsRequest.model.
    /// </summary>
    function Requests(const Value: TArray<TEmbedContentParams>): TEmbeddingBatchParams;
  end;

  /// <summary>
  /// Represents the content embedding generated from input text.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the embedding values produced by an embedding model,
  /// allowing for access to the numerical representation of the content.
  /// </remarks>
  TEmbedContent = class
  private
    FValues: TArray<Double>;
  public
    /// <summary>
    /// The embedding values.
    /// </summary>
    property Values: TArray<Double> read FValues write FValues;
  end;

  /// <summary>
  /// Represents an embedding generated from input content.
  /// </summary>
  /// <remarks>
  /// The <c>TEmbedding</c> class encapsulates a numerical representation of text content,
  /// generated by an embedding model. It can be used for various tasks, such as search, retrieval,
  /// and natural language processing.
  /// </remarks>
  TEmbedding = class(TJSONFingerprint)
  private
    FEmbedding: TEmbedContent;
  public
    /// <summary>
    /// Output only. The embedding generated from the input content.
    /// </summary>
    property Embedding: TEmbedContent read FEmbedding write FEmbedding;

    /// <summary>
    /// Destructor to free resources associated with the embedding.
    /// </summary>
    /// <remarks>
    /// This destructor ensures that the memory allocated for the <c>TEmbeddingValues</c>
    /// instance is properly released when the <c>TEmbedding</c> instance is destroyed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the embedding generated from input content.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the embedding result, providing access to the generated
  /// content embedding, which can be utilized for various applications such as search,
  /// retrieval, and natural language processing tasks.
  /// </remarks>
  TEmbeddingList = class(TJSONFingerprint)
  private
    FEmbeddings: TArray<TEmbedContent>;
  public
    /// <summary>
    /// The embeddings for each request, in the same order as provided in the batch request.
    /// </summary>
    property Embeddings: TArray<TEmbedContent> read FEmbeddings write FEmbeddings;

    /// <summary>
    /// Destructor to free resources associated with the embedding.
    /// </summary>
    /// <remarks>
    /// This destructor ensures that the memory allocated for the <c>TEmbeddingValues</c>
    /// instance is properly released when the <c>TEmbedding</c> instance is destroyed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callbacks for a model search request using <c>TEmbedding</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynEmbedding</c> type extends the <c>TAsynParams&lt;TEmbedding&gt;</c> record to handle the lifecycle of an asynchronous model operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking model search operations and is specifically tailored for scenarios where multiple model choices are required.
  /// </remarks>
  TAsynEmbedding = TAsynCallBack<TEmbedding>;

  /// <summary>
  /// Promise-style callback container for operations that return a <c>TEmbedding</c>.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseEmbedding</c> is a specialization of <c>TPromiseCallback&lt;TEmbedding&gt;</c> intended for
  /// promise-based embedding endpoints (e.g., async/await wrappers). It groups lifecycle callbacks that may be
  /// invoked while the promise is pending and when it settles (resolved with a <c>TEmbedding</c> or rejected with an error).
  /// <para>
  /// This type only defines the callback bundle; it does not execute any asynchronous work by itself.
  /// </para>
  /// </remarks>
  TPromiseEmbedding = TPromiseCallback<TEmbedding>;

  /// <summary>
  /// Manages asynchronous callbacks for a model search request using <c>TEmbeddingList</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynEmbeddingList</c> type extends the <c>TAsynParams&lt;TEmbeddingList&gt;</c> record to handle the lifecycle of an asynchronous model operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking model search operations and is specifically tailored for scenarios where multiple model choices are required.
  /// </remarks>
  TAsynEmbeddingList = TAsynCallBack<TEmbeddingList>;

  /// <summary>
  /// Promise-style callback container for operations that return a <c>TEmbeddingList</c>.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseEmbeddingList</c> is a specialization of <c>TPromiseCallback&lt;TEmbeddingList&gt;</c> intended for
  /// promise-based batch embedding endpoints (e.g., async/await wrappers). It groups lifecycle callbacks that may be
  /// invoked while the promise is pending and when it settles (resolved with a <c>TEmbeddingList</c> or rejected with an error).
  /// <para>
  /// This type only defines the callback bundle; it does not execute any asynchronous work by itself.
  /// </para>
  /// </remarks>
  TPromiseEmbeddingList = TPromiseCallback<TEmbeddingList>;

  TAbstractSupport = class(TGeminiAPIRoute)
  protected
    function Create(const ModelName: string;
      const ParamProc: TProc<TEmbeddingsParams>): TEmbedding; overload; virtual; abstract;

    function Create(const ModelName: string;
      const Value: TArray<string>): TEmbedding; overload; virtual; abstract;

    function CreateBatch(const ModelName: string;
      const ParamProc: TProc<TEmbeddingBatchParams>): TEmbeddingList; virtual; abstract;
  end;

  TAsynchronousSupport = class(TAbstractSupport)
  protected
    procedure AsynCreate(const ModelName: string;
      const ParamProc: TProc<TEmbeddingsParams>;
      const CallBacks: TFunc<TAsynEmbedding>); overload;

    procedure AsynCreate(const ModelName: string;
      const Value: TArray<string>;
      const CallBacks: TFunc<TAsynEmbedding>); overload;

    procedure AsynCreateBatch(const ModelName: string;
      const ParamProc: TProc<TEmbeddingBatchParams>;
      const CallBacks: TFunc<TAsynEmbeddingList>);
  end;

  /// <summary>
  /// Represents the route for embedding operations in the Gemini API.
  /// </summary>
  /// <remarks>
  /// This class provides methods for performing both synchronous and asynchronous embedding requests
  /// using various models. It manages the currently used model and facilitates embedding operations
  /// by allowing users to set parameters and handle results through callbacks.
  /// </remarks>
  TEmbeddingsRoute = class(TAsynchronousSupport)
    /// <summary>
    /// Performs a synchronous embedding request and returns the result.
    /// </summary>
    /// <param name="ModelName">
    /// The name of the model
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to set up the embedding parameters.
    /// </param>
    /// <returns>
    /// An instance of <c>TEmbedding</c> containing the embedding results.
    /// </returns>
    function Create(const ModelName: string;
      const ParamProc: TProc<TEmbeddingsParams>): TEmbedding; overload; override;

    /// <summary>
    /// Performs a synchronous embedding request and returns the result.
    /// </summary>
    /// <param name="ModelName">
    /// The name of the model
    /// </param>
    /// <param name="Value">
    /// An array of string
    /// </param>
    /// <returns>
    /// An instance of <c>TEmbedding</c> containing the embedding results.
    /// </returns>
    function Create(const ModelName: string;
      const Value: TArray<string>): TEmbedding; overload; override;

    /// <summary>
    /// Performs a synchronous embedding request for a batch and returns the result.
    /// </summary>
    /// <param name="ModelName">
    /// The name of the model
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to set up the embedding parameters.
    /// </param>
    /// <returns>
    /// An instance of <c>TEmbeddingList</c> containing the embedding results.
    /// </returns>
    function CreateBatch(const ModelName: string;
      const ParamProc: TProc<TEmbeddingBatchParams>): TEmbeddingList; override;

    /// <summary>
    /// Asynchronously creates an embedding using a promise-based interface.
    /// </summary>
    /// <param name="ModelName">
    /// The model resource name (or base model id) to use for the embedding request. If required by the route,
    /// the name may be normalized (e.g., prefixed with <c>models/</c>).
    /// </param>
    /// <param name="ParamProc">
    /// A configuration procedure used to populate the embedding request parameters (content, task type, title,
    /// output dimensionality, etc.).
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function that returns a <c>TPromiseEmbedding</c> record containing lifecycle callbacks that may be
    /// invoked while the promise is pending and when it settles (success or error).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TEmbedding&gt;</c> that resolves with the resulting <c>TEmbedding</c> instance, or rejects with an
    /// exception on failure.
    /// </returns>
    /// <remarks>
    /// Use this overload when you want full control over the embedding request parameters via <paramref name="ParamProc"/>.
    /// </remarks>
    function AsyncAwaitCreate(const ModelName: string;
      const ParamProc: TProc<TEmbeddingsParams>;
      const Callbacks: TFunc<TPromiseEmbedding> = nil): TPromise<TEmbedding>; overload;

    /// <summary>
    /// Asynchronously creates an embedding from an array of input strings using a promise-based interface.
    /// </summary>
    /// <param name="ModelName">
    /// The model resource name (or base model id) to use for the embedding request. If required by the route,
    /// the name may be normalized (e.g., prefixed with <c>models/</c>).
    /// </param>
    /// <param name="Value">
    /// The input text items to embed. Each item is sent as a <c>parts.text</c> entry in the request content.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function that returns a <c>TPromiseEmbedding</c> record containing lifecycle callbacks that may be
    /// invoked while the promise is pending and when it settles (success or error).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TEmbedding&gt;</c> that resolves with the resulting <c>TEmbedding</c> instance, or rejects with an
    /// exception on failure.
    /// </returns>
    /// <remarks>
    /// This overload is a convenience wrapper that builds the request parameters by calling
    /// <c>TEmbeddingsParams.Content(Value)</c> internally.
    /// </remarks>
    function AsyncAwaitCreate(const ModelName: string;
      const Value: TArray<string>;
      const Callbacks: TFunc<TPromiseEmbedding> = nil): TPromise<TEmbedding>; overload;

    /// <summary>
    /// Asynchronously creates embeddings for a batch of requests using a promise-based interface.
    /// </summary>
    /// <param name="ModelName">
    /// The model resource name (or base model id) to use for the batch embedding request. If required by the route,
    /// the name may be normalized (e.g., prefixed with <c>models/</c>).
    /// </param>
    /// <param name="ParamProc">
    /// A configuration procedure used to populate the batch request parameters, including the array of
    /// <c>TEmbedContentParams</c> entries to embed.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function that returns a <c>TPromiseEmbeddingList</c> record containing lifecycle callbacks that may be
    /// invoked while the promise is pending and when it settles (success or error).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TEmbeddingList&gt;</c> that resolves with the resulting <c>TEmbeddingList</c> instance, or rejects with an
    /// exception on failure.
    /// </returns>
    /// <remarks>
    /// Use this overload when you need to submit multiple embedding requests in a single API call.
    /// The resulting <c>TEmbeddingList</c> contains embeddings in the same order as the requests provided.
    /// </remarks>
    function AsyncAwaitCreateBatch(const ModelName: string;
      const ParamProc: TProc<TEmbeddingBatchParams>;
      const Callbacks: TFunc<TPromiseEmbeddingList> = nil): TPromise<TEmbeddingList>; overload;

  end;

implementation

uses
  System.StrUtils, Rest.Json;

{ TEmbeddingsRoute }

function TEmbeddingsRoute.AsyncAwaitCreate(const ModelName: string;
  const ParamProc: TProc<TEmbeddingsParams>;
  const Callbacks: TFunc<TPromiseEmbedding>): TPromise<TEmbedding>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TEmbedding>(
    procedure(const CallbackParams: TFunc<TAsynEmbedding>)
    begin
      Self.AsynCreate(ModelName, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TEmbeddingsRoute.AsyncAwaitCreate(const ModelName: string;
  const Value: TArray<string>;
  const Callbacks: TFunc<TPromiseEmbedding>): TPromise<TEmbedding>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TEmbedding>(
    procedure(const CallbackParams: TFunc<TAsynEmbedding>)
    begin
      Self.AsynCreate(ModelName, Value, CallbackParams);
    end,
    Callbacks);
end;

function TEmbeddingsRoute.AsyncAwaitCreateBatch(const ModelName: string;
  const ParamProc: TProc<TEmbeddingBatchParams>;
  const Callbacks: TFunc<TPromiseEmbeddingList>): TPromise<TEmbeddingList>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TEmbeddingList>(
    procedure(const CallbackParams: TFunc<TAsynEmbeddingList>)
    begin
      Self.AsynCreateBatch(ModelName, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TEmbeddingsRoute.Create(const ModelName: string;
  const ParamProc: TProc<TEmbeddingsParams>): TEmbedding;
begin
  Result := API.Post<TEmbedding, TEmbeddingsParams>(SetModel(ModelName, ':embedContent'), ParamProc);
end;

function TEmbeddingsRoute.Create(const ModelName: string;
  const Value: TArray<string>): TEmbedding;
begin
  Result := Create(ModelName,
    procedure (Params: TEmbeddingsParams)
    begin
      Params.Content(Value);
    end);
end;

function TEmbeddingsRoute.CreateBatch(const ModelName: string;
  const ParamProc: TProc<TEmbeddingBatchParams>): TEmbeddingList;
begin
  Result := API.Post<TEmbeddingList, TEmbeddingBatchParams>(SetModel(ModelName, ':batchEmbedContents'), ParamProc);
end;

{ TEmbeddingBatchParams }

function TEmbeddingBatchParams.Requests(
  const Value: TArray<TEmbedContentParams>): TEmbeddingBatchParams;
begin
  Result := TEmbeddingBatchParams(Add('requests',
    TJSONHelper.ToJsonArray<TEmbedContentParams>(Value)));
end;

{ TEmbedding }

destructor TEmbedding.Destroy;
begin
  if Assigned(FEmbedding) then
    FEmbedding.Free;
  inherited;
end;

{ TEmbeddingsParams }

function TEmbeddingsParams.Content(
  const Value: TArray<string>): TEmbeddingsParams;
begin
  var PartsJSON := TJSONArray.Create;
  for var Item in Value do
      PartsJSON.Add(TJSONObject.Create.AddPair('text', Item));

  var ContentJSON := TJSONObject.Create;

  ContentJSON.AddPair('parts', PartsJSON);

  Result := TEmbeddingsParams(Add('content', ContentJSON));
end;

function TEmbeddingsParams.Content(
  const Value: TContentPayload): TEmbeddingsParams;
begin
  Result := TEmbeddingsParams(Add('Content', Value.Detach));
end;

function TEmbeddingsParams.OutputDimensionality(
  const Value: Integer): TEmbeddingsParams;
begin
  Result := TEmbeddingsParams(Add('outputDimensionality', Value));
end;

function TEmbeddingsParams.TaskType(const Value: TTaskType): TEmbeddingsParams;
begin
  Result := TEmbeddingsParams(Add('taskType', Value.ToString));
end;

function TEmbeddingsParams.Title(const Value: string): TEmbeddingsParams;
begin
  Result := TEmbeddingsParams(Add('title', Value));
end;

{ TEmbedContentParams }

function TEmbedContentParams.Content(
  const Value: TArray<string>): TEmbedContentParams;
begin
  var PartsJSON := TJSONArray.Create;
  for var Item in Value do
    begin
      PartsJSON.Add(TJSONObject.Create.AddPair('text', Item));
    end;

  var ContentJSON := TJSONObject.Create;
  ContentJSON.AddPair('parts', PartsJSON);

  Result := TEmbedContentParams(Add('content', ContentJSON));
end;

function TEmbedContentParams.Content(
  const Value: TContentPayload): TEmbedContentParams;
begin
  Result := TEmbedContentParams(Add('Content', Value.Detach));
end;

function TEmbedContentParams.Model(const Value: string): TEmbedContentParams;
begin
  Result := TEmbedContentParams(Add('model', TGeminiAPIModel.ModelNormalize(Value)));
end;

class function TEmbedContentParams.NewEmbedContentParams(const Model: string;
  const Content: TContentPayload): TEmbedContentParams;
begin
  Result := TEmbedContentParams.Create
    .Model(Model)
    .Content(Content);
end;

class function TEmbedContentParams.NewEmbedContentParams(
  const Model: string;
  const Content: TArray<string>): TEmbedContentParams;
begin
  Result := TEmbedContentParams.Create
    .Model(Model)
    .Content(Content);
end;

function TEmbedContentParams.OutputDimensionality(
  const Value: Integer): TEmbedContentParams;
begin
  Result := TEmbedContentParams(Add('outputDimensionality', Value));
end;

function TEmbedContentParams.TaskType(
  const Value: TTaskType): TEmbedContentParams;
begin
  Result := TEmbedContentParams(Add('taskType', Value.ToString));
end;

function TEmbedContentParams.Title(const Value: string): TEmbedContentParams;
begin
  Result := TEmbedContentParams(Add('title', Value));
end;

{ TEmbeddingList }

destructor TEmbeddingList.Destroy;
begin
  for var Item in FEmbeddings do
    Item.Free;
  inherited;
end;

{ TAsynchronousSupport }

procedure TAsynchronousSupport.AsynCreate(const ModelName: string;
  const ParamProc: TProc<TEmbeddingsParams>;
  const CallBacks: TFunc<TAsynEmbedding>);
begin
  with TAsynCallBackExec<TAsynEmbedding, TEmbedding>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TEmbedding
      begin
        Result := Self.Create(ModelName, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TAsynchronousSupport.AsynCreate(const ModelName: string;
  const Value: TArray<string>; const CallBacks: TFunc<TAsynEmbedding>);
begin
  with TAsynCallBackExec<TAsynEmbedding, TEmbedding>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TEmbedding
      begin
        Result := Self.Create(ModelName, Value);
      end);
  finally
    Free;
  end;
end;

procedure TAsynchronousSupport.AsynCreateBatch(const ModelName: string;
  const ParamProc: TProc<TEmbeddingBatchParams>;
  const CallBacks: TFunc<TAsynEmbeddingList>);
begin
  with TAsynCallBackExec<TAsynEmbeddingList, TEmbeddingList>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TEmbeddingList
      begin
        Result := Self.CreateBatch(ModelName, ParamProc);
      end);
  finally
    Free;
  end;
end;

end.
