unit Gemini.Chat;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils,
  Gemini.API, Gemini.Async.Support, Gemini.Async.Promise, Gemini.Chat.Request,
  Gemini.Chat.Response;

type
  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="Chat">
  /// The <c>TChat</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Chat</c> parameter will be <c>nil</c>.
  /// </remarks>
  TChatEvent = reference to procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean);

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynChat = TAsynCallBack<TChat>;

  /// <summary>
  /// Manages asynchronous responses callBacks for a promise request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TPromiseChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// </remarks>
  TPromiseChat = TPromiseCallback<TChat>;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChatStream</c> type extends the <c>TAsynStreamParams&lt;TChat&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynChatStream = TAsynStreamCallBack<TChat>;

  /// <summary>
  /// Manages asynchronous streaming responses callBacks for a responses request using <c>TResponseChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TPromiseChatStream</c> type extends the <c>TAsynStreamParams&lt;TChatm&gt;</c> record to support the lifecycle of an asynchronous streaming responses operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the responses response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TPromiseChatStream = TPromiseStreamCallback<TChat>;

  /// <summary>
  /// The <c>TChatRoute</c> class inherits from <c>TGeminiAPIRoute</c> and provides an interface for managing various interactions with the chat API.
  /// It supports creating chat completion requests in synchronous, asynchronous, and streaming modes, offering mechanisms to handle responses generated by the model.
  /// </summary>
  /// <remarks>
  /// This class facilitates sending messages to a chat model, receiving responses, and managing them, whether synchronously or asynchronously.
  /// The primary methods in the class are:
  /// <para>
  /// - <c>Create</c> : Sends a chat request and waits for a full response.
  /// </para>
  /// <para>
  /// - <c>AsynCreate</c> : Performs an asynchronous chat completion request with event handling.
  /// </para>
  /// <para>
  /// - <c>CreateStream</c> : Initiates a chat completion request in streaming mode, receiving tokens progressively.
  /// </para>
  /// <para>
  /// - <c>ASynCreateStream</c> : Performs an asynchronous request in streaming mode with event handling.
  /// </para>
  /// Each method allows configuring model parameters, setting input messages, managing token limits, and including callbacks for processing responses or errors.
  /// </remarks>
  TChatRoute = class(TGeminiAPIRoute)
  public
    /// <summary>
    /// Creates an asynchronous chat completion request using a promise-based
    /// interface.
    /// </summary>
    /// <param name="ModelName">
    /// The name of the model to use for the chat request.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure used to configure the <c>TChatParams</c> for the request,
    /// such as messages, tools, and generation options.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function that returns a <c>TPromiseChat</c> record
    /// containing callbacks invoked when the promise is resolved or rejected.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TChat&gt;</c> that resolves with the generated
    /// <c>TChat</c> response or rejects with an exception.
    /// </returns>
    /// <remarks>
    /// Use this method when you want to await a chat completion in an
    /// asynchronous workflow while still having access to promise-style
    /// callbacks for success, error, or lifecycle handling.
    /// </remarks>
    function AsyncAwaitCreate(const ModelName: string;
      const ParamProc: TProc<TChatParams>;
      const Callbacks: TFunc<TPromiseChat> = nil): TPromise<TChat>;

    /// <summary>
    /// Creates an asynchronous streaming chat request using a promise-based
    /// interface.
    /// </summary>
    /// <param name="ModelName">
    /// The name of the model to use for the streaming chat request.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure used to configure the <c>TChatParams</c> for the request,
    /// including messages, tools, and generation options.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns a <c>TPromiseChatStream</c> record containing
    /// callbacks invoked during streaming (progress, success, error, cancel).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;string&gt;</c> that resolves with the concatenated
    /// streamed text or rejects with an exception.
    /// </returns>
    /// <remarks>
    /// Use this method when you want to consume a streamed chat response in
    /// an asynchronous workflow, while also receiving per-chunk callbacks and
    /// a final aggregated string when the stream completes.
    /// </remarks>
    function AsyncAwaitCreateStream(const ModelName: string;
      const ParamProc: TProc<TChatParams>;
      const Callbacks: TFunc<TPromiseChatStream>): TPromise<string>;

    /// <summary>
    /// Creates a completion for the chat message using the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, such as selecting the model, providing messages, setting token limits, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TChat</c> object that contains the chat response, including the choices generated by the model.
    /// </returns>
    /// <exception cref="GeminiExceptionAPI">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="GeminiExceptionInvalidRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>Create</c> method sends a chat completion request and waits for the full response. The returned <c>TChat</c> object contains the model's generated response, including multiple choices if available.
    ///
    /// Example usage:
    /// <code>
    ///   var Gemini := TGeminiFactory.CreateInstance(BaererKey);
    ///   var Chat := Gemini.Chat.Create(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///     end);
    ///   try
    ///     for var Item in Chat.Candidates do
    ///       WriteLn(Item.Text);
    ///   finally
    ///     Chat.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(const ModelName: string; ParamProc: TProc<TChatParams>): TChat;

    /// <summary>
    /// Creates a chat message completion with a streamed response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, such as selecting the model, providing messages, and adjusting other settings like token limits or temperature.
    /// </param>
    /// <param name="Event">
    /// A callback of type <c>TChatEvent</c> that is triggered with each chunk of data received during the streaming process. It includes the current state of the <c>TChat</c> object, a flag indicating if the stream is done, and a boolean to handle cancellation.
    /// </param>
    /// <returns>
    /// Returns <c>True</c> if the streaming process started successfully, <c>False</c> otherwise.
    /// </returns>
    /// <remarks>
    /// This method initiates a chat request in streaming mode, where the response is delivered incrementally in real-time.
    /// The <c>Event</c> callback will be invoked multiple times as tokens are received.
    /// When the response is complete, the <c>IsDone</c> flag will be set to <c>True</c>, and the <c>Chat</c> object will be <c>nil</c>.
    /// The streaming process can be interrupted by setting the <c>Cancel</c> flag to <c>True</c> within the event.
    ///
    /// Example usage:
    /// <code>
    ///   var Gemini := TGeminiFactory.CreateInstance(BaererKey);
    ///   Gemini.Chat.CreateStream(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///       Params.Stream(True);
    ///     end,
    ///
    ///     procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // Handle displaying
    ///     end
    ///   );
    /// </code>
    /// </remarks>
    function CreateStream(const ModelName: string; ParamProc: TProc<TChatParams>; Event: TChatEvent): Boolean;

    /// <summary>
    /// Create an asynchronous completion for chat message
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the chat request, such as model selection, messages, and other parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for the asynchronous chat completion, such as on success and on error.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate a chat completion based on the provided parameters. The response or error is handled by the provided callBacks.
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var Gemini := TGeminiFactory.CreateInstance(BaererKey);
    /// Gemini.Chat.AsynCreate(
    ///   procedure (Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///   end,
    ///   function: TAsynChat
    ///   begin
    ///     Result.Sender := Memo1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Chat: TChat)
    ///     begin
    ///       var M := Sender as TMemo; // Because Result.Sender = Memo1
    ///       // Handle success operation
    ///     end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Value: string)
    ///     begin
    ///       // Handle error message
    ///     end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreate(const ModelName: string; ParamProc: TProc<TChatParams>;
      CallBacks: TFunc<TAsynChat>);

    /// <summary>
    /// Creates an asynchronous streaming chat completion request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, including the model, messages, and additional options such as max tokens and streaming mode.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynChatStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous chat operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// CheckBox1.Checked := False;  //Click to stop the streaming
    /// // WARNING - Move the following line into the main OnCreate
    /// //var Gemini := TGeminiFactory.CreateInstance(BaererKey);
    /// Gemini.Chat.AsynCreateStream(
    ///   procedure(Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///   end,
    ///
    ///   function: TAsynChatStream
    ///   begin
    ///     Result.Sender := Memo1; // Instance passed to callback parameter
    ///     Result.OnProgress :=
    ///         procedure (Sender: TObject; Chat: TChat)
    ///         begin
    ///           // Handle progressive updates to the chat response
    ///         end;
    ///     Result.OnSuccess :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Handle success when the operation completes
    ///         end;
    ///     Result.OnError :=
    ///         procedure (Sender: TObject; Value: string)
    ///         begin
    ///           // Handle error message
    ///         end;
    ///     Result.OnDoCancel :=
    ///         function: Boolean
    ///         begin
    ///           Result := CheckBox1.Checked; // Click on checkbox to cancel
    ///         end;
    ///     Result.OnCancellation :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Processing when process has been canceled
    ///         end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreateStream(const ModelName: string; ParamProc: TProc<TChatParams>;
      CallBacks: TFunc<TAsynChatStream>);
  end;

implementation

uses
  System.Classes, System.Threading, System.SyncObjs,
  Rest.Json,
  Gemini.Async.Params, Gemini.API.Streams, Gemini.API.SSEDecoder;

{ TChatRoute }

function TChatRoute.AsyncAwaitCreate(
  const ParamProc: TProc<TChatParams>;
  const Callbacks: TFunc<TPromiseChat>): TPromise<TChat>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TChat>(
    procedure(const CallbackParams: TFunc<TAsynChat>)
    begin
      AsynCreate(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TChatRoute.AsyncAwaitCreateStream(
  const ParamProc: TProc<TChatParams>;
  const Callbacks: TFunc<TPromiseChatStream>): TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    var
      Buffer: string;
    begin
      AsynCreateStream(ModelName, ParamProc,
        function : TAsynChatStream
        begin
          Result.Sender := Callbacks.Sender;

          Result.OnStart := Callbacks.OnStart;

          Result.OnProgress :=
            procedure (Sender: TObject; Event: TChat)
            begin
              if Assigned(Callbacks.OnProgress) then
                Callbacks.OnProgress(Sender, Event);
              Buffer := Buffer + Event.Candidates[0].Content.Parts[0].Text;
            end;

          Result.OnSuccess :=
            procedure (Sender: TObject)
            begin
              Resolve(Buffer);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              if Assigned(Callbacks.OnError) then
                Error := Callbacks.OnError(Sender, Error);
              Reject(Exception.Create(Error));
            end;

          Result.OnDoCancel :=
            function : Boolean
            begin
              if Assigned(Callbacks.OnDoCancel) then
                Result := Callbacks.OnDoCancel()
              else
                Result := False;
            end;

          Result.OnCancellation :=
            procedure (Sender: TObject)
            begin
              var Error := 'aborted';
              if Assigned(Callbacks.OnCancellation) then
                Error := Callbacks.OnCancellation(Sender);
              Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

procedure TChatRoute.AsynCreate(const ModelName: string;
  ParamProc: TProc<TChatParams>; CallBacks: TFunc<TAsynChat>);
begin
  with TAsynCallBackExec<TAsynChat, TChat>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.Create(ModelName, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TChatRoute.AsynCreateStream(const ModelName: string;
  ParamProc: TProc<TChatParams>; CallBacks: TFunc<TAsynChatStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynChatStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;
  var CancelTag := 0;

  var Task: ITask := TTask.Create(
        procedure()
        begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ModelName, ParamProc,
                procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                      procedure
                      begin
                        Stop := OnDoCancel();
                      end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if (CancelTag = 0) and Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Inc(CancelTag);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Chat) then
                    begin
                      var LocalChat := Chat;
                      Chat := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(nil, //TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalChat);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalChat.Free;
                          end;
                        end)
                      else
                       LocalChat.Free;
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
        end);
  Task.Start;
end;

function TChatRoute.Create(const ModelName: string; ParamProc: TProc<TChatParams>): TChat;
begin
  Result := API.Post<TChat, TChatParams>(SetModel(ModelName, ':generateContent'), ParamProc);
end;

function TChatRoute.CreateStream(const ModelName: string; ParamProc: TProc<TChatParams>;
  Event: TChatEvent): Boolean;
var
  Response: TLockedMemoryStream;
  RetPos: Int64;
  Prev: Int64;
  Decoder: TSSEDecoder;
  DoneSent: Boolean;
begin
  Response := TLockedMemoryStream.Create;
  try
    RetPos := 0;
    Prev := 0;
    DoneSent := False;

    Decoder := TSSEDecoder.Create(
      procedure(const Data: string; var AAbort: Boolean)
      var
        IsDone: Boolean;
        Chat: TChat;
        TextBuffer: string;
        Line: string;
      begin
        TextBuffer := Data;
        Line := TextBuffer.Trim;

        IsDone := SameText(Line, '[DONE]');
        if IsDone then
          begin
            if not DoneSent then
              begin
                DoneSent := True;
                Chat := nil;
                Event(Chat, True, AAbort);
                FreeAndNil(Chat);
              end;
            Exit;
          end;

        Chat := nil;
        try
          Chat := TApiDeserializer.Parse<TChat>(Line);
        except
          Chat := nil;
        end;

        try
          Event(Chat, False, AAbort);
        finally
          Chat.Free;
        end;
      end);

    try
      Result := API.Post<TChatParams>(
        SetModel(ModelName, ':streamGenerateContent'),
        '&&alt=sse',
        ParamProc,
        Response,
        procedure(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var AAbort: Boolean)
        var
          Bytes: TBytes;
        begin
          {--- Atomic incremental reading (no more Response.Memory without lock) }
          Prev := RetPos;
          if Response.ExtractDelta(RetPos, Bytes) then
            begin
              try
                Decoder.Feed(Bytes, AAbort);
              except
                RetPos := Prev;
                raise;
              end;
            end;
        end);

    finally
      if not DoneSent then
        begin
          var AbortFlag: Boolean;
          AbortFlag := False;
          Decoder.Flush(AbortFlag);

          if not DoneSent then
            begin
              var AAbort: Boolean;
              var Chat: TChat;
              AAbort := False;
              Chat := nil;
              Event(Chat, True, AAbort);
              FreeAndNil(Chat);
            end;
        end;

      Decoder.Free;
    end;

  finally
    Response.Free;
  end;
end;

end.
